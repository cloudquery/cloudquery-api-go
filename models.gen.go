// Package cloudquery_api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package cloudquery_api

import (
	"encoding/json"
	"fmt"
	"time"

	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes  = "basicAuth.Scopes"
	BearerAuthScopes = "bearerAuth.Scopes"
	CookieAuthScopes = "cookieAuth.Scopes"
)

// Defines values for APIKeyScope.
const (
	APIKeyScopeReadAndWrite        APIKeyScope = "read-and-write"
	APIKeyScopeSyncsOperationsOnly APIKeyScope = "syncs-operations-only"
)

// Defines values for AddonCategory.
const (
	AddonCategoryCloudInfrastructure  AddonCategory = "cloud-infrastructure"
	AddonCategoryDatabases            AddonCategory = "databases"
	AddonCategoryEngineeringAnalytics AddonCategory = "engineering-analytics"
	AddonCategoryOther                AddonCategory = "other"
	AddonCategorySalesMarketing       AddonCategory = "sales-marketing"
)

// Defines values for AddonFormat.
const (
	AddonFormatZip AddonFormat = "zip"
)

// Defines values for AddonOrderStatus.
const (
	AddonOrderStatusCancelled AddonOrderStatus = "cancelled"
	AddonOrderStatusCompleted AddonOrderStatus = "completed"
	AddonOrderStatusPending   AddonOrderStatus = "pending"
)

// Defines values for AddonTier.
const (
	AddonTierFree AddonTier = "free"
	AddonTierPaid AddonTier = "paid"
)

// Defines values for AddonType.
const (
	AddonTypeTransformation AddonType = "transformation"
	AddonTypeVisualization  AddonType = "visualization"
)

// Defines values for ContentType.
const (
	ContentTypeImagejpeg ContentType = "image/jpeg"
	ContentTypeImagepng  ContentType = "image/png"
	ContentTypeImagewebp ContentType = "image/webp"
)

// Defines values for EmailTeamInvitationRequestRole.
const (
	EmailTeamInvitationRequestRoleAdmin  EmailTeamInvitationRequestRole = "admin"
	EmailTeamInvitationRequestRoleMember EmailTeamInvitationRequestRole = "member"
)

// Defines values for ManagedDatabaseStatus.
const (
	ManagedDatabaseStatusExpired ManagedDatabaseStatus = "expired"
	ManagedDatabaseStatusFailed  ManagedDatabaseStatus = "failed"
	ManagedDatabaseStatusPending ManagedDatabaseStatus = "pending"
	ManagedDatabaseStatusReady   ManagedDatabaseStatus = "ready"
)

// Defines values for PluginCategory.
const (
	PluginCategoryCloudFinops          PluginCategory = "cloud-finops"
	PluginCategoryCloudInfrastructure  PluginCategory = "cloud-infrastructure"
	PluginCategoryCustomerSupport      PluginCategory = "customer-support"
	PluginCategoryDataWarehouses       PluginCategory = "data-warehouses"
	PluginCategoryDatabases            PluginCategory = "databases"
	PluginCategoryEngineeringAnalytics PluginCategory = "engineering-analytics"
	PluginCategoryFinance              PluginCategory = "finance"
	PluginCategoryFleetManagement      PluginCategory = "fleet-management"
	PluginCategoryHumanResources       PluginCategory = "human-resources"
	PluginCategoryMarketingAnalytics   PluginCategory = "marketing-analytics"
	PluginCategoryOther                PluginCategory = "other"
	PluginCategoryProductAnalytics     PluginCategory = "product-analytics"
	PluginCategoryProjectManagement    PluginCategory = "project-management"
	PluginCategorySalesMarketing       PluginCategory = "sales-marketing"
	PluginCategorySecurity             PluginCategory = "security"
	PluginCategoryShipmentTracking     PluginCategory = "shipment-tracking"
)

// Defines values for PluginKind.
const (
	PluginKindDestination PluginKind = "destination"
	PluginKindSource      PluginKind = "source"
	PluginKindTransformer PluginKind = "transformer"
)

// Defines values for PluginNotificationRequestStatus.
const (
	PluginNotificationRequestStatusPending PluginNotificationRequestStatus = "pending"
	PluginNotificationRequestStatusSent    PluginNotificationRequestStatus = "sent"
)

// Defines values for PluginPackageType.
const (
	PluginPackageTypeDocker PluginPackageType = "docker"
	PluginPackageTypeNative PluginPackageType = "native"
)

// Defines values for PluginPriceCategory.
const (
	PluginPriceCategoryApi      PluginPriceCategory = "api"
	PluginPriceCategoryDatabase PluginPriceCategory = "database"
	PluginPriceCategoryFree     PluginPriceCategory = "free"
)

// Defines values for PluginReleaseStage.
const (
	PluginReleaseStageComingSoon PluginReleaseStage = "coming-soon"
	PluginReleaseStageDeprecated PluginReleaseStage = "deprecated"
	PluginReleaseStageGa         PluginReleaseStage = "ga"
	PluginReleaseStagePreview    PluginReleaseStage = "preview"
)

// Defines values for PluginReleaseStageCreate.
const (
	PluginReleaseStageCreateComingSoon PluginReleaseStageCreate = "coming-soon"
	PluginReleaseStageCreateGa         PluginReleaseStageCreate = "ga"
	PluginReleaseStageCreatePreview    PluginReleaseStageCreate = "preview"
)

// Defines values for PluginReleaseStageUpdate.
const (
	PluginReleaseStageUpdateComingSoon PluginReleaseStageUpdate = "coming-soon"
	PluginReleaseStageUpdateDeprecated PluginReleaseStageUpdate = "deprecated"
	PluginReleaseStageUpdateGa         PluginReleaseStageUpdate = "ga"
	PluginReleaseStageUpdatePreview    PluginReleaseStageUpdate = "preview"
)

// Defines values for PluginTier.
const (
	PluginTierFree     PluginTier = "free"
	PluginTierOpenCore PluginTier = "open-core"
	PluginTierPaid     PluginTier = "paid"
)

// Defines values for TeamPlan.
const (
	TeamPlanEnterprise TeamPlan = "enterprise"
	TeamPlanFree       TeamPlan = "free"
	TeamPlanPaid       TeamPlan = "paid"
	TeamPlanTrial      TeamPlan = "trial"
)

// Defines values for TeamSubscriptionOrderStatus.
const (
	TeamSubscriptionOrderStatusCancelled TeamSubscriptionOrderStatus = "cancelled"
	TeamSubscriptionOrderStatusCompleted TeamSubscriptionOrderStatus = "completed"
	TeamSubscriptionOrderStatusPending   TeamSubscriptionOrderStatus = "pending"
)

// Defines values for AddonSortBy.
const (
	AddonSortByCreatedAt AddonSortBy = "created_at"
	AddonSortByDownloads AddonSortBy = "downloads"
	AddonSortByName      AddonSortBy = "name"
	AddonSortByUpdatedAt AddonSortBy = "updated_at"
)

// Defines values for PluginSortBy.
const (
	PluginSortByCreatedAt PluginSortBy = "created_at"
	PluginSortByDownloads PluginSortBy = "downloads"
	PluginSortByName      PluginSortBy = "name"
	PluginSortByUpdatedAt PluginSortBy = "updated_at"
)

// Defines values for VersionSortBy.
const (
	VersionSortByCreatedAt VersionSortBy = "created_at"
)

// Defines values for ListAddonsParamsSortBy.
const (
	ListAddonsParamsSortByCreatedAt ListAddonsParamsSortBy = "created_at"
	ListAddonsParamsSortByDownloads ListAddonsParamsSortBy = "downloads"
	ListAddonsParamsSortByName      ListAddonsParamsSortBy = "name"
	ListAddonsParamsSortByUpdatedAt ListAddonsParamsSortBy = "updated_at"
)

// Defines values for ListAddonVersionsParamsSortBy.
const (
	ListAddonVersionsParamsSortByCreatedAt ListAddonVersionsParamsSortBy = "created_at"
)

// Defines values for ListPluginsParamsSortBy.
const (
	ListPluginsParamsSortByCreatedAt ListPluginsParamsSortBy = "created_at"
	ListPluginsParamsSortByDownloads ListPluginsParamsSortBy = "downloads"
	ListPluginsParamsSortByName      ListPluginsParamsSortBy = "name"
	ListPluginsParamsSortByUpdatedAt ListPluginsParamsSortBy = "updated_at"
)

// Defines values for ListPluginVersionsParamsSortBy.
const (
	ListPluginVersionsParamsSortByCreatedAt ListPluginVersionsParamsSortBy = "created_at"
)

// Defines values for GetTeamUsageSummaryParamsMetrics.
const (
	GetTeamUsageSummaryParamsMetricsCloudVcpuSeconds     GetTeamUsageSummaryParamsMetrics = "cloud_vcpu_seconds"
	GetTeamUsageSummaryParamsMetricsCloudVramByteSeconds GetTeamUsageSummaryParamsMetrics = "cloud_vram_byte_seconds"
	GetTeamUsageSummaryParamsMetricsNetworkEgressBytes   GetTeamUsageSummaryParamsMetrics = "network_egress_bytes"
	GetTeamUsageSummaryParamsMetricsPaidRows             GetTeamUsageSummaryParamsMetrics = "paid_rows"
)

// Defines values for GetTeamUsageSummaryParamsAggregationPeriod.
const (
	GetTeamUsageSummaryParamsAggregationPeriodDay   GetTeamUsageSummaryParamsAggregationPeriod = "day"
	GetTeamUsageSummaryParamsAggregationPeriodMonth GetTeamUsageSummaryParamsAggregationPeriod = "month"
)

// Defines values for GetGroupedTeamUsageSummaryParamsMetrics.
const (
	GetGroupedTeamUsageSummaryParamsMetricsCloudVcpuSeconds     GetGroupedTeamUsageSummaryParamsMetrics = "cloud_vcpu_seconds"
	GetGroupedTeamUsageSummaryParamsMetricsCloudVramByteSeconds GetGroupedTeamUsageSummaryParamsMetrics = "cloud_vram_byte_seconds"
	GetGroupedTeamUsageSummaryParamsMetricsNetworkEgressBytes   GetGroupedTeamUsageSummaryParamsMetrics = "network_egress_bytes"
	GetGroupedTeamUsageSummaryParamsMetricsPaidRows             GetGroupedTeamUsageSummaryParamsMetrics = "paid_rows"
)

// Defines values for GetGroupedTeamUsageSummaryParamsAggregationPeriod.
const (
	GetGroupedTeamUsageSummaryParamsAggregationPeriodDay   GetGroupedTeamUsageSummaryParamsAggregationPeriod = "day"
	GetGroupedTeamUsageSummaryParamsAggregationPeriodMonth GetGroupedTeamUsageSummaryParamsAggregationPeriod = "month"
)

// Defines values for GetGroupedTeamUsageSummaryParamsGroupBy.
const (
	GetGroupedTeamUsageSummaryParamsGroupByPlugin        GetGroupedTeamUsageSummaryParamsGroupBy = "plugin"
	GetGroupedTeamUsageSummaryParamsGroupByPriceCategory GetGroupedTeamUsageSummaryParamsGroupBy = "price_category"
	GetGroupedTeamUsageSummaryParamsGroupBySyncId        GetGroupedTeamUsageSummaryParamsGroupBy = "sync_id"
)

// AIOnboardingChat200Response defines model for AIOnboardingChat_200_response.
type AIOnboardingChat200Response struct {
	// FunctionCall The name of the function being called (if any)
	FunctionCall *interface{} `json:"function_call,omitempty"`

	// FunctionCallArguments Arguments for the function call (if any)
	FunctionCallArguments *interface{} `json:"function_call_arguments,omitempty"`

	// FunctionCallID ID of the function call (if any)
	FunctionCallID *interface{} `json:"function_call_id,omitempty"`

	// Message The AI assistant's response message
	Message              interface{}            `json:"message"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AIOnboardingChatRequest defines model for AIOnboardingChat_request.
type AIOnboardingChatRequest struct {
	// ChatMode Optional chat mode - "web" for markdown output, "terminal" for plain text output
	ChatMode *interface{} `json:"chat_mode,omitempty"`

	// ConversationID Optional conversation ID to continue an existing conversation
	ConversationID *interface{} `json:"conversation_id,omitempty"`

	// FunctionCallOutputs Function call outputs from previous interactions
	FunctionCallOutputs *interface{} `json:"function_call_outputs,omitempty"`

	// Message The user's message to send to the AI assistant
	Message              *interface{}           `json:"message,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AIOnboardingEndConversation200Response defines model for AIOnboardingEndConversation_200_response.
type AIOnboardingEndConversation200Response struct {
	// Success Whether the conversation was ended successfully
	Success              *interface{}           `json:"success,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AIOnboardingNewConversation200Response defines model for AIOnboardingNewConversation_200_response.
type AIOnboardingNewConversation200Response struct {
	// ConversationID The ID of the new conversation
	ConversationID       interface{}            `json:"conversation_id"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AIOnboardingNewConversationRequest defines model for AIOnboardingNewConversation_request.
type AIOnboardingNewConversationRequest struct {
	// TryResume If true, resume existing conversation instead of starting a new one
	TryResume            *interface{}           `json:"try_resume,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// APIKey API Key to interact with CloudQuery Cloud under specific team
type APIKey struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// CreatedBy email of the user that created the API key
	CreatedBy *string `json:"created_by,omitempty"`

	// Expired Whether the API key has expired or not
	Expired bool `json:"expired"`

	// ExpiresAt Timestamp at which API key will stop working
	ExpiresAt time.Time `json:"expires_at"`

	// APIKeyID ID of the API key
	APIKeyID APIKeyID `json:"id"`

	// Key API key. Will be shown only in the response when creating the key.
	Key *string `json:"key,omitempty"`

	// LastAccessAt Timestamp at which API key was last used - accurate to the day only.
	LastAccessAt *time.Time `json:"last_access_at,omitempty"`

	// Name Name of the API key
	Name APIKeyName `json:"name"`

	// Scope Scope of permissions for the API key. API keys are used for creating new plugin versions and downloading existing plugins
	Scope APIKeyScope `json:"scope"`
}

// APIKeyID ID of the API key
type APIKeyID = openapi_types.UUID

// APIKeyName Name of the API key
type APIKeyName = string

// APIKeyScope Scope of permissions for the API key. API keys are used for creating new plugin versions and downloading existing plugins
type APIKeyScope string

// AcceptTeamInvitationRequest defines model for AcceptTeamInvitation_request.
type AcceptTeamInvitationRequest struct {
	Token openapi_types.UUID `json:"token"`
}

// ActivatePlatform200Response defines model for ActivatePlatform_200_response.
type ActivatePlatform200Response struct {
	// ActivationID Activation ID for the platform
	ActivationID interface{} `json:"activation_id"`

	// NextCheckInSeconds Time in seconds until the next check in
	NextCheckInSeconds interface{} `json:"next_check_in_seconds"`

	// TeamName Name of the team that was activated
	TeamName             interface{}            `json:"team_name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ActivatePlatform205Response defines model for ActivatePlatform_205_response.
type ActivatePlatform205Response struct {
	// ButtonText Text for the button
	ButtonText *interface{} `json:"button_text,omitempty"`

	// ButtonURL URL for the button
	ButtonURL *interface{} `json:"button_url,omitempty"`

	// Error Error message
	Error                interface{}            `json:"error"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ActivatePlatformRequest defines model for ActivatePlatform_request.
type ActivatePlatformRequest struct {
	// APIKey Team API key to activate platform with
	APIKey interface{} `json:"api_key"`

	// InstallationID Installation ID of the platform
	InstallationID       interface{}            `json:"installation_id"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Addon CloudQuery Addon
type Addon struct {
	// AddonFormat Supported formats for addons
	AddonFormat AddonFormat `json:"addon_format"`

	// AddonType Supported types for addons
	AddonType AddonType `json:"addon_type"`

	// Category Supported categories for addons
	Category  AddonCategory `json:"category"`
	CreatedAt time.Time     `json:"created_at"`

	// DisplayName The addon's display name
	DisplayName string  `json:"display_name"`
	Homepage    *string `json:"homepage,omitempty"`
	Logo        string  `json:"logo"`

	// Name The unique name for the addon.
	Name AddonName `json:"name"`

	// Official True if the addon is maintained by CloudQuery, false otherwise
	Official bool `json:"official"`

	// PriceUSD The price for 6 months
	PriceUSD string `json:"price_usd"`

	// Public Whether the plugin is listed in the CloudQuery Hub. If false, the plugin will not be shown in the CloudQuery Hub and will only be visible to members of the plugin's team.
	Public           *bool   `json:"public,omitempty"`
	Repository       *string `json:"repository,omitempty"`
	ShortDescription string  `json:"short_description"`

	// TeamName The unique name for the team.
	TeamName TeamName `json:"team_name"`

	// Tier Supported tiers for addons
	Tier      AddonTier `json:"tier"`
	UpdatedAt time.Time `json:"updated_at"`
}

// AddonAsset CloudQuery Addon Asset
type AddonAsset struct {
	// Checksum The checksum of the addon asset
	Checksum string `json:"checksum"`

	// Location The location to download the addon asset from
	Location string `json:"location"`
}

// AddonCategory Supported categories for addons
type AddonCategory string

// AddonCreate CloudQuery AddonCreate
type AddonCreate struct {
	// AddonFormat Supported formats for addons
	AddonFormat AddonFormat `json:"addon_format"`

	// AddonType Supported types for addons
	AddonType AddonType `json:"addon_type"`

	// Category Supported categories for addons
	Category AddonCategory `json:"category"`

	// DisplayName The addon's display name
	DisplayName string  `json:"display_name"`
	Homepage    *string `json:"homepage,omitempty"`
	Logo        *string `json:"logo,omitempty"`

	// Name The unique name for the addon.
	Name AddonName `json:"name"`

	// PriceUSD The price for 6 months
	PriceUSD *string `json:"price_usd,omitempty"`

	// Public Whether the plugin is listed in the CloudQuery Hub. If false, the plugin will not be shown in the CloudQuery Hub and will only be visible to members of the plugin's team.
	Public           bool    `json:"public"`
	Repository       *string `json:"repository,omitempty"`
	ShortDescription string  `json:"short_description"`

	// TeamName The unique name for the team.
	TeamName TeamName `json:"team_name"`

	// Tier Supported tiers for addons
	Tier AddonTier `json:"tier"`
}

// AddonFormat Supported formats for addons
type AddonFormat string

// AddonName The unique name for the addon.
type AddonName = string

// AddonOrder CloudQuery Addon Order
type AddonOrder struct {
	// AddonName The unique name for the addon.
	AddonName AddonName `json:"addon_name"`

	// AddonTeam The unique name for the team.
	AddonTeam TeamName `json:"addon_team"`

	// AddonType Supported types for addons
	AddonType   AddonType  `json:"addon_type"`
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CompletionURL Stripe URL for completing purchase. Only shown in response to POST request.
	CompletionURL *string   `json:"completion_url,omitempty"`
	CreatedAt     time.Time `json:"created_at"`

	// AddonOrderID ID of the addon order
	AddonOrderID AddonOrderID     `json:"id"`
	Status       AddonOrderStatus `json:"status"`

	// TeamName The unique name for the team.
	TeamName  TeamName  `json:"team_name"`
	UpdatedAt time.Time `json:"updated_at"`
}

// AddonOrderCreate Create CloudQuery Addon Order
type AddonOrderCreate struct {
	// AddonName The unique name for the addon.
	AddonName AddonName `json:"addon_name"`

	// AddonTeam The unique name for the team.
	AddonTeam TeamName `json:"addon_team"`

	// AddonType Supported types for addons
	AddonType AddonType `json:"addon_type"`

	// CancelUrl URL to redirect to after order cancellation
	CancelUrl string `json:"cancel_url"`

	// SuccessUrl URL to redirect to after successful order completion
	SuccessUrl string `json:"success_url"`
}

// AddonOrderID ID of the addon order
type AddonOrderID = openapi_types.UUID

// AddonOrderStatus defines model for AddonOrderStatus.
type AddonOrderStatus string

// AddonTier Supported tiers for addons
type AddonTier string

// AddonType Supported types for addons
type AddonType string

// AddonUpdate CloudQuery AddonUpdate
type AddonUpdate struct {
	// AddonFormat Supported formats for addons
	AddonFormat *AddonFormat `json:"addon_format,omitempty"`

	// Category Supported categories for addons
	Category  *AddonCategory `json:"category,omitempty"`
	CreatedAt *time.Time     `json:"created_at,omitempty"`

	// DisplayName The addon's display name
	DisplayName *string `json:"display_name,omitempty"`
	Homepage    *string `json:"homepage,omitempty"`
	Logo        *string `json:"logo,omitempty"`

	// PriceUSD The price for 6 months in USD
	PriceUSD *string `json:"price_usd,omitempty"`

	// Public Whether the plugin is listed in the CloudQuery Hub. If false, the plugin will not be shown in the CloudQuery Hub and will only be visible to members of the plugin's team.
	Public           *bool   `json:"public,omitempty"`
	Repository       *string `json:"repository,omitempty"`
	ShortDescription *string `json:"short_description,omitempty"`

	// Tier Supported tiers for addons
	Tier *AddonTier `json:"tier,omitempty"`
}

// AddonVersion CloudQuery Addon Version
type AddonVersion struct {
	// AddonDeps list of other addons this addon depends on in the format of team_name/type/name@version
	AddonDeps *[]string `json:"addon_deps,omitempty"`

	// Checksum The checksum of the addon asset
	Checksum string `json:"checksum"`

	// CreatedAt The date and time the plugin version was created.
	CreatedAt time.Time `json:"created_at"`

	// Doc Main README in MD format
	Doc string `json:"doc"`

	// Draft If a plugin version is in draft, it will not show to members outside the team or be counted as the latest version.
	Draft bool `json:"draft"`

	// Message Description of what's new or changed in this version (supports markdown)
	Message string `json:"message"`

	// Name The version in semantic version format.
	Name VersionName `json:"name"`

	// PluginDeps list of plugins the addon depends on in the format of team_name/kind/name@version
	PluginDeps *[]string `json:"plugin_deps,omitempty"`

	// PublishedAt The date and time the plugin version was set to non-draft (published).
	PublishedAt *time.Time `json:"published_at,omitempty"`

	// Retracted If a plugin version is retracted, assets will still be available for download, but the version will be marked as retracted to discourage use.
	Retracted bool `json:"retracted"`
}

// AddonVersionUpdate defines model for AddonVersionUpdate.
type AddonVersionUpdate struct {
	// AddonDeps list of other addons this addon depends on in the format of team_name/type/name@version
	AddonDeps *[]string `json:"addon_deps,omitempty"`

	// Checksum The checksum of the addon asset
	Checksum *string `json:"checksum,omitempty"`

	// Doc Main README in MD format
	Doc *string `json:"doc,omitempty"`

	// Draft If a plugin version is in draft, it will not show to members outside the team or be counted as the latest version.
	Draft *bool `json:"draft,omitempty"`

	// Message Description of what's new or changed in this version (supports markdown)
	Message *string `json:"message,omitempty"`

	// PluginDeps list of plugins the addon depends on in the format of team_name/kind/name@version
	PluginDeps *[]string `json:"plugin_deps,omitempty"`

	// Retracted If a plugin version is retracted, assets will still be available for download, but the version will be marked as retracted to discourage use.
	Retracted *bool `json:"retracted,omitempty"`
}

// BasicError Basic Error
type BasicError struct {
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// CheckUserAuthStatus200Response defines model for CheckUserAuthStatus_200_response.
type CheckUserAuthStatus200Response struct {
	// Authenticated Whether the user is authenticated
	Authenticated bool `json:"authenticated"`
}

// ContentType The HTTP Content-Type of the image or asset
type ContentType string

// CreateAddonVersionRequest defines model for CreateAddonVersion_request.
type CreateAddonVersionRequest struct {
	// AddonDeps addon dependencies in the format of ['team_name/type/addon_name@version']
	AddonDeps *[]string `json:"addon_deps,omitempty"`

	// Checksum SHA-256 checksum for the addon asset
	Checksum string `json:"checksum"`

	// Doc Main README in MD format
	Doc string `json:"doc"`

	// Message A message describing what's new or changed in this version.
	// This message will be displayed to users in the addon's changelog.
	// Supports limited markdown syntax.
	Message string `json:"message"`

	// PluginDeps plugin dependencies in the format of ['team_name/kind/plugin_name@version']
	PluginDeps *[]string `json:"plugin_deps,omitempty"`
}

// CreatePluginVersionDocs201Response defines model for CreatePluginVersionDocs_201_response.
type CreatePluginVersionDocs201Response struct {
	Names *[]PluginDocsPageName `json:"names,omitempty"`
}

// CreatePluginVersionDocsRequest defines model for CreatePluginVersionDocs_request.
type CreatePluginVersionDocsRequest struct {
	Pages []PluginDocsPageCreate `json:"pages"`
}

// CreatePluginVersionTables201Response defines model for CreatePluginVersionTables_201_response.
type CreatePluginVersionTables201Response struct {
	Names *[]PluginTableName `json:"names,omitempty"`
}

// CreatePluginVersionTablesRequest defines model for CreatePluginVersionTables_request.
type CreatePluginVersionTablesRequest struct {
	Tables []PluginTableCreate `json:"tables"`
}

// CreatePluginVersionRequest defines model for CreatePluginVersion_request.
type CreatePluginVersionRequest struct {
	// Checksums List of SHA-256 checksums for this plugin version, one for each supported target.
	Checksums []string `json:"checksums"`

	// Message A message describing what's new or changed in this version.
	// This message will be displayed to users in the plugin's changelog.
	// Supports limited markdown syntax.
	Message string `json:"message"`

	// PackageType The package type of the plugin assets
	PackageType PluginPackageType `json:"package_type"`

	// Protocols The CloudQuery protocols supported by this plugin version (only protocol 3 is supported by new plugins).
	Protocols PluginProtocols `json:"protocols"`

	// SpecJsonSchema The specification of the plugin. This is a JSON schema that describes the configuration of the plugin.
	SpecJsonSchema *PluginSpecJSONSchema `json:"spec_json_schema,omitempty"`

	// SupportedTargets The targets supported by this plugin version, formatted as <os>_<arch>
	SupportedTargets []string `json:"supported_targets"`
}

// CreateTeamAPIKeyRequest defines model for CreateTeamAPIKey_request.
type CreateTeamAPIKeyRequest struct {
	ExpiresAt time.Time `json:"expires_at"`

	// Name Name of the API key
	Name APIKeyName `json:"name"`

	// Scope Scope of permissions for the API key. API keys are used for creating new plugin versions and downloading existing plugins
	Scope *APIKeyScope `json:"scope,omitempty"`
}

// CreateTeamImages201Response defines model for CreateTeamImages_201_response.
type CreateTeamImages201Response struct {
	Items    []TeamImage  `json:"items"`
	Metadata ListMetadata `json:"metadata"`
}

// CreateTeamImagesRequest defines model for CreateTeamImages_request.
type CreateTeamImagesRequest struct {
	Images []TeamImageCreate `json:"images"`
}

// CreateTeamRequest defines model for CreateTeam_request.
type CreateTeamRequest struct {
	// DisplayName The team's display name
	DisplayName interface{} `json:"display_name"`

	// Name The unique name for the team.
	Name                 TeamName               `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// CreateUserToken201Response defines model for CreateUserToken_201_response.
type CreateUserToken201Response struct {
	// CustomToken Token to exchange for refresh token
	CustomToken string `json:"custom_token"`
}

// DeletePluginVersionDocsRequest defines model for DeletePluginVersionDocs_request.
type DeletePluginVersionDocsRequest struct {
	Names []PluginDocsPageName `json:"names"`
}

// DeletePluginVersionTablesRequest defines model for DeletePluginVersionTables_request.
type DeletePluginVersionTablesRequest struct {
	Names []PluginTableName `json:"names"`
}

// DeleteTeamInvitationRequest defines model for DeleteTeamInvitation_request.
type DeleteTeamInvitationRequest struct {
	Email openapi_types.Email `json:"email"`
}

// DeterminePlatformTenantByEmail200Response defines model for DeterminePlatformTenantByEmail_200_response.
type DeterminePlatformTenantByEmail200Response struct {
	// HasCloudAccount Whether the user has a cloud account
	HasCloudAccount bool `json:"has_cloud_account"`

	// Items List of tenants
	Items []TenantUser `json:"items,omitempty"`
}

// DockerError Error Returned from the Docker Authorization Handler to the Docker Registry
type DockerError struct {
	Details string `json:"details"`
}

// Email defines model for Email.
type Email = openapi_types.Email

// EmailTeamInvitationRequest defines model for EmailTeamInvitation_request.
type EmailTeamInvitationRequest struct {
	Email openapi_types.Email            `json:"email"`
	Role  EmailTeamInvitationRequestRole `json:"role"`
}

// EmailTeamInvitationRequestRole defines model for EmailTeamInvitationRequest.Role.
type EmailTeamInvitationRequestRole string

// FieldError defines model for FieldError.
type FieldError struct {
	Errors      *[]string          `json:"errors,omitempty"`
	FieldErrors *map[string]string `json:"field_errors,omitempty"`
	Message     string             `json:"message"`
	Status      int                `json:"status"`
}

// FinalizePluginUIAssetUploadRequest defines model for FinalizePluginUIAssetUpload_request.
type FinalizePluginUIAssetUploadRequest struct {
	// UIID ID representing the finished upload
	UIID string `json:"ui_id"`
}

// FunctionCallOutput defines model for FunctionCallOutput.
type FunctionCallOutput struct {
	// Arguments The arguments passed to the function
	Arguments interface{} `json:"arguments"`

	// CallID The unique identifier for this function call
	CallID interface{} `json:"call_id"`

	// Name The name of the function that was called
	Name interface{} `json:"name"`

	// Output The output/result from the function call
	Output               interface{}            `json:"output"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// GetCurrentUserMemberships200Response defines model for GetCurrentUserMemberships_200_response.
type GetCurrentUserMemberships200Response struct {
	Items    []MembershipWithTeam `json:"items"`
	Metadata ListMetadata         `json:"metadata"`
}

// GetManagedDatabases200Response defines model for GetManagedDatabases_200_response.
type GetManagedDatabases200Response struct {
	Items    []ManagedDatabase `json:"items"`
	Metadata ListMetadata      `json:"metadata"`
}

// GetTeamMemberships200Response defines model for GetTeamMemberships_200_response.
type GetTeamMemberships200Response struct {
	Items    []MembershipWithUser `json:"items"`
	Metadata ListMetadata         `json:"metadata"`
}

// ImageURL defines model for ImageURL.
type ImageURL struct {
	DownloadUrl string `json:"download_url"`

	// RequiredHeaders Required HTTP headers to include for the upload
	RequiredHeaders map[string]interface{} `json:"required_headers"`
	UploadUrl       string                 `json:"upload_url"`
}

// Invitation defines model for Invitation.
type Invitation struct {
	CreatedAt time.Time `json:"created_at"`
	Email     Email     `json:"email"`
	Role      string    `json:"role"`

	// TeamName The unique name for the team.
	TeamName TeamName `json:"team_name"`
}

// InvitationWithToken defines model for InvitationWithToken.
type InvitationWithToken struct {
	CreatedAt time.Time `json:"created_at"`
	Email     Email     `json:"email"`
	Role      string    `json:"role"`

	// TeamName The unique name for the team.
	TeamName TeamName `json:"team_name"`

	// Token The token used to accept the invitation
	Token openapi_types.UUID `json:"token"`
}

// Invoice Invoice details
type Invoice struct {
	// AmountDue Amount due in cents. This is the amount that will be charged, unless there are pending invoice items. If the invoiceâ€™s total is smaller than the minimum charge amount, for example, or if there is account credit that can be applied to the invoice, the amount_due may be 0. The charge that gets generated for the invoice will be for the amount specified in amount_due.
	AmountDue int64     `json:"amount_due"`
	CreatedAt time.Time `json:"created_at"`
	Currency  string    `json:"currency"`

	// InvoicePDF The link to download the PDF for the invoice.
	InvoicePDF string `json:"invoice_pdf"`

	// Paid Whether or not payment was successfully collected for this invoice.
	Paid bool `json:"paid"`
}

// ListAddon defines model for ListAddon.
type ListAddon struct {
	// AddonFormat Supported formats for addons
	AddonFormat AddonFormat `json:"addon_format"`

	// AddonType Supported types for addons
	AddonType AddonType `json:"addon_type"`

	// Category Supported categories for addons
	Category  AddonCategory `json:"category"`
	CreatedAt time.Time     `json:"created_at"`

	// DisplayName The addon's display name
	DisplayName string  `json:"display_name"`
	Homepage    *string `json:"homepage,omitempty"`

	// LatestVersion The version in semantic version format.
	LatestVersion *VersionName `json:"latest_version,omitempty"`
	Logo          string       `json:"logo"`

	// Name The unique name for the addon.
	Name AddonName `json:"name"`

	// Official True if the addon is maintained by CloudQuery, false otherwise
	Official bool `json:"official"`

	// PriceUSD The price for 6 months
	PriceUSD string `json:"price_usd"`

	// Public Whether the plugin is listed in the CloudQuery Hub. If false, the plugin will not be shown in the CloudQuery Hub and will only be visible to members of the plugin's team.
	Public           *bool   `json:"public,omitempty"`
	Repository       *string `json:"repository,omitempty"`
	ShortDescription string  `json:"short_description"`

	// TeamName The unique name for the team.
	TeamName TeamName `json:"team_name"`

	// Tier Supported tiers for addons
	Tier      AddonTier `json:"tier"`
	UpdatedAt time.Time `json:"updated_at"`
}

// ListAddonOrdersByTeam200Response defines model for ListAddonOrdersByTeam_200_response.
type ListAddonOrdersByTeam200Response struct {
	Items    []AddonOrder `json:"items"`
	Metadata ListMetadata `json:"metadata"`
}

// ListAddonVersions200Response defines model for ListAddonVersions_200_response.
type ListAddonVersions200Response struct {
	Items    []AddonVersion `json:"items"`
	Metadata ListMetadata   `json:"metadata"`
}

// ListAddonsByTeam200Response defines model for ListAddonsByTeam_200_response.
type ListAddonsByTeam200Response struct {
	Items    []Addon      `json:"items"`
	Metadata ListMetadata `json:"metadata"`
}

// ListAddons200Response defines model for ListAddons_200_response.
type ListAddons200Response struct {
	Items    []ListAddon  `json:"items"`
	Metadata ListMetadata `json:"metadata"`
}

// ListCurrentUserInvitations200Response defines model for ListCurrentUserInvitations_200_response.
type ListCurrentUserInvitations200Response struct {
	Items    []InvitationWithToken `json:"items"`
	Metadata ListMetadata          `json:"metadata"`
}

// ListInvoicesByTeam200Response defines model for ListInvoicesByTeam_200_response.
type ListInvoicesByTeam200Response struct {
	Items    []Invoice    `json:"items"`
	Metadata ListMetadata `json:"metadata"`
}

// ListMetadata defines model for ListMetadata.
type ListMetadata struct {
	LastPage   *int `json:"last_page,omitempty"`
	PageSize   int  `json:"page_size"`
	TimeMs     *int `json:"time_ms,omitempty"`
	TotalCount *int `json:"total_count,omitempty"`
}

// ListPlugin defines model for ListPlugin.
type ListPlugin struct {
	// Category Supported categories for plugins
	Category  PluginCategory `json:"category"`
	CreatedAt time.Time      `json:"created_at"`

	// DisplayName The plugin's display name
	DisplayName string `json:"display_name"`

	// FreeRowsPerMonth Deprecated. Refer to `price_category` instead.
	// Deprecated:
	FreeRowsPerMonth int64   `json:"free_rows_per_month"`
	Homepage         *string `json:"homepage,omitempty"`

	// Kind The kind of plugin, ie. source or destination.
	Kind PluginKind `json:"kind"`

	// LatestVersion The version in semantic version format.
	LatestVersion *VersionName `json:"latest_version,omitempty"`
	Logo          string       `json:"logo"`

	// Name The unique name for the plugin.
	Name PluginName `json:"name"`

	// Official True if the plugin is maintained by CloudQuery, false otherwise
	Official bool `json:"official"`

	// PriceCategory Supported price categories for billing
	PriceCategory *PluginPriceCategory `json:"price_category,omitempty"`

	// Public Whether the plugin is listed in the CloudQuery Hub. If false, the plugin will not be shown in the CloudQuery Hub and will only be visible to members of the plugin's team.
	Public *bool `json:"public,omitempty"`

	// ReleaseStage Official plugins can go through three release stages: Coming Soon, Preview, and GA.
	// The Coming Soon stage is for plugins that are not yet ready for Preview, but users can subscribe to be notified when they are ready.
	// Both Preview and GA plugins follow semantic versioning. The main differences between the two stages are:
	// Preview plugins are still experimental and may have frequent breaking changes. Preview plugins might get deprecated due to lack of usage. Long Term Support with community Discord and bug fixes is only guaranteed for GA plugins. Premium plugins are often discounted or free during the Preview stage.
	ReleaseStage     PluginReleaseStage `json:"release_stage"`
	Repository       *string            `json:"repository,omitempty"`
	ShortDescription string             `json:"short_description"`

	// TeamName The unique name for the team.
	TeamName TeamName `json:"team_name"`

	// Tier This field is deprecated, refer to `price_category` instead.
	// This field is only kept for backward compatibility and may be removed in a future release.
	// Supported tiers for plugins.
	//   - free: Free tier, with no paid tables.
	//   - paid: Paid tier. These plugins may have paid tables, but can also have free tables. They require login to access.
	//   - open-core: This option is deprecated, values will either be free or paid.
	// Deprecated:
	Tier      PluginTier `json:"tier"`
	UpdatedAt time.Time  `json:"updated_at"`

	// USDPerRow Deprecated. Refer to `price_category` instead.
	// Deprecated:
	USDPerRow string `json:"usd_per_row"`
}

// ListPluginNotificationRequests200Response defines model for ListPluginNotificationRequests_200_response.
type ListPluginNotificationRequests200Response struct {
	Items    []PluginNotificationRequest `json:"items"`
	Metadata ListMetadata                `json:"metadata"`
}

// ListPluginUpcomingPriceChanges200Response defines model for ListPluginUpcomingPriceChanges_200_response.
type ListPluginUpcomingPriceChanges200Response struct {
	Items    []PluginPrice `json:"items"`
	Metadata ListMetadata  `json:"metadata"`
}

// ListPluginVersionDocs200Response defines model for ListPluginVersionDocs_200_response.
type ListPluginVersionDocs200Response struct {
	Items    []PluginDocsPage `json:"items"`
	Metadata ListMetadata     `json:"metadata"`
}

// ListPluginVersionTables200Response defines model for ListPluginVersionTables_200_response.
type ListPluginVersionTables200Response struct {
	Items    []PluginTable `json:"items"`
	Metadata ListMetadata  `json:"metadata"`
}

// ListPluginVersions200Response defines model for ListPluginVersions_200_response.
type ListPluginVersions200Response struct {
	Items    []PluginVersionList `json:"items"`
	Metadata ListMetadata        `json:"metadata"`
}

// ListPluginsByTeam200Response defines model for ListPluginsByTeam_200_response.
type ListPluginsByTeam200Response struct {
	Items    []Plugin     `json:"items"`
	Metadata ListMetadata `json:"metadata"`
}

// ListPlugins200Response defines model for ListPlugins_200_response.
type ListPlugins200Response struct {
	Items    []ListPlugin `json:"items"`
	Metadata ListMetadata `json:"metadata"`
}

// ListSubscriptionOrdersByTeam200Response defines model for ListSubscriptionOrdersByTeam_200_response.
type ListSubscriptionOrdersByTeam200Response struct {
	Items    []TeamSubscriptionOrder `json:"items"`
	Metadata ListMetadata            `json:"metadata"`
}

// ListTeamAPIKeys200Response defines model for ListTeamAPIKeys_200_response.
type ListTeamAPIKeys200Response struct {
	Items    []APIKey     `json:"items"`
	Metadata ListMetadata `json:"metadata"`
}

// ListTeamInvitations200Response defines model for ListTeamInvitations_200_response.
type ListTeamInvitations200Response struct {
	Items    []Invitation `json:"items"`
	Metadata ListMetadata `json:"metadata"`
}

// ListTeamPluginUsage200Response defines model for ListTeamPluginUsage_200_response.
type ListTeamPluginUsage200Response struct {
	Items    []UsageCurrent `json:"items"`
	Metadata ListMetadata   `json:"metadata"`
}

// ListTeams200Response defines model for ListTeams_200_response.
type ListTeams200Response struct {
	Items    []Team       `json:"items"`
	Metadata ListMetadata `json:"metadata"`
}

// ListUsersByTeam200Response defines model for ListUsersByTeam_200_response.
type ListUsersByTeam200Response struct {
	Items    []User       `json:"items"`
	Metadata ListMetadata `json:"metadata"`
}

// LoginUserRequest defines model for LoginUser_request.
type LoginUserRequest struct {
	IDToken              interface{}            `json:"id_token"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ManagedDatabase Managed Database definition
type ManagedDatabase struct {
	// ConnectionString The connection string to the database
	ConnectionString *string `json:"connection_string,omitempty"`

	// CreatedAt Time the managed database was created
	CreatedAt time.Time `json:"created_at"`

	// Expiration Time the managed database should expire
	Expiration *time.Time `json:"expiration,omitempty"`

	// ManagedDatabaseID The identifier for the managed database
	ManagedDatabaseID ManagedDatabaseID `json:"id"`

	// Status The status of the managed database
	Status ManagedDatabaseStatus `json:"status"`
}

// ManagedDatabaseCreate Managed Database creation
type ManagedDatabaseCreate = map[string]interface{}

// ManagedDatabaseID The identifier for the managed database
type ManagedDatabaseID = openapi_types.UUID

// ManagedDatabaseStatus The status of the managed database
type ManagedDatabaseStatus string

// MembershipWithTeam defines model for MembershipWithTeam.
type MembershipWithTeam struct {
	Role string `json:"role"`

	// Team CloudQuery Team
	Team Team `json:"team"`
}

// MembershipWithUser defines model for MembershipWithUser.
type MembershipWithUser struct {
	Role string `json:"role"`

	// User CloudQuery User
	User User `json:"user"`
}

// Plugin CloudQuery Plugin
type Plugin struct {
	// Category Supported categories for plugins
	Category  PluginCategory `json:"category"`
	CreatedAt time.Time      `json:"created_at"`

	// DisplayName The plugin's display name
	DisplayName string `json:"display_name"`

	// FreeRowsPerMonth Deprecated. Refer to `price_category` instead.
	// Deprecated:
	FreeRowsPerMonth int64   `json:"free_rows_per_month"`
	Homepage         *string `json:"homepage,omitempty"`

	// Kind The kind of plugin, ie. source or destination.
	Kind PluginKind `json:"kind"`
	Logo string     `json:"logo"`

	// Name The unique name for the plugin.
	Name PluginName `json:"name"`

	// Official True if the plugin is maintained by CloudQuery, false otherwise
	Official bool `json:"official"`

	// PriceCategory Supported price categories for billing
	PriceCategory *PluginPriceCategory `json:"price_category,omitempty"`

	// Public Whether the plugin is listed in the CloudQuery Hub. If false, the plugin will not be shown in the CloudQuery Hub and will only be visible to members of the plugin's team.
	Public *bool `json:"public,omitempty"`

	// ReleaseStage Official plugins can go through three release stages: Coming Soon, Preview, and GA.
	// The Coming Soon stage is for plugins that are not yet ready for Preview, but users can subscribe to be notified when they are ready.
	// Both Preview and GA plugins follow semantic versioning. The main differences between the two stages are:
	// Preview plugins are still experimental and may have frequent breaking changes. Preview plugins might get deprecated due to lack of usage. Long Term Support with community Discord and bug fixes is only guaranteed for GA plugins. Premium plugins are often discounted or free during the Preview stage.
	ReleaseStage     PluginReleaseStage `json:"release_stage"`
	Repository       *string            `json:"repository,omitempty"`
	ShortDescription string             `json:"short_description"`

	// TeamName The unique name for the team.
	TeamName TeamName `json:"team_name"`

	// Tier This field is deprecated, refer to `price_category` instead.
	// This field is only kept for backward compatibility and may be removed in a future release.
	// Supported tiers for plugins.
	//   - free: Free tier, with no paid tables.
	//   - paid: Paid tier. These plugins may have paid tables, but can also have free tables. They require login to access.
	//   - open-core: This option is deprecated, values will either be free or paid.
	// Deprecated:
	Tier      PluginTier `json:"tier"`
	UpdatedAt time.Time  `json:"updated_at"`

	// USDPerRow Deprecated. Refer to `price_category` instead.
	// Deprecated:
	USDPerRow string `json:"usd_per_row"`
}

// PluginAsset CloudQuery Plugin Asset
type PluginAsset struct {
	// Checksum The checksum of the plugin asset
	Checksum string `json:"checksum"`

	// Location The location to download the plugin asset from
	Location string `json:"location"`
}

// PluginCategory Supported categories for plugins
type PluginCategory string

// PluginCreate defines model for PluginCreate.
type PluginCreate struct {
	// Category Supported categories for plugins
	Category PluginCategory `json:"category"`

	// DisplayName The plugin's display name, as shown in the CloudQuery Hub.
	DisplayName string `json:"display_name"`

	// FreeRowsPerMonth Deprecated. Use `price_category` instead.
	// Deprecated:
	FreeRowsPerMonth *int64  `json:"free_rows_per_month,omitempty"`
	Homepage         *string `json:"homepage,omitempty"`

	// Kind The kind of plugin, ie. source or destination.
	Kind PluginKind `json:"kind"`

	// Logo URL to the plugin's logo. This will be shown in the CloudQuery Hub.
	Logo *string `json:"logo,omitempty"`

	// Name The unique name for the plugin.
	Name PluginName `json:"name"`

	// PriceCategory Supported price categories for billing
	PriceCategory *PluginPriceCategory `json:"price_category,omitempty"`

	// Public Whether the plugin is listed in the CloudQuery Hub. If false, the plugin will not be shown in the CloudQuery Hub and will only be visible to members of the team.
	Public bool `json:"public"`

	// ReleaseStage Official plugins can go through three release stages: Coming Soon, Preview, and GA.
	// The Coming Soon stage is for plugins that are not yet ready for Preview, but users can subscribe to be notified when they are ready.
	// Both Preview and GA plugins follow semantic versioning. The main differences between the two stages are:
	// Preview plugins are still experimental and may have frequent breaking changes. Preview plugins might get deprecated due to lack of usage. Long Term Support with community Discord and bug fixes is only guaranteed for GA plugins. Premium plugins are often discounted or free during the Preview stage.
	ReleaseStage *PluginReleaseStageCreate `json:"release_stage,omitempty"`
	Repository   *string                   `json:"repository,omitempty"`

	// ShortDescription Short description of the plugin. This will be shown in the CloudQuery Hub.
	ShortDescription string `json:"short_description"`

	// TeamName The unique name for the team.
	TeamName TeamName `json:"team_name"`

	// Tier This field is deprecated, refer to `price_category` instead.
	// This field is only kept for backward compatibility and may be removed in a future release.
	// Supported tiers for plugins.
	//   - free: Free tier, with no paid tables.
	//   - paid: Paid tier. These plugins may have paid tables, but can also have free tables. They require login to access.
	//   - open-core: This option is deprecated, values will either be free or paid.
	// Deprecated:
	Tier *PluginTier `json:"tier,omitempty"`

	// USDPerRow Deprecated. Use `price_category` instead.
	// Deprecated:
	USDPerRow *string `json:"usd_per_row,omitempty"`
}

// PluginDocsPage CloudQuery Plugin Documentation Page
type PluginDocsPage struct {
	// Content The content of the documentation page. Supports markdown.
	Content string `json:"content"`

	// Name The unique name for the plugin documentation page.
	Name PluginDocsPageName `json:"name"`
}

// PluginDocsPageCreate CloudQuery Plugin Documentation Page
type PluginDocsPageCreate struct {
	// Content The content of the documentation page. Supports markdown.
	Content string `json:"content"`

	// Name The unique name for the plugin documentation page.
	Name PluginDocsPageName `json:"name"`
}

// PluginDocsPageName The unique name for the plugin documentation page.
type PluginDocsPageName = string

// PluginKind The kind of plugin, ie. source or destination.
type PluginKind string

// PluginName The unique name for the plugin.
type PluginName = string

// PluginNotificationRequest Plugin Notification Request
type PluginNotificationRequest struct {
	CreatedAt time.Time `json:"created_at"`

	// PluginKind The kind of plugin, ie. source or destination.
	PluginKind PluginKind `json:"plugin_kind"`

	// PluginName The unique name for the plugin.
	PluginName PluginName `json:"plugin_name"`

	// PluginTeam The unique name for the team.
	PluginTeam TeamName   `json:"plugin_team"`
	SentAt     *time.Time `json:"sent_at,omitempty"`

	// Status Status of a plugin notification request
	Status *PluginNotificationRequestStatus `json:"status,omitempty"`
}

// PluginNotificationRequestCreate Create a Plugin Notification Request
type PluginNotificationRequestCreate struct {
	// PluginKind The kind of plugin, ie. source or destination.
	PluginKind PluginKind `json:"plugin_kind"`

	// PluginName The unique name for the plugin.
	PluginName PluginName `json:"plugin_name"`

	// PluginTeam The unique name for the team.
	PluginTeam TeamName `json:"plugin_team"`
}

// PluginNotificationRequestStatus Status of a plugin notification request
type PluginNotificationRequestStatus string

// PluginPackageType The package type of the plugin assets
type PluginPackageType string

// PluginPrice CloudQuery Plugin Price
type PluginPrice struct {
	// EffectiveFrom The date and time the price came (or will come) into effect.
	EffectiveFrom time.Time `json:"effective_from"`

	// FreeRowsPerMonth The number of rows that can be synced for free each month.
	FreeRowsPerMonth int64 `json:"free_rows_per_month"`

	// ID ID of the price change
	ID openapi_types.UUID `json:"id"`

	// USDPerRow The price per row in USD. This is used to calculate the price of a sync.
	USDPerRow string `json:"usd_per_row"`
}

// PluginPriceCategory Supported price categories for billing
type PluginPriceCategory string

// PluginPriceCreate CloudQuery Plugin Price Create
type PluginPriceCreate struct {
	// EffectiveFrom The date and time the price came (or will come) into effect.
	EffectiveFrom time.Time `json:"effective_from"`

	// FreeRowsPerMonth The number of rows that can be synced for free each month.
	FreeRowsPerMonth int64 `json:"free_rows_per_month"`

	// USDPerRow The price per row in USD. This is used to calculate the price of a sync.
	USDPerRow string `json:"usd_per_row"`
}

// PluginProtocols The CloudQuery protocols supported by this plugin version (only protocol 3 is supported by new plugins).
type PluginProtocols = []int

// PluginReleaseStage Official plugins can go through three release stages: Coming Soon, Preview, and GA.
// The Coming Soon stage is for plugins that are not yet ready for Preview, but users can subscribe to be notified when they are ready.
// Both Preview and GA plugins follow semantic versioning. The main differences between the two stages are:
// Preview plugins are still experimental and may have frequent breaking changes. Preview plugins might get deprecated due to lack of usage. Long Term Support with community Discord and bug fixes is only guaranteed for GA plugins. Premium plugins are often discounted or free during the Preview stage.
type PluginReleaseStage string

// PluginReleaseStageCreate Official plugins can go through three release stages: Coming Soon, Preview, and GA.
// The Coming Soon stage is for plugins that are not yet ready for Preview, but users can subscribe to be notified when they are ready.
// Both Preview and GA plugins follow semantic versioning. The main differences between the two stages are:
// Preview plugins are still experimental and may have frequent breaking changes. Preview plugins might get deprecated due to lack of usage. Long Term Support with community Discord and bug fixes is only guaranteed for GA plugins. Premium plugins are often discounted or free during the Preview stage.
type PluginReleaseStageCreate string

// PluginReleaseStageUpdate Official plugins can go through three release stages: Coming Soon, Preview, and GA.
// The Coming Soon stage is for plugins that are not yet ready for Preview, but users can subscribe to be notified when they are ready.
// Both Preview and GA plugins follow semantic versioning. The main differences between the two stages are:
// Preview plugins are still experimental and may have frequent breaking changes. Preview plugins might get deprecated due to lack of usage. Long Term Support with community Discord and bug fixes is only guaranteed for GA plugins. Premium plugins are often discounted or free during the Preview stage.
type PluginReleaseStageUpdate string

// PluginSpecJSONSchema The specification of the plugin. This is a JSON schema that describes the configuration of the plugin.
type PluginSpecJSONSchema = string

// PluginTable CloudQuery Plugin Table
type PluginTable struct {
	// Description Description of the table
	Description string `json:"description"`

	// IsIncremental Whether the table is incremental
	IsIncremental bool `json:"is_incremental"`

	// IsPaid Whether the table is paid
	IsPaid *bool `json:"is_paid,omitempty"`

	// Name Name of the table
	Name PluginTableName `json:"name"`

	// Parent Name of the parent table, if any
	Parent *string `json:"parent,omitempty"`

	// Relations Names of the tables that depend on this table
	Relations []string `json:"relations"`

	// Title Title of the table
	Title string `json:"title"`
}

// PluginTableColumn CloudQuery Plugin Column
type PluginTableColumn struct {
	// Description Description of the column
	Description string `json:"description"`

	// IncrementalKey Whether the column is used as an incremental key
	IncrementalKey bool `json:"incremental_key"`

	// Name Name of the column
	Name string `json:"name"`

	// NotNull Whether the column is nullable
	NotNull bool `json:"not_null"`

	// PrimaryKey Whether the column is part of the primary key
	PrimaryKey bool `json:"primary_key"`

	// Type Arrow Type of the column
	Type string `json:"type"`

	// TypeSchema For columns of type JSON, the schema of the JSON object
	TypeSchema *string `json:"type_schema,omitempty"`

	// Unique Whether the column has a unique constraint
	Unique bool `json:"unique"`
}

// PluginTableCreate CloudQuery Plugin Table
type PluginTableCreate struct {
	Columns *[]PluginTableColumn `json:"columns,omitempty"`

	// Description Description of the table
	Description *string `json:"description,omitempty"`

	// IsIncremental Whether the table is incremental
	IsIncremental *bool `json:"is_incremental,omitempty"`

	// IsPaid Whether the table is paid
	IsPaid *bool `json:"is_paid,omitempty"`

	// Name Name of the table
	Name PluginTableName `json:"name"`

	// Parent Name of the parent table, if any
	Parent *string `json:"parent,omitempty"`

	// PermissionsNeeded List of permissions needed to access this table, if any
	PermissionsNeeded *[]string `json:"permissions_needed,omitempty"`

	// Relations Names of the tables that depend on this table
	Relations *[]string `json:"relations,omitempty"`

	// SensitiveColumns List of columns within this table that can contain sensitive/secret data
	SensitiveColumns *[]string `json:"sensitive_columns,omitempty"`

	// Title Title of the table
	Title *string `json:"title,omitempty"`
}

// PluginTableDetails defines model for PluginTableDetails.
type PluginTableDetails struct {
	// Columns List of columns
	Columns []PluginTableColumn `json:"columns"`

	// Description Description of the table
	Description string `json:"description"`

	// IsIncremental Whether the table is incremental
	IsIncremental bool `json:"is_incremental"`

	// IsPaid Whether the table is paid
	IsPaid *bool `json:"is_paid,omitempty"`

	// Name Name of the table
	Name string `json:"name"`

	// Parent Name of the parent table, if any
	Parent *string `json:"parent,omitempty"`

	// PermissionsNeeded List of permissions needed to access this table, if any
	PermissionsNeeded []string `json:"permissions_needed"`

	// Relations Names of the tables that depend on this table
	Relations []string `json:"relations"`

	// SensitiveColumns List of columns within this table that can contain sensitive/secret data
	SensitiveColumns *[]string `json:"sensitive_columns,omitempty"`

	// Title Title of the table
	Title string `json:"title"`
}

// PluginTableName Name of the table
type PluginTableName = string

// PluginTier This field is deprecated, refer to `price_category` instead.
// This field is only kept for backward compatibility and may be removed in a future release.
// Supported tiers for plugins.
//   - free: Free tier, with no paid tables.
//   - paid: Paid tier. These plugins may have paid tables, but can also have free tables. They require login to access.
//   - open-core: This option is deprecated, values will either be free or paid.
type PluginTier string

// PluginUIAsset CloudQuery Plugin UI Asset
type PluginUIAsset struct {
	// Name The path and name of the asset
	Name string `json:"name"`

	// UploadURL URL to upload the asset to
	UploadURL string `json:"upload_url"`
}

// PluginUIAssetUploadRequest CloudQuery Plugin UI Asset Upload Request
type PluginUIAssetUploadRequest struct {
	// ContentType Content-type of the asset
	ContentType *string `json:"content_type,omitempty"`

	// Name The path and name of the asset
	Name string `json:"name"`
}

// PluginUpdate defines model for PluginUpdate.
type PluginUpdate struct {
	// Category Supported categories for plugins
	Category *PluginCategory `json:"category,omitempty"`

	// DisplayName The plugin's display name, as shown in the CloudQuery Hub.
	DisplayName *string `json:"display_name,omitempty"`

	// FreeRowsPerMonth Deprecated. Update `price_category` instead.
	// Deprecated:
	FreeRowsPerMonth *int64  `json:"free_rows_per_month,omitempty"`
	Homepage         *string `json:"homepage,omitempty"`

	// Logo URL to the plugin's logo. This will be shown in the CloudQuery Hub.
	Logo *string `json:"logo,omitempty"`

	// PriceCategory Supported price categories for billing
	PriceCategory *PluginPriceCategory `json:"price_category,omitempty"`

	// Public If plugin is not public, it won't be visible to other teams in the CloudQuery Hub.
	Public *bool `json:"public,omitempty"`

	// ReleaseStage Official plugins can go through three release stages: Coming Soon, Preview, and GA.
	// The Coming Soon stage is for plugins that are not yet ready for Preview, but users can subscribe to be notified when they are ready.
	// Both Preview and GA plugins follow semantic versioning. The main differences between the two stages are:
	// Preview plugins are still experimental and may have frequent breaking changes. Preview plugins might get deprecated due to lack of usage. Long Term Support with community Discord and bug fixes is only guaranteed for GA plugins. Premium plugins are often discounted or free during the Preview stage.
	ReleaseStage *PluginReleaseStageUpdate `json:"release_stage,omitempty"`
	Repository   *string                   `json:"repository,omitempty"`

	// ShortDescription Short description of the plugin. This will be shown in the CloudQuery Hub.
	ShortDescription *string `json:"short_description,omitempty"`

	// Tier This field is deprecated, refer to `price_category` instead.
	// This field is only kept for backward compatibility and may be removed in a future release.
	// Supported tiers for plugins.
	//   - free: Free tier, with no paid tables.
	//   - paid: Paid tier. These plugins may have paid tables, but can also have free tables. They require login to access.
	//   - open-core: This option is deprecated, values will either be free or paid.
	// Deprecated:
	Tier *PluginTier `json:"tier,omitempty"`

	// USDPerRow Deprecated. Update `price_category` instead.
	// Deprecated:
	USDPerRow *string `json:"usd_per_row,omitempty"`
}

// PluginVersion defines model for PluginVersion.
type PluginVersion struct {
	// Checksums The checksums of the plugin assets
	Checksums []string `json:"checksums"`

	// ConnectorRequired Whether a connector is required for this plugin version
	ConnectorRequired *bool `json:"connector_required,omitempty"`

	// ConnectorTypes List of connector types available for this plugin version
	ConnectorTypes *[]string `json:"connector_types,omitempty"`

	// CreatedAt The date and time the plugin version was created.
	CreatedAt time.Time `json:"created_at"`

	// Draft If a plugin version is in draft, it will not show to members outside the team or be counted as the latest version.
	Draft bool `json:"draft"`

	// Message Description of what's new or changed in this version (supports markdown)
	Message string `json:"message"`

	// Name The version in semantic version format.
	Name VersionName `json:"name"`

	// PackageType The package type of the plugin assets
	PackageType PluginPackageType `json:"package_type"`

	// Protocols The CloudQuery protocols supported by this plugin version (only protocol 3 is supported by new plugins).
	Protocols PluginProtocols `json:"protocols"`

	// PublishedAt The date and time the plugin version was set to non-draft (published).
	PublishedAt *time.Time `json:"published_at,omitempty"`

	// Retracted If a plugin version is retracted, assets will still be available for download, but the version will be marked as retracted to discourage use.
	Retracted bool `json:"retracted"`

	// SpecJsonSchema The specification of the plugin. This is a JSON schema that describes the configuration of the plugin.
	SpecJsonSchema *PluginSpecJSONSchema `json:"spec_json_schema,omitempty"`

	// SupportedTargets The targets supported by this plugin version, formatted as <os>_<arch>
	SupportedTargets []string `json:"supported_targets"`
}

// PluginVersionBase CloudQuery Plugin Version
type PluginVersionBase struct {
	// Checksums The checksums of the plugin assets
	Checksums []string `json:"checksums"`

	// CreatedAt The date and time the plugin version was created.
	CreatedAt time.Time `json:"created_at"`

	// Draft If a plugin version is in draft, it will not show to members outside the team or be counted as the latest version.
	Draft bool `json:"draft"`

	// Message Description of what's new or changed in this version (supports markdown)
	Message string `json:"message"`

	// Name The version in semantic version format.
	Name VersionName `json:"name"`

	// PackageType The package type of the plugin assets
	PackageType PluginPackageType `json:"package_type"`

	// Protocols The CloudQuery protocols supported by this plugin version (only protocol 3 is supported by new plugins).
	Protocols PluginProtocols `json:"protocols"`

	// PublishedAt The date and time the plugin version was set to non-draft (published).
	PublishedAt *time.Time `json:"published_at,omitempty"`

	// Retracted If a plugin version is retracted, assets will still be available for download, but the version will be marked as retracted to discourage use.
	Retracted bool `json:"retracted"`

	// SupportedTargets The targets supported by this plugin version, formatted as <os>_<arch>
	SupportedTargets []string `json:"supported_targets"`
}

// PluginVersionDetails defines model for PluginVersionDetails.
type PluginVersionDetails struct {
	// Checksums The checksums of the plugin assets
	Checksums []string `json:"checksums"`

	// ConnectorRequired Whether a connector is required for this plugin version
	ConnectorRequired *bool `json:"connector_required,omitempty"`

	// ConnectorTypes List of connector types available for this plugin version
	ConnectorTypes *[]string `json:"connector_types,omitempty"`

	// CreatedAt The date and time the plugin version was created.
	CreatedAt time.Time `json:"created_at"`

	// Draft If a plugin version is in draft, it will not show to members outside the team or be counted as the latest version.
	Draft bool `json:"draft"`

	// ExampleConfig Example configuration for the plugin. This can be used in generated quickstart guides, for example. Markdown format.
	ExampleConfig string `json:"example_config"`

	// Message Description of what's new or changed in this version (supports markdown)
	Message string `json:"message"`

	// Name The version in semantic version format.
	Name VersionName `json:"name"`

	// PackageType The package type of the plugin assets
	PackageType PluginPackageType `json:"package_type"`

	// Protocols The CloudQuery protocols supported by this plugin version (only protocol 3 is supported by new plugins).
	Protocols PluginProtocols `json:"protocols"`

	// PublishedAt The date and time the plugin version was set to non-draft (published).
	PublishedAt *time.Time `json:"published_at,omitempty"`

	// Retracted If a plugin version is retracted, assets will still be available for download, but the version will be marked as retracted to discourage use.
	Retracted bool `json:"retracted"`

	// SpecJsonSchema The specification of the plugin. This is a JSON schema that describes the configuration of the plugin.
	SpecJsonSchema *PluginSpecJSONSchema `json:"spec_json_schema,omitempty"`

	// SupportedTargets The targets supported by this plugin version, formatted as <os>_<arch>
	SupportedTargets []string `json:"supported_targets"`

	// UIBaseURL Base URL for the plugin's UI. Only available for plugins with a UI and for logged in users.
	UIBaseURL *string `json:"ui_base_url,omitempty"`

	// UIBaseURLv2 Base URL for the plugin's UI. Only available for plugins with a UI and for logged in users.
	UIBaseURLv2 *string `json:"ui_base_url_v2,omitempty"`

	// UIID ID of the plugin's UI.
	UIID *openapi_types.UUID `json:"ui_id,omitempty"`
}

// PluginVersionList CloudQuery Plugin Version
type PluginVersionList = PluginVersionBase

// PluginVersionUpdate defines model for PluginVersionUpdate.
type PluginVersionUpdate struct {
	// Checksums The SHA-256 checksums of the plugin binaries, one per supported target.
	Checksums *[]string `json:"checksums,omitempty"`

	// Draft If a plugin version is in draft, it will not show to members outside the team or be counted as the latest version. Once draft is set to false, only certain fields can be updated.
	Draft *bool `json:"draft,omitempty"`

	// Message Description of what's new or changed in this version (supports markdown)
	Message *string `json:"message,omitempty"`

	// PackageType The package type of the plugin binaries
	PackageType *string `json:"package_type,omitempty"`

	// Protocols The CloudQuery protocols supported by this plugin version (only protocol 3 is supported by new plugins).
	Protocols *PluginProtocols `json:"protocols,omitempty"`

	// Retracted If a plugin version is retracted, assets will still be available for download, but the version will be marked as retracted to discourage use.
	Retracted *bool `json:"retracted,omitempty"`

	// SpecJsonSchema The specification of the plugin. This is a JSON schema that describes the configuration of the plugin.
	SpecJsonSchema   *PluginSpecJSONSchema `json:"spec_json_schema,omitempty"`
	SupportedTargets *[]string             `json:"supported_targets,omitempty"`
}

// PriceCategorySpend Spend by price category for a defined period.
type PriceCategorySpend struct {
	// Category Supported price categories for billing
	Category PluginPriceCategory `json:"category"`
	Total    string              `json:"total"`
}

// RegisterUser201Response defines model for RegisterUser_201_response.
type RegisterUser201Response struct {
	// CustomToken Token to exchange for ID token
	CustomToken string `json:"custom_token"`

	// Email Indicates successful user creation
	Email string `json:"email"`
}

// RegisterUserRequest defines model for RegisterUser_request.
type RegisterUserRequest struct {
	// Email Email address
	Email interface{} `json:"email"`

	// Password Password for the new user account
	Password             interface{}            `json:"password"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RegistryAuthToken JWT token for the image registry
type RegistryAuthToken struct {
	AccessToken string `json:"access_token"`
	Token       string `json:"token"`
}

// ReleaseURL defines model for ReleaseURL.
type ReleaseURL struct {
	Url string `json:"url"`
}

// RemoveTeamMembershipRequest defines model for RemoveTeamMembership_request.
type RemoveTeamMembershipRequest struct {
	Email string `json:"email"`
}

// RenewPlatformActivation200Response defines model for RenewPlatformActivation_200_response.
type RenewPlatformActivation200Response struct {
	// NextCheckInSeconds Time in seconds until the next check in
	NextCheckInSeconds   interface{}            `json:"next_check_in_seconds"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RenewPlatformActivationRequest defines model for RenewPlatformActivation_request.
type RenewPlatformActivationRequest struct {
	// ActivationID Previous activation ID
	ActivationID interface{} `json:"activation_id"`

	// InstallationID Installation ID of the platform
	InstallationID       interface{}            `json:"installation_id"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ReportPlatformDataRequest defines model for ReportPlatformData_request.
type ReportPlatformDataRequest struct {
	// InstallationID Installation ID of the platform
	InstallationID       interface{}            `json:"installation_id"`
	UserAdditions        interface{}            `json:"user_additions,omitempty"`
	UserRemovals         interface{}            `json:"user_removals,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ReportTenantPlatformDataRequest defines model for ReportTenantPlatformData_request.
type ReportTenantPlatformDataRequest struct {
	Host                 string                 `json:"host"`
	UserAdditions        interface{}            `json:"user_additions,omitempty"`
	UserRemovals         interface{}            `json:"user_removals,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ResetUserPasswordRequest defines model for ResetUserPassword_request.
type ResetUserPasswordRequest struct {
	// Email Email address to reset
	Email interface{} `json:"email"`

	// Subdomain Subdomain to use in the URL
	Subdomain            *interface{}           `json:"subdomain,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SendAnonymousEventRequest defines model for SendAnonymousEvent_request.
type SendAnonymousEventRequest struct {
	// AnonymousID Anonymous ID identifying the user
	AnonymousID interface{} `json:"anonymous_id"`

	// Name Name of event
	Name interface{} `json:"name"`

	// Properties Properties of event, keys should be of string type
	Properties           *interface{}           `json:"properties,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SendUserEventRequest defines model for SendUserEvent_request.
type SendUserEventRequest struct {
	// Name Name of event
	Name interface{} `json:"name"`

	// Properties Properties of event, keys should be of string type
	Properties           *interface{}           `json:"properties,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Settings Platform settings definition
type Settings struct {
	// EnforceMfa Whether or not to require MFA for all users
	EnforceMfa bool `json:"enforce_mfa"`
}

// SettingsUpdate Platform settings partial update
type SettingsUpdate struct {
	// EnforceMfa Whether or not to require MFA for all users
	EnforceMfa *bool `json:"enforce_mfa,omitempty"`
}

// SpendSummary A spend summary for a team, summarizing the spend by each price category over a given time range.
// Note that empty or all-zero values are not included in the response.
type SpendSummary struct {
	// Metadata Additional metadata about the spend summary. This may include information about the time range, the aggregation period, or other details.
	Metadata             SpendSummaryMetadata   `json:"metadata"`
	Values               interface{}            `json:"values"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SpendSummaryValue A spend summary value.
type SpendSummaryValue struct {
	ByCategory []PriceCategorySpend `json:"by_category"`

	// Date The timestamp for the spend summary.
	Date time.Time `json:"date"`

	// Total Total spend for the period in USD.
	Total string `json:"total"`
}

// SpendSummaryMetadata Additional metadata about the spend summary. This may include information about the time range, the aggregation period, or other details.
type SpendSummaryMetadata struct {
	// End The exclusive end of the query time range.
	End interface{} `json:"end"`

	// Start The inclusive start of the query time range.
	Start interface{} `json:"start"`
}

// SpendingLimit A configurable spending limit for the team. Empty values indicate no limit.
type SpendingLimit struct {
	// CreatedAt The date and time the team limit was created.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// UpdatedAt The date and time the team limit was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// USD The maximum USD amount the team is allowed to use within a calendar month.
	USD *int `json:"usd,omitempty"`
}

// SpendingLimitCreate A configurable monthly limit for team usage.
type SpendingLimitCreate struct {
	// USD The maximum USD amount the team is allowed to use within a calendar month.
	USD int `json:"usd"`
}

// SpendingLimitUpdate A configurable spending limit for the team.
type SpendingLimitUpdate struct {
	// USD The maximum USD amount the team is allowed to use within a calendar month.
	USD int `json:"usd"`
}

// Team CloudQuery Team
type Team struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DisplayName The team's display name
	DisplayName   string `json:"display_name"`
	Internal      bool   `json:"internal"`
	IsTrialActive bool   `json:"is_trial_active"`

	// Name The unique name for the team.
	Name TeamName `json:"name"`

	// Plan The plan the team is on (trial is deprecated)
	Plan         TeamPlan   `json:"plan"`
	PlanEndTime  *time.Time `json:"plan_end_time,omitempty"`
	TrialEndTime *time.Time `json:"trial_end_time,omitempty"`
}

// TeamImage defines model for TeamImage.
type TeamImage struct {
	// Checksum SHA1 checksum of image
	Checksum string `json:"checksum"`

	// Name Name of image
	Name string `json:"name"`

	// RequiredHeaders Required HTTP headers to include for the upload
	RequiredHeaders map[string]interface{} `json:"required_headers"`

	// UploadURL URL to upload image
	UploadURL *string `json:"upload_url,omitempty"`

	// URL URL to download image
	URL string `json:"url"`
}

// TeamImageCreate defines model for TeamImageCreate.
type TeamImageCreate struct {
	// Checksum SHA1 checksum of image
	Checksum string `json:"checksum"`

	// ContentType The HTTP Content-Type of the image or asset
	ContentType ContentType `json:"content_type"`

	// Name Name of image
	Name string `json:"name"`
}

// TeamName The unique name for the team.
type TeamName = string

// TeamPlan The plan the team is on (trial is deprecated)
type TeamPlan string

// TeamSubscriptionOrder Team subscription order
type TeamSubscriptionOrder struct {
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CompletionURL Stripe URL for completing purchase. Only shown in response to POST request when a paid plan is selected.
	CompletionURL *string   `json:"completion_url,omitempty"`
	CreatedAt     time.Time `json:"created_at"`

	// TeamSubscriptionOrderID ID of the team subscription order
	TeamSubscriptionOrderID TeamSubscriptionOrderID `json:"id"`

	// Plan The plan the team is on (trial is deprecated)
	Plan   TeamPlan                    `json:"plan"`
	Status TeamSubscriptionOrderStatus `json:"status"`

	// TeamName The unique name for the team.
	TeamName  TeamName  `json:"team_name"`
	UpdatedAt time.Time `json:"updated_at"`
}

// TeamSubscriptionOrderCreate Create team subscription order
type TeamSubscriptionOrderCreate struct {
	// CancelUrl URL to redirect to after order cancellation
	CancelUrl string `json:"cancel_url"`

	// Plan The plan the team is on (trial is deprecated)
	Plan TeamPlan `json:"plan"`

	// SuccessUrl URL to redirect to after successful order completion
	SuccessUrl string `json:"success_url"`
}

// TeamSubscriptionOrderID ID of the team subscription order
type TeamSubscriptionOrderID = openapi_types.UUID

// TeamSubscriptionOrderStatus defines model for TeamSubscriptionOrderStatus.
type TeamSubscriptionOrderStatus string

// TenantUser Tenant information of a platform user
type TenantUser struct {
	// Provider Login provider of the tenant
	Provider *string `json:"provider,omitempty"`

	// TenantURL URL of the tenant
	TenantURL string `json:"tenant_url"`
}

// UpdateCurrentUserRequest defines model for UpdateCurrentUser_request.
type UpdateCurrentUserRequest struct {
	// Name The unique name for the user.
	Name *UserName `json:"name,omitempty"`

	// Onboarded Whether the user has completed onboarding
	Onboarded            *UserOnboarded         `json:"onboarded,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UpdateCustomerRequest defines model for UpdateCustomer_request.
type UpdateCustomerRequest struct {
	CompanyName             *string                `json:"company_name,omitempty"`
	FirstName               string                 `json:"first_name"`
	LastName                string                 `json:"last_name"`
	LearnedAboutCqFrom      *string                `json:"learned_about_cq_from,omitempty"`
	LearnedAboutCqFromOther *string                `json:"learned_about_cq_from_other,omitempty"`
	Phone                   *string                `json:"phone,omitempty"`
	AdditionalProperties    map[string]interface{} `json:"-"`
}

// UpdateTeamRequest defines model for UpdateTeam_request.
type UpdateTeamRequest struct {
	// DisplayName The team's display name
	DisplayName          *interface{}           `json:"display_name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UploadImageRequest defines model for UploadImage_request.
type UploadImageRequest struct {
	// ContentType The HTTP Content-Type of the image or asset
	ContentType ContentType `json:"content_type"`
}

// UploadPluginUIAssets201Response defines model for UploadPluginUIAssets_201_response.
type UploadPluginUIAssets201Response struct {
	Assets []PluginUIAsset `json:"assets"`

	// UIID ID representing this upload
	UIID string `json:"ui_id"`
}

// UploadPluginUIAssetsRequest defines model for UploadPluginUIAssets_request.
type UploadPluginUIAssetsRequest struct {
	Assets []PluginUIAssetUploadRequest `json:"assets"`
}

// UsageCurrent The usage of a plugin within the current calendar month.
type UsageCurrent struct {
	// PluginKind The kind of plugin, ie. source or destination.
	PluginKind PluginKind `json:"plugin_kind"`

	// PluginName The unique name for the plugin.
	PluginName PluginName `json:"plugin_name"`

	// PluginTeam The unique name for the team.
	PluginTeam TeamName `json:"plugin_team"`

	// RemainingRows Deprecated - this field used to contain the estimated remaining rows but now returns 1 to indicate rows are remaining or 0 if there are no more remaining rows.
	// Deprecated:
	RemainingRows *int64 `json:"remaining_rows,omitempty"`

	// RemainingUSD The remaining USD amount in the plugin's quota for the calendar month.
	// Deprecated:
	RemainingUSD *string `json:"remaining_usd,omitempty"`

	// Rows The number of rows used by the plugin in the calendar month.
	Rows int64 `json:"rows"`

	// USD The USD amount used by the plugin in the calendar month, rounded to two decimal places.
	// Deprecated:
	USD string `json:"usd"`
}

// UsageIncrease Increase the usage of a plugin. This can incur billing costs and should be used only by plugins.
type UsageIncrease struct {
	// InstallationID Installation ID associated with the platform, for platform syncs.
	InstallationID *string `json:"installation_id,omitempty"`

	// PluginKind The kind of plugin, ie. source or destination.
	PluginKind PluginKind `json:"plugin_kind"`

	// PluginName The unique name for the plugin.
	PluginName PluginName `json:"plugin_name"`

	// PluginTeam The unique name for the team.
	PluginTeam TeamName `json:"plugin_team"`

	// RequestId A unique ID associated with the usage increase.
	RequestId openapi_types.UUID `json:"request_id"`

	// Rows The total number of additional rows used by the plugin.
	Rows   int                         `json:"rows"`
	Tables *[]UsageIncreaseTablesInner `json:"tables,omitempty"`
}

// UsageIncreaseTablesInner defines model for UsageIncrease_tables_inner.
type UsageIncreaseTablesInner struct {
	// Name The name of the table.
	Name string `json:"name"`

	// Rows The additional rows used by the table.
	Rows int `json:"rows"`
}

// UsageSummary A usage summary for a team, summarizing the paid rows synced and/or cloud resource usage over a given time range.
// Note that empty or all-zero values are not included in the response.
type UsageSummary struct {
	// Groups The groups of the usage summary. Every group will have a corresponding value at the same index in the values array.
	Groups interface{} `json:"groups"`

	// Metadata Additional metadata about the usage summary. This may include information about the time range, the aggregation period, or other details.
	Metadata             UsageSummaryMetadata   `json:"metadata"`
	Values               interface{}            `json:"values"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UsageSummaryGroup A usage summary group.
type UsageSummaryGroup struct {
	// Name The name of the group.
	Name string `json:"name"`

	// Value The value of the group at this index.
	Value string `json:"value"`
}

// UsageSummaryValue A usage summary value.
type UsageSummaryValue struct {
	// CloudEgressBytes Egress bytes consumed in this period, one per group.
	CloudEgressBytes *[]int64 `json:"cloud_egress_bytes,omitempty"`

	// CloudVcpuSeconds vCPU/seconds consumed in this period, one per group.
	CloudVcpuSeconds *[]int64 `json:"cloud_vcpu_seconds,omitempty"`

	// CloudVramByteSeconds vRAM/byte-seconds consumed in this period, one per group.
	CloudVramByteSeconds *[]int64 `json:"cloud_vram_byte_seconds,omitempty"`

	// PaidRows The paid rows that were synced in this period, one per group.
	PaidRows *[]int64 `json:"paid_rows,omitempty"`

	// Timestamp The timestamp marking the start of a period.
	Timestamp time.Time `json:"timestamp"`
}

// UsageSummaryMetadata Additional metadata about the usage summary. This may include information about the time range, the aggregation period, or other details.
type UsageSummaryMetadata struct {
	// AggregationPeriod The aggregation period to sum data over. In other words, data will be returned at this granularity.
	AggregationPeriod interface{} `json:"aggregation_period"`

	// End The exclusive end of the query time range.
	End interface{} `json:"end"`

	// Metrics List of metrics included in the response.
	Metrics interface{} `json:"metrics"`

	// Start The inclusive start of the query time range.
	Start interface{} `json:"start"`
}

// User CloudQuery User
type User struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Email     string     `json:"email"`

	// ID ID of the User
	ID openapi_types.UUID `json:"id"`

	// Name The unique name for the user.
	Name *UserName `json:"name,omitempty"`

	// Onboarded Whether the user has completed onboarding
	Onboarded *UserOnboarded `json:"onboarded,omitempty"`

	// ProfileImageURL Profile image URL of user
	ProfileImageURL *string    `json:"profile_image_url,omitempty"`
	UpdatedAt       *time.Time `json:"updated_at,omitempty"`
}

// UserID ID of the User
type UserID = openapi_types.UUID

// UserName The unique name for the user.
type UserName = string

// UserOnboarded Whether the user has completed onboarding
type UserOnboarded = bool

// UserTOTPSetup200Response defines model for UserTOTPSetup_200_response.
type UserTOTPSetup200Response struct {
	Secret string `json:"secret"`
	Url    string `json:"url"`
}

// UserTOTPVerify201Response defines model for UserTOTPVerify_201_response.
type UserTOTPVerify201Response struct {
	// CustomToken Token to exchange for ID token
	CustomToken string `json:"custom_token"`
}

// UserTOTPVerifyRequest defines model for UserTOTPVerify_request.
type UserTOTPVerifyRequest struct {
	OTP                  interface{}            `json:"otp"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// VerifyUserEmailRequest defines model for VerifyUserEmail_request.
type VerifyUserEmailRequest struct {
	// Email Email address to verify
	Email interface{} `json:"email"`

	// ReturnTo Return to this URL after verification
	ReturnTo *interface{} `json:"return_to,omitempty"`

	// Subdomain Subdomain to use in the URL
	Subdomain            *interface{}           `json:"subdomain,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// VersionFilter A version filter in semantic version format with prefix ranges.
type VersionFilter = string

// VersionName The version in semantic version format.
type VersionName = string

// AddonSortBy defines model for addon_sort_by.
type AddonSortBy string

// AddonTeam The unique name for the team.
type AddonTeam = TeamName

// EmailBasic defines model for email_basic.
type EmailBasic = string

// IncludeDrafts defines model for include_drafts.
type IncludeDrafts = bool

// IncludeFips defines model for include_fips.
type IncludeFips = bool

// IncludePrereleases defines model for include_prereleases.
type IncludePrereleases = bool

// IncludePrivate defines model for include_private.
type IncludePrivate = bool

// Page defines model for page.
type Page = int64

// PerPage defines model for per_page.
type PerPage = int64

// PluginExcludeReleaseStages defines model for plugin_exclude_release_stages.
type PluginExcludeReleaseStages = []PluginReleaseStage

// PluginIncludeReleaseStages defines model for plugin_include_release_stages.
type PluginIncludeReleaseStages = []PluginReleaseStage

// PluginSortBy defines model for plugin_sort_by.
type PluginSortBy string

// PluginTeam The unique name for the team.
type PluginTeam = TeamName

// TargetName defines model for target_name.
type TargetName = string

// VersionSortBy defines model for version_sort_by.
type VersionSortBy string

// BadRequest defines model for BadRequest.
type BadRequest = FieldError

// Conflict Basic Error
type Conflict = BasicError

// Forbidden defines model for Forbidden.
type Forbidden = FieldError

// InternalError Basic Error
type InternalError = BasicError

// MethodNotAllowed Basic Error
type MethodNotAllowed = BasicError

// NotFound Basic Error
type NotFound = BasicError

// RequiresAuthentication Basic Error
type RequiresAuthentication = BasicError

// ServiceUnavailable Basic Error
type ServiceUnavailable = BasicError

// TooManyRequests Basic Error
type TooManyRequests = BasicError

// UnprocessableEntity defines model for UnprocessableEntity.
type UnprocessableEntity = FieldError

// ListAddonsParams defines parameters for ListAddons.
type ListAddonsParams struct {
	// SortBy The field to sort by
	SortBy *ListAddonsParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListAddonsParamsSortBy defines parameters for ListAddons.
type ListAddonsParamsSortBy string

// ListAddonVersionsParams defines parameters for ListAddonVersions.
type ListAddonVersionsParams struct {
	// SortBy The field to sort by
	SortBy *ListAddonVersionsParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// IncludeDrafts Whether to include draft versions
	IncludeDrafts *IncludeDrafts `form:"include_drafts,omitempty" json:"include_drafts,omitempty"`
}

// ListAddonVersionsParamsSortBy defines parameters for ListAddonVersions.
type ListAddonVersionsParamsSortBy string

// DownloadAddonAssetParams defines parameters for DownloadAddonAsset.
type DownloadAddonAssetParams struct {
	Accept *string `json:"Accept,omitempty"`
}

// ListPluginNotificationRequestsParams defines parameters for ListPluginNotificationRequests.
type ListPluginNotificationRequestsParams struct {
	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListPluginsParams defines parameters for ListPlugins.
type ListPluginsParams struct {
	// SortBy The field to sort by
	SortBy *ListPluginsParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// IncludeReleaseStages Include these release stages in the response
	IncludeReleaseStages *PluginIncludeReleaseStages `form:"include_release_stages,omitempty" json:"include_release_stages,omitempty"`

	// ExcludeReleaseStages Exclude these release stages from the response
	ExcludeReleaseStages *PluginExcludeReleaseStages `form:"exclude_release_stages,omitempty" json:"exclude_release_stages,omitempty"`
}

// ListPluginsParamsSortBy defines parameters for ListPlugins.
type ListPluginsParamsSortBy string

// ListPluginVersionsParams defines parameters for ListPluginVersions.
type ListPluginVersionsParams struct {
	// SortBy The field to sort by
	SortBy *ListPluginVersionsParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// IncludeDrafts Whether to include draft versions
	IncludeDrafts *IncludeDrafts `form:"include_drafts,omitempty" json:"include_drafts,omitempty"`

	// IncludeFips Whether to include fips versions
	IncludeFips *IncludeFips `form:"include_fips,omitempty" json:"include_fips,omitempty"`

	// IncludePrereleases Whether to include prerelease versions
	IncludePrereleases *IncludePrereleases `form:"include_prereleases,omitempty" json:"include_prereleases,omitempty"`
	VersionFilter      *VersionFilter      `form:"version_filter,omitempty" json:"version_filter,omitempty"`
}

// ListPluginVersionsParamsSortBy defines parameters for ListPluginVersions.
type ListPluginVersionsParamsSortBy string

// DownloadPluginAssetParams defines parameters for DownloadPluginAsset.
type DownloadPluginAssetParams struct {
	Accept *string `json:"Accept,omitempty"`
}

// ListPluginVersionDocsParams defines parameters for ListPluginVersionDocs.
type ListPluginVersionDocsParams struct {
	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListPluginVersionTablesParams defines parameters for ListPluginVersionTables.
type ListPluginVersionTablesParams struct {
	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// AuthRegistryRequestParams defines parameters for AuthRegistryRequest.
type AuthRegistryRequestParams struct {
	// Account Username used for `docker login`
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Service Service requesting the JWT token
	Service *string `form:"service,omitempty" json:"service,omitempty"`

	// Scope Multi-value string containing the repository being access and the operation type (push/pull)
	Scope *string `form:"scope,omitempty" json:"scope,omitempty"`

	// XMetaPluginVersion Plugin version name
	XMetaPluginVersion *string `json:"X-Meta-Plugin-Version,omitempty"`

	// XMetaUserTeamName User's team name
	XMetaUserTeamName *string `json:"X-Meta-User-Team-Name,omitempty"`
}

// ListTeamsParams defines parameters for ListTeams.
type ListTeamsParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// ListAddonOrdersByTeamParams defines parameters for ListAddonOrdersByTeam.
type ListAddonOrdersByTeamParams struct {
	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListAddonsByTeamParams defines parameters for ListAddonsByTeam.
type ListAddonsByTeamParams struct {
	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// IncludePrivate Whether to include private plugins
	IncludePrivate *IncludePrivate `form:"include_private,omitempty" json:"include_private,omitempty"`
}

// DownloadAddonAssetByTeamParams defines parameters for DownloadAddonAssetByTeam.
type DownloadAddonAssetByTeamParams struct {
	Accept *string `json:"Accept,omitempty"`
}

// ListTeamAPIKeysParams defines parameters for ListTeamAPIKeys.
type ListTeamAPIKeysParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// ListTeamInvitationsParams defines parameters for ListTeamInvitations.
type ListTeamInvitationsParams struct {
	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListInvoicesByTeamParams defines parameters for ListInvoicesByTeam.
type ListInvoicesByTeamParams struct {
	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetManagedDatabasesParams defines parameters for GetManagedDatabases.
type GetManagedDatabasesParams struct {
	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetTeamMembershipsParams defines parameters for GetTeamMemberships.
type GetTeamMembershipsParams struct {
	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListPluginsByTeamParams defines parameters for ListPluginsByTeam.
type ListPluginsByTeamParams struct {
	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// IncludePrivate Whether to include private plugins
	IncludePrivate *IncludePrivate `form:"include_private,omitempty" json:"include_private,omitempty"`
}

// DownloadPluginAssetByTeamParams defines parameters for DownloadPluginAssetByTeam.
type DownloadPluginAssetByTeamParams struct {
	Accept *string `json:"Accept,omitempty"`
}

// GetTeamSpendParams defines parameters for GetTeamSpend.
type GetTeamSpendParams struct {
	// Start A valid ISO 8601 date string representing the inclusive start of the period.
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End A valid ISO 8601 date string representing the exclusive end of the period.
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`
}

// ListSubscriptionOrdersByTeamParams defines parameters for ListSubscriptionOrdersByTeam.
type ListSubscriptionOrdersByTeamParams struct {
	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListTeamPluginUsageParams defines parameters for ListTeamPluginUsage.
type ListTeamPluginUsageParams struct {
	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetTeamUsageSummaryParams defines parameters for GetTeamUsageSummary.
type GetTeamUsageSummaryParams struct {
	Metrics *[]GetTeamUsageSummaryParamsMetrics `form:"metrics,omitempty" json:"metrics,omitempty"`
	Start   *time.Time                          `form:"start,omitempty" json:"start,omitempty"`
	End     *time.Time                          `form:"end,omitempty" json:"end,omitempty"`

	// AggregationPeriod An aggregation period to sum data over. In other words, data will be returned at this granularity. Currently only supports day and month.
	AggregationPeriod *GetTeamUsageSummaryParamsAggregationPeriod `form:"aggregation_period,omitempty" json:"aggregation_period,omitempty"`
}

// GetTeamUsageSummaryParamsMetrics defines parameters for GetTeamUsageSummary.
type GetTeamUsageSummaryParamsMetrics string

// GetTeamUsageSummaryParamsAggregationPeriod defines parameters for GetTeamUsageSummary.
type GetTeamUsageSummaryParamsAggregationPeriod string

// GetGroupedTeamUsageSummaryParams defines parameters for GetGroupedTeamUsageSummary.
type GetGroupedTeamUsageSummaryParams struct {
	Metrics *[]GetGroupedTeamUsageSummaryParamsMetrics `form:"metrics,omitempty" json:"metrics,omitempty"`
	Start   *time.Time                                 `form:"start,omitempty" json:"start,omitempty"`
	End     *time.Time                                 `form:"end,omitempty" json:"end,omitempty"`

	// AggregationPeriod An aggregation period to sum data over. In other words, data will be returned at this granularity. Currently only supports day and month.
	AggregationPeriod *GetGroupedTeamUsageSummaryParamsAggregationPeriod `form:"aggregation_period,omitempty" json:"aggregation_period,omitempty"`
}

// GetGroupedTeamUsageSummaryParamsMetrics defines parameters for GetGroupedTeamUsageSummary.
type GetGroupedTeamUsageSummaryParamsMetrics string

// GetGroupedTeamUsageSummaryParamsAggregationPeriod defines parameters for GetGroupedTeamUsageSummary.
type GetGroupedTeamUsageSummaryParamsAggregationPeriod string

// GetGroupedTeamUsageSummaryParamsGroupBy defines parameters for GetGroupedTeamUsageSummary.
type GetGroupedTeamUsageSummaryParamsGroupBy string

// ListUsersByTeamParams defines parameters for ListUsersByTeam.
type ListUsersByTeamParams struct {
	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// ListCurrentUserInvitationsParams defines parameters for ListCurrentUserInvitations.
type ListCurrentUserInvitationsParams struct {
	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetCurrentUserMembershipsParams defines parameters for GetCurrentUserMemberships.
type GetCurrentUserMembershipsParams struct {
	// Page Page number of the results to fetch
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results per page (max 1000).
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// DeterminePlatformTenantByEmailParams defines parameters for DeterminePlatformTenantByEmail.
type DeterminePlatformTenantByEmailParams struct {
	Email string `form:"email" json:"email"`
}

// UserTOTPVerifyParams defines parameters for UserTOTPVerify.
type UserTOTPVerifyParams struct {
	Session *string `form:"__session,omitempty" json:"__session,omitempty"`
}

// CreateAddonJSONRequestBody defines body for CreateAddon for application/json ContentType.
type CreateAddonJSONRequestBody = AddonCreate

// UpdateAddonJSONRequestBody defines body for UpdateAddon for application/json ContentType.
type UpdateAddonJSONRequestBody = AddonUpdate

// UpdateAddonVersionJSONRequestBody defines body for UpdateAddonVersion for application/json ContentType.
type UpdateAddonVersionJSONRequestBody = AddonVersionUpdate

// CreateAddonVersionJSONRequestBody defines body for CreateAddonVersion for application/json ContentType.
type CreateAddonVersionJSONRequestBody = CreateAddonVersionRequest

// ActivatePlatformJSONRequestBody defines body for ActivatePlatform for application/json ContentType.
type ActivatePlatformJSONRequestBody = ActivatePlatformRequest

// RenewPlatformActivationJSONRequestBody defines body for RenewPlatformActivation for application/json ContentType.
type RenewPlatformActivationJSONRequestBody = RenewPlatformActivationRequest

// ReportPlatformDataJSONRequestBody defines body for ReportPlatformData for application/json ContentType.
type ReportPlatformDataJSONRequestBody = ReportPlatformDataRequest

// ReportTenantPlatformDataJSONRequestBody defines body for ReportTenantPlatformData for application/json ContentType.
type ReportTenantPlatformDataJSONRequestBody = ReportTenantPlatformDataRequest

// CreatePluginNotificationRequestJSONRequestBody defines body for CreatePluginNotificationRequest for application/json ContentType.
type CreatePluginNotificationRequestJSONRequestBody = PluginNotificationRequestCreate

// CreatePluginJSONRequestBody defines body for CreatePlugin for application/json ContentType.
type CreatePluginJSONRequestBody = PluginCreate

// UpdatePluginJSONRequestBody defines body for UpdatePlugin for application/json ContentType.
type UpdatePluginJSONRequestBody = PluginUpdate

// CreatePluginUpcomingPriceChangeJSONRequestBody defines body for CreatePluginUpcomingPriceChange for application/json ContentType.
type CreatePluginUpcomingPriceChangeJSONRequestBody = PluginPriceCreate

// UpdatePluginVersionJSONRequestBody defines body for UpdatePluginVersion for application/json ContentType.
type UpdatePluginVersionJSONRequestBody = PluginVersionUpdate

// CreatePluginVersionJSONRequestBody defines body for CreatePluginVersion for application/json ContentType.
type CreatePluginVersionJSONRequestBody = CreatePluginVersionRequest

// DeletePluginVersionDocsJSONRequestBody defines body for DeletePluginVersionDocs for application/json ContentType.
type DeletePluginVersionDocsJSONRequestBody = DeletePluginVersionDocsRequest

// ReplacePluginVersionDocsJSONRequestBody defines body for ReplacePluginVersionDocs for application/json ContentType.
type ReplacePluginVersionDocsJSONRequestBody = CreatePluginVersionDocsRequest

// CreatePluginVersionDocsJSONRequestBody defines body for CreatePluginVersionDocs for application/json ContentType.
type CreatePluginVersionDocsJSONRequestBody = CreatePluginVersionDocsRequest

// DeletePluginVersionTablesJSONRequestBody defines body for DeletePluginVersionTables for application/json ContentType.
type DeletePluginVersionTablesJSONRequestBody = DeletePluginVersionTablesRequest

// CreatePluginVersionTablesJSONRequestBody defines body for CreatePluginVersionTables for application/json ContentType.
type CreatePluginVersionTablesJSONRequestBody = CreatePluginVersionTablesRequest

// UploadPluginUIAssetsJSONRequestBody defines body for UploadPluginUIAssets for application/json ContentType.
type UploadPluginUIAssetsJSONRequestBody = UploadPluginUIAssetsRequest

// FinalizePluginUIAssetUploadJSONRequestBody defines body for FinalizePluginUIAssetUpload for application/json ContentType.
type FinalizePluginUIAssetUploadJSONRequestBody = FinalizePluginUIAssetUploadRequest

// CreateTeamJSONRequestBody defines body for CreateTeam for application/json ContentType.
type CreateTeamJSONRequestBody = CreateTeamRequest

// UpdateTeamJSONRequestBody defines body for UpdateTeam for application/json ContentType.
type UpdateTeamJSONRequestBody = UpdateTeamRequest

// CreateAddonOrderForTeamJSONRequestBody defines body for CreateAddonOrderForTeam for application/json ContentType.
type CreateAddonOrderForTeamJSONRequestBody = AddonOrderCreate

// AIOnboardingChatJSONRequestBody defines body for AIOnboardingChat for application/json ContentType.
type AIOnboardingChatJSONRequestBody = AIOnboardingChatRequest

// AIOnboardingNewConversationJSONRequestBody defines body for AIOnboardingNewConversation for application/json ContentType.
type AIOnboardingNewConversationJSONRequestBody = AIOnboardingNewConversationRequest

// CreateTeamAPIKeyJSONRequestBody defines body for CreateTeamAPIKey for application/json ContentType.
type CreateTeamAPIKeyJSONRequestBody = CreateTeamAPIKeyRequest

// CreateTeamImagesJSONRequestBody defines body for CreateTeamImages for application/json ContentType.
type CreateTeamImagesJSONRequestBody = CreateTeamImagesRequest

// DeleteTeamInvitationJSONRequestBody defines body for DeleteTeamInvitation for application/json ContentType.
type DeleteTeamInvitationJSONRequestBody = DeleteTeamInvitationRequest

// EmailTeamInvitationJSONRequestBody defines body for EmailTeamInvitation for application/json ContentType.
type EmailTeamInvitationJSONRequestBody = EmailTeamInvitationRequest

// AcceptTeamInvitationJSONRequestBody defines body for AcceptTeamInvitation for application/json ContentType.
type AcceptTeamInvitationJSONRequestBody = AcceptTeamInvitationRequest

// CreateManagedDatabaseJSONRequestBody defines body for CreateManagedDatabase for application/json ContentType.
type CreateManagedDatabaseJSONRequestBody = ManagedDatabaseCreate

// RemoveTeamMembershipJSONRequestBody defines body for RemoveTeamMembership for application/json ContentType.
type RemoveTeamMembershipJSONRequestBody = RemoveTeamMembershipRequest

// UpdateSettingsJSONRequestBody defines body for UpdateSettings for application/json ContentType.
type UpdateSettingsJSONRequestBody = SettingsUpdate

// CreateSpendingLimitJSONRequestBody defines body for CreateSpendingLimit for application/json ContentType.
type CreateSpendingLimitJSONRequestBody = SpendingLimitCreate

// UpdateSpendingLimitJSONRequestBody defines body for UpdateSpendingLimit for application/json ContentType.
type UpdateSpendingLimitJSONRequestBody = SpendingLimitUpdate

// CreateSubscriptionOrderForTeamJSONRequestBody defines body for CreateSubscriptionOrderForTeam for application/json ContentType.
type CreateSubscriptionOrderForTeamJSONRequestBody = TeamSubscriptionOrderCreate

// IncreaseTeamPluginUsageJSONRequestBody defines body for IncreaseTeamPluginUsage for application/json ContentType.
type IncreaseTeamPluginUsageJSONRequestBody = UsageIncrease

// UploadImageJSONRequestBody defines body for UploadImage for application/json ContentType.
type UploadImageJSONRequestBody = UploadImageRequest

// UpdateCurrentUserJSONRequestBody defines body for UpdateCurrentUser for application/json ContentType.
type UpdateCurrentUserJSONRequestBody = UpdateCurrentUserRequest

// SendAnonymousEventJSONRequestBody defines body for SendAnonymousEvent for application/json ContentType.
type SendAnonymousEventJSONRequestBody = SendAnonymousEventRequest

// UpdateCustomerJSONRequestBody defines body for UpdateCustomer for application/json ContentType.
type UpdateCustomerJSONRequestBody = UpdateCustomerRequest

// SendUserEventJSONRequestBody defines body for SendUserEvent for application/json ContentType.
type SendUserEventJSONRequestBody = SendUserEventRequest

// LoginUserJSONRequestBody defines body for LoginUser for application/json ContentType.
type LoginUserJSONRequestBody = LoginUserRequest

// RegisterUserJSONRequestBody defines body for RegisterUser for application/json ContentType.
type RegisterUserJSONRequestBody = RegisterUserRequest

// ResetUserPasswordJSONRequestBody defines body for ResetUserPassword for application/json ContentType.
type ResetUserPasswordJSONRequestBody = ResetUserPasswordRequest

// UserTOTPVerifyJSONRequestBody defines body for UserTOTPVerify for application/json ContentType.
type UserTOTPVerifyJSONRequestBody = UserTOTPVerifyRequest

// VerifyUserEmailJSONRequestBody defines body for VerifyUserEmail for application/json ContentType.
type VerifyUserEmailJSONRequestBody = VerifyUserEmailRequest

// Getter for additional properties for AIOnboardingChat200Response. Returns the specified
// element and whether it was found
func (a AIOnboardingChat200Response) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AIOnboardingChat200Response
func (a *AIOnboardingChat200Response) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AIOnboardingChat200Response to handle AdditionalProperties
func (a *AIOnboardingChat200Response) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["function_call"]; found {
		err = json.Unmarshal(raw, &a.FunctionCall)
		if err != nil {
			return fmt.Errorf("error reading 'function_call': %w", err)
		}
		delete(object, "function_call")
	}

	if raw, found := object["function_call_arguments"]; found {
		err = json.Unmarshal(raw, &a.FunctionCallArguments)
		if err != nil {
			return fmt.Errorf("error reading 'function_call_arguments': %w", err)
		}
		delete(object, "function_call_arguments")
	}

	if raw, found := object["function_call_id"]; found {
		err = json.Unmarshal(raw, &a.FunctionCallID)
		if err != nil {
			return fmt.Errorf("error reading 'function_call_id': %w", err)
		}
		delete(object, "function_call_id")
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &a.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
		delete(object, "message")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AIOnboardingChat200Response to handle AdditionalProperties
func (a AIOnboardingChat200Response) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.FunctionCall != nil {
		object["function_call"], err = json.Marshal(a.FunctionCall)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'function_call': %w", err)
		}
	}

	if a.FunctionCallArguments != nil {
		object["function_call_arguments"], err = json.Marshal(a.FunctionCallArguments)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'function_call_arguments': %w", err)
		}
	}

	if a.FunctionCallID != nil {
		object["function_call_id"], err = json.Marshal(a.FunctionCallID)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'function_call_id': %w", err)
		}
	}

	object["message"], err = json.Marshal(a.Message)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'message': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AIOnboardingChatRequest. Returns the specified
// element and whether it was found
func (a AIOnboardingChatRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AIOnboardingChatRequest
func (a *AIOnboardingChatRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AIOnboardingChatRequest to handle AdditionalProperties
func (a *AIOnboardingChatRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["chat_mode"]; found {
		err = json.Unmarshal(raw, &a.ChatMode)
		if err != nil {
			return fmt.Errorf("error reading 'chat_mode': %w", err)
		}
		delete(object, "chat_mode")
	}

	if raw, found := object["conversation_id"]; found {
		err = json.Unmarshal(raw, &a.ConversationID)
		if err != nil {
			return fmt.Errorf("error reading 'conversation_id': %w", err)
		}
		delete(object, "conversation_id")
	}

	if raw, found := object["function_call_outputs"]; found {
		err = json.Unmarshal(raw, &a.FunctionCallOutputs)
		if err != nil {
			return fmt.Errorf("error reading 'function_call_outputs': %w", err)
		}
		delete(object, "function_call_outputs")
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &a.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
		delete(object, "message")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AIOnboardingChatRequest to handle AdditionalProperties
func (a AIOnboardingChatRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ChatMode != nil {
		object["chat_mode"], err = json.Marshal(a.ChatMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'chat_mode': %w", err)
		}
	}

	if a.ConversationID != nil {
		object["conversation_id"], err = json.Marshal(a.ConversationID)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'conversation_id': %w", err)
		}
	}

	if a.FunctionCallOutputs != nil {
		object["function_call_outputs"], err = json.Marshal(a.FunctionCallOutputs)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'function_call_outputs': %w", err)
		}
	}

	if a.Message != nil {
		object["message"], err = json.Marshal(a.Message)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'message': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AIOnboardingEndConversation200Response. Returns the specified
// element and whether it was found
func (a AIOnboardingEndConversation200Response) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AIOnboardingEndConversation200Response
func (a *AIOnboardingEndConversation200Response) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AIOnboardingEndConversation200Response to handle AdditionalProperties
func (a *AIOnboardingEndConversation200Response) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["success"]; found {
		err = json.Unmarshal(raw, &a.Success)
		if err != nil {
			return fmt.Errorf("error reading 'success': %w", err)
		}
		delete(object, "success")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AIOnboardingEndConversation200Response to handle AdditionalProperties
func (a AIOnboardingEndConversation200Response) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Success != nil {
		object["success"], err = json.Marshal(a.Success)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'success': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AIOnboardingNewConversation200Response. Returns the specified
// element and whether it was found
func (a AIOnboardingNewConversation200Response) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AIOnboardingNewConversation200Response
func (a *AIOnboardingNewConversation200Response) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AIOnboardingNewConversation200Response to handle AdditionalProperties
func (a *AIOnboardingNewConversation200Response) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["conversation_id"]; found {
		err = json.Unmarshal(raw, &a.ConversationID)
		if err != nil {
			return fmt.Errorf("error reading 'conversation_id': %w", err)
		}
		delete(object, "conversation_id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AIOnboardingNewConversation200Response to handle AdditionalProperties
func (a AIOnboardingNewConversation200Response) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["conversation_id"], err = json.Marshal(a.ConversationID)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'conversation_id': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AIOnboardingNewConversationRequest. Returns the specified
// element and whether it was found
func (a AIOnboardingNewConversationRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AIOnboardingNewConversationRequest
func (a *AIOnboardingNewConversationRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AIOnboardingNewConversationRequest to handle AdditionalProperties
func (a *AIOnboardingNewConversationRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["try_resume"]; found {
		err = json.Unmarshal(raw, &a.TryResume)
		if err != nil {
			return fmt.Errorf("error reading 'try_resume': %w", err)
		}
		delete(object, "try_resume")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AIOnboardingNewConversationRequest to handle AdditionalProperties
func (a AIOnboardingNewConversationRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.TryResume != nil {
		object["try_resume"], err = json.Marshal(a.TryResume)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'try_resume': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ActivatePlatform200Response. Returns the specified
// element and whether it was found
func (a ActivatePlatform200Response) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ActivatePlatform200Response
func (a *ActivatePlatform200Response) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ActivatePlatform200Response to handle AdditionalProperties
func (a *ActivatePlatform200Response) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["activation_id"]; found {
		err = json.Unmarshal(raw, &a.ActivationID)
		if err != nil {
			return fmt.Errorf("error reading 'activation_id': %w", err)
		}
		delete(object, "activation_id")
	}

	if raw, found := object["next_check_in_seconds"]; found {
		err = json.Unmarshal(raw, &a.NextCheckInSeconds)
		if err != nil {
			return fmt.Errorf("error reading 'next_check_in_seconds': %w", err)
		}
		delete(object, "next_check_in_seconds")
	}

	if raw, found := object["team_name"]; found {
		err = json.Unmarshal(raw, &a.TeamName)
		if err != nil {
			return fmt.Errorf("error reading 'team_name': %w", err)
		}
		delete(object, "team_name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ActivatePlatform200Response to handle AdditionalProperties
func (a ActivatePlatform200Response) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["activation_id"], err = json.Marshal(a.ActivationID)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'activation_id': %w", err)
	}

	object["next_check_in_seconds"], err = json.Marshal(a.NextCheckInSeconds)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'next_check_in_seconds': %w", err)
	}

	object["team_name"], err = json.Marshal(a.TeamName)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'team_name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ActivatePlatform205Response. Returns the specified
// element and whether it was found
func (a ActivatePlatform205Response) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ActivatePlatform205Response
func (a *ActivatePlatform205Response) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ActivatePlatform205Response to handle AdditionalProperties
func (a *ActivatePlatform205Response) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["button_text"]; found {
		err = json.Unmarshal(raw, &a.ButtonText)
		if err != nil {
			return fmt.Errorf("error reading 'button_text': %w", err)
		}
		delete(object, "button_text")
	}

	if raw, found := object["button_url"]; found {
		err = json.Unmarshal(raw, &a.ButtonURL)
		if err != nil {
			return fmt.Errorf("error reading 'button_url': %w", err)
		}
		delete(object, "button_url")
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ActivatePlatform205Response to handle AdditionalProperties
func (a ActivatePlatform205Response) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ButtonText != nil {
		object["button_text"], err = json.Marshal(a.ButtonText)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'button_text': %w", err)
		}
	}

	if a.ButtonURL != nil {
		object["button_url"], err = json.Marshal(a.ButtonURL)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'button_url': %w", err)
		}
	}

	object["error"], err = json.Marshal(a.Error)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'error': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ActivatePlatformRequest. Returns the specified
// element and whether it was found
func (a ActivatePlatformRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ActivatePlatformRequest
func (a *ActivatePlatformRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ActivatePlatformRequest to handle AdditionalProperties
func (a *ActivatePlatformRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["api_key"]; found {
		err = json.Unmarshal(raw, &a.APIKey)
		if err != nil {
			return fmt.Errorf("error reading 'api_key': %w", err)
		}
		delete(object, "api_key")
	}

	if raw, found := object["installation_id"]; found {
		err = json.Unmarshal(raw, &a.InstallationID)
		if err != nil {
			return fmt.Errorf("error reading 'installation_id': %w", err)
		}
		delete(object, "installation_id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ActivatePlatformRequest to handle AdditionalProperties
func (a ActivatePlatformRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["api_key"], err = json.Marshal(a.APIKey)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'api_key': %w", err)
	}

	object["installation_id"], err = json.Marshal(a.InstallationID)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'installation_id': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateTeamRequest. Returns the specified
// element and whether it was found
func (a CreateTeamRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateTeamRequest
func (a *CreateTeamRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateTeamRequest to handle AdditionalProperties
func (a *CreateTeamRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["display_name"]; found {
		err = json.Unmarshal(raw, &a.DisplayName)
		if err != nil {
			return fmt.Errorf("error reading 'display_name': %w", err)
		}
		delete(object, "display_name")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateTeamRequest to handle AdditionalProperties
func (a CreateTeamRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["display_name"], err = json.Marshal(a.DisplayName)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'display_name': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for FunctionCallOutput. Returns the specified
// element and whether it was found
func (a FunctionCallOutput) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for FunctionCallOutput
func (a *FunctionCallOutput) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for FunctionCallOutput to handle AdditionalProperties
func (a *FunctionCallOutput) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["arguments"]; found {
		err = json.Unmarshal(raw, &a.Arguments)
		if err != nil {
			return fmt.Errorf("error reading 'arguments': %w", err)
		}
		delete(object, "arguments")
	}

	if raw, found := object["call_id"]; found {
		err = json.Unmarshal(raw, &a.CallID)
		if err != nil {
			return fmt.Errorf("error reading 'call_id': %w", err)
		}
		delete(object, "call_id")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["output"]; found {
		err = json.Unmarshal(raw, &a.Output)
		if err != nil {
			return fmt.Errorf("error reading 'output': %w", err)
		}
		delete(object, "output")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for FunctionCallOutput to handle AdditionalProperties
func (a FunctionCallOutput) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["arguments"], err = json.Marshal(a.Arguments)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'arguments': %w", err)
	}

	object["call_id"], err = json.Marshal(a.CallID)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'call_id': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	object["output"], err = json.Marshal(a.Output)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'output': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for LoginUserRequest. Returns the specified
// element and whether it was found
func (a LoginUserRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for LoginUserRequest
func (a *LoginUserRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for LoginUserRequest to handle AdditionalProperties
func (a *LoginUserRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id_token"]; found {
		err = json.Unmarshal(raw, &a.IDToken)
		if err != nil {
			return fmt.Errorf("error reading 'id_token': %w", err)
		}
		delete(object, "id_token")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for LoginUserRequest to handle AdditionalProperties
func (a LoginUserRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id_token"], err = json.Marshal(a.IDToken)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id_token': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RegisterUserRequest. Returns the specified
// element and whether it was found
func (a RegisterUserRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RegisterUserRequest
func (a *RegisterUserRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RegisterUserRequest to handle AdditionalProperties
func (a *RegisterUserRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["email"]; found {
		err = json.Unmarshal(raw, &a.Email)
		if err != nil {
			return fmt.Errorf("error reading 'email': %w", err)
		}
		delete(object, "email")
	}

	if raw, found := object["password"]; found {
		err = json.Unmarshal(raw, &a.Password)
		if err != nil {
			return fmt.Errorf("error reading 'password': %w", err)
		}
		delete(object, "password")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RegisterUserRequest to handle AdditionalProperties
func (a RegisterUserRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["email"], err = json.Marshal(a.Email)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'email': %w", err)
	}

	object["password"], err = json.Marshal(a.Password)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'password': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RenewPlatformActivation200Response. Returns the specified
// element and whether it was found
func (a RenewPlatformActivation200Response) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RenewPlatformActivation200Response
func (a *RenewPlatformActivation200Response) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RenewPlatformActivation200Response to handle AdditionalProperties
func (a *RenewPlatformActivation200Response) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["next_check_in_seconds"]; found {
		err = json.Unmarshal(raw, &a.NextCheckInSeconds)
		if err != nil {
			return fmt.Errorf("error reading 'next_check_in_seconds': %w", err)
		}
		delete(object, "next_check_in_seconds")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RenewPlatformActivation200Response to handle AdditionalProperties
func (a RenewPlatformActivation200Response) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["next_check_in_seconds"], err = json.Marshal(a.NextCheckInSeconds)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'next_check_in_seconds': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RenewPlatformActivationRequest. Returns the specified
// element and whether it was found
func (a RenewPlatformActivationRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RenewPlatformActivationRequest
func (a *RenewPlatformActivationRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RenewPlatformActivationRequest to handle AdditionalProperties
func (a *RenewPlatformActivationRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["activation_id"]; found {
		err = json.Unmarshal(raw, &a.ActivationID)
		if err != nil {
			return fmt.Errorf("error reading 'activation_id': %w", err)
		}
		delete(object, "activation_id")
	}

	if raw, found := object["installation_id"]; found {
		err = json.Unmarshal(raw, &a.InstallationID)
		if err != nil {
			return fmt.Errorf("error reading 'installation_id': %w", err)
		}
		delete(object, "installation_id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RenewPlatformActivationRequest to handle AdditionalProperties
func (a RenewPlatformActivationRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["activation_id"], err = json.Marshal(a.ActivationID)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'activation_id': %w", err)
	}

	object["installation_id"], err = json.Marshal(a.InstallationID)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'installation_id': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ReportPlatformDataRequest. Returns the specified
// element and whether it was found
func (a ReportPlatformDataRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ReportPlatformDataRequest
func (a *ReportPlatformDataRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ReportPlatformDataRequest to handle AdditionalProperties
func (a *ReportPlatformDataRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["installation_id"]; found {
		err = json.Unmarshal(raw, &a.InstallationID)
		if err != nil {
			return fmt.Errorf("error reading 'installation_id': %w", err)
		}
		delete(object, "installation_id")
	}

	if raw, found := object["user_additions"]; found {
		err = json.Unmarshal(raw, &a.UserAdditions)
		if err != nil {
			return fmt.Errorf("error reading 'user_additions': %w", err)
		}
		delete(object, "user_additions")
	}

	if raw, found := object["user_removals"]; found {
		err = json.Unmarshal(raw, &a.UserRemovals)
		if err != nil {
			return fmt.Errorf("error reading 'user_removals': %w", err)
		}
		delete(object, "user_removals")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ReportPlatformDataRequest to handle AdditionalProperties
func (a ReportPlatformDataRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["installation_id"], err = json.Marshal(a.InstallationID)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'installation_id': %w", err)
	}

	if a.UserAdditions != nil {
		object["user_additions"], err = json.Marshal(a.UserAdditions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'user_additions': %w", err)
		}
	}

	if a.UserRemovals != nil {
		object["user_removals"], err = json.Marshal(a.UserRemovals)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'user_removals': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ReportTenantPlatformDataRequest. Returns the specified
// element and whether it was found
func (a ReportTenantPlatformDataRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ReportTenantPlatformDataRequest
func (a *ReportTenantPlatformDataRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ReportTenantPlatformDataRequest to handle AdditionalProperties
func (a *ReportTenantPlatformDataRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["host"]; found {
		err = json.Unmarshal(raw, &a.Host)
		if err != nil {
			return fmt.Errorf("error reading 'host': %w", err)
		}
		delete(object, "host")
	}

	if raw, found := object["user_additions"]; found {
		err = json.Unmarshal(raw, &a.UserAdditions)
		if err != nil {
			return fmt.Errorf("error reading 'user_additions': %w", err)
		}
		delete(object, "user_additions")
	}

	if raw, found := object["user_removals"]; found {
		err = json.Unmarshal(raw, &a.UserRemovals)
		if err != nil {
			return fmt.Errorf("error reading 'user_removals': %w", err)
		}
		delete(object, "user_removals")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ReportTenantPlatformDataRequest to handle AdditionalProperties
func (a ReportTenantPlatformDataRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["host"], err = json.Marshal(a.Host)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'host': %w", err)
	}

	if a.UserAdditions != nil {
		object["user_additions"], err = json.Marshal(a.UserAdditions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'user_additions': %w", err)
		}
	}

	if a.UserRemovals != nil {
		object["user_removals"], err = json.Marshal(a.UserRemovals)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'user_removals': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ResetUserPasswordRequest. Returns the specified
// element and whether it was found
func (a ResetUserPasswordRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ResetUserPasswordRequest
func (a *ResetUserPasswordRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ResetUserPasswordRequest to handle AdditionalProperties
func (a *ResetUserPasswordRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["email"]; found {
		err = json.Unmarshal(raw, &a.Email)
		if err != nil {
			return fmt.Errorf("error reading 'email': %w", err)
		}
		delete(object, "email")
	}

	if raw, found := object["subdomain"]; found {
		err = json.Unmarshal(raw, &a.Subdomain)
		if err != nil {
			return fmt.Errorf("error reading 'subdomain': %w", err)
		}
		delete(object, "subdomain")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ResetUserPasswordRequest to handle AdditionalProperties
func (a ResetUserPasswordRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["email"], err = json.Marshal(a.Email)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'email': %w", err)
	}

	if a.Subdomain != nil {
		object["subdomain"], err = json.Marshal(a.Subdomain)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subdomain': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SendAnonymousEventRequest. Returns the specified
// element and whether it was found
func (a SendAnonymousEventRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SendAnonymousEventRequest
func (a *SendAnonymousEventRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SendAnonymousEventRequest to handle AdditionalProperties
func (a *SendAnonymousEventRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["anonymous_id"]; found {
		err = json.Unmarshal(raw, &a.AnonymousID)
		if err != nil {
			return fmt.Errorf("error reading 'anonymous_id': %w", err)
		}
		delete(object, "anonymous_id")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["properties"]; found {
		err = json.Unmarshal(raw, &a.Properties)
		if err != nil {
			return fmt.Errorf("error reading 'properties': %w", err)
		}
		delete(object, "properties")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SendAnonymousEventRequest to handle AdditionalProperties
func (a SendAnonymousEventRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["anonymous_id"], err = json.Marshal(a.AnonymousID)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'anonymous_id': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Properties != nil {
		object["properties"], err = json.Marshal(a.Properties)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'properties': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SendUserEventRequest. Returns the specified
// element and whether it was found
func (a SendUserEventRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SendUserEventRequest
func (a *SendUserEventRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SendUserEventRequest to handle AdditionalProperties
func (a *SendUserEventRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["properties"]; found {
		err = json.Unmarshal(raw, &a.Properties)
		if err != nil {
			return fmt.Errorf("error reading 'properties': %w", err)
		}
		delete(object, "properties")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SendUserEventRequest to handle AdditionalProperties
func (a SendUserEventRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Properties != nil {
		object["properties"], err = json.Marshal(a.Properties)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'properties': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SpendSummary. Returns the specified
// element and whether it was found
func (a SpendSummary) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SpendSummary
func (a *SpendSummary) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SpendSummary to handle AdditionalProperties
func (a *SpendSummary) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["metadata"]; found {
		err = json.Unmarshal(raw, &a.Metadata)
		if err != nil {
			return fmt.Errorf("error reading 'metadata': %w", err)
		}
		delete(object, "metadata")
	}

	if raw, found := object["values"]; found {
		err = json.Unmarshal(raw, &a.Values)
		if err != nil {
			return fmt.Errorf("error reading 'values': %w", err)
		}
		delete(object, "values")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SpendSummary to handle AdditionalProperties
func (a SpendSummary) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["metadata"], err = json.Marshal(a.Metadata)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'metadata': %w", err)
	}

	object["values"], err = json.Marshal(a.Values)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'values': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateCurrentUserRequest. Returns the specified
// element and whether it was found
func (a UpdateCurrentUserRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateCurrentUserRequest
func (a *UpdateCurrentUserRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateCurrentUserRequest to handle AdditionalProperties
func (a *UpdateCurrentUserRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["onboarded"]; found {
		err = json.Unmarshal(raw, &a.Onboarded)
		if err != nil {
			return fmt.Errorf("error reading 'onboarded': %w", err)
		}
		delete(object, "onboarded")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateCurrentUserRequest to handle AdditionalProperties
func (a UpdateCurrentUserRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	if a.Onboarded != nil {
		object["onboarded"], err = json.Marshal(a.Onboarded)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'onboarded': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateCustomerRequest. Returns the specified
// element and whether it was found
func (a UpdateCustomerRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateCustomerRequest
func (a *UpdateCustomerRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateCustomerRequest to handle AdditionalProperties
func (a *UpdateCustomerRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["company_name"]; found {
		err = json.Unmarshal(raw, &a.CompanyName)
		if err != nil {
			return fmt.Errorf("error reading 'company_name': %w", err)
		}
		delete(object, "company_name")
	}

	if raw, found := object["first_name"]; found {
		err = json.Unmarshal(raw, &a.FirstName)
		if err != nil {
			return fmt.Errorf("error reading 'first_name': %w", err)
		}
		delete(object, "first_name")
	}

	if raw, found := object["last_name"]; found {
		err = json.Unmarshal(raw, &a.LastName)
		if err != nil {
			return fmt.Errorf("error reading 'last_name': %w", err)
		}
		delete(object, "last_name")
	}

	if raw, found := object["learned_about_cq_from"]; found {
		err = json.Unmarshal(raw, &a.LearnedAboutCqFrom)
		if err != nil {
			return fmt.Errorf("error reading 'learned_about_cq_from': %w", err)
		}
		delete(object, "learned_about_cq_from")
	}

	if raw, found := object["learned_about_cq_from_other"]; found {
		err = json.Unmarshal(raw, &a.LearnedAboutCqFromOther)
		if err != nil {
			return fmt.Errorf("error reading 'learned_about_cq_from_other': %w", err)
		}
		delete(object, "learned_about_cq_from_other")
	}

	if raw, found := object["phone"]; found {
		err = json.Unmarshal(raw, &a.Phone)
		if err != nil {
			return fmt.Errorf("error reading 'phone': %w", err)
		}
		delete(object, "phone")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateCustomerRequest to handle AdditionalProperties
func (a UpdateCustomerRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.CompanyName != nil {
		object["company_name"], err = json.Marshal(a.CompanyName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'company_name': %w", err)
		}
	}

	object["first_name"], err = json.Marshal(a.FirstName)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'first_name': %w", err)
	}

	object["last_name"], err = json.Marshal(a.LastName)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'last_name': %w", err)
	}

	if a.LearnedAboutCqFrom != nil {
		object["learned_about_cq_from"], err = json.Marshal(a.LearnedAboutCqFrom)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'learned_about_cq_from': %w", err)
		}
	}

	if a.LearnedAboutCqFromOther != nil {
		object["learned_about_cq_from_other"], err = json.Marshal(a.LearnedAboutCqFromOther)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'learned_about_cq_from_other': %w", err)
		}
	}

	if a.Phone != nil {
		object["phone"], err = json.Marshal(a.Phone)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'phone': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateTeamRequest. Returns the specified
// element and whether it was found
func (a UpdateTeamRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateTeamRequest
func (a *UpdateTeamRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateTeamRequest to handle AdditionalProperties
func (a *UpdateTeamRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["display_name"]; found {
		err = json.Unmarshal(raw, &a.DisplayName)
		if err != nil {
			return fmt.Errorf("error reading 'display_name': %w", err)
		}
		delete(object, "display_name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateTeamRequest to handle AdditionalProperties
func (a UpdateTeamRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.DisplayName != nil {
		object["display_name"], err = json.Marshal(a.DisplayName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'display_name': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UsageSummary. Returns the specified
// element and whether it was found
func (a UsageSummary) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UsageSummary
func (a *UsageSummary) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UsageSummary to handle AdditionalProperties
func (a *UsageSummary) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["groups"]; found {
		err = json.Unmarshal(raw, &a.Groups)
		if err != nil {
			return fmt.Errorf("error reading 'groups': %w", err)
		}
		delete(object, "groups")
	}

	if raw, found := object["metadata"]; found {
		err = json.Unmarshal(raw, &a.Metadata)
		if err != nil {
			return fmt.Errorf("error reading 'metadata': %w", err)
		}
		delete(object, "metadata")
	}

	if raw, found := object["values"]; found {
		err = json.Unmarshal(raw, &a.Values)
		if err != nil {
			return fmt.Errorf("error reading 'values': %w", err)
		}
		delete(object, "values")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UsageSummary to handle AdditionalProperties
func (a UsageSummary) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["groups"], err = json.Marshal(a.Groups)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'groups': %w", err)
	}

	object["metadata"], err = json.Marshal(a.Metadata)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'metadata': %w", err)
	}

	object["values"], err = json.Marshal(a.Values)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'values': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UserTOTPVerifyRequest. Returns the specified
// element and whether it was found
func (a UserTOTPVerifyRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UserTOTPVerifyRequest
func (a *UserTOTPVerifyRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UserTOTPVerifyRequest to handle AdditionalProperties
func (a *UserTOTPVerifyRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["otp"]; found {
		err = json.Unmarshal(raw, &a.OTP)
		if err != nil {
			return fmt.Errorf("error reading 'otp': %w", err)
		}
		delete(object, "otp")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UserTOTPVerifyRequest to handle AdditionalProperties
func (a UserTOTPVerifyRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["otp"], err = json.Marshal(a.OTP)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'otp': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for VerifyUserEmailRequest. Returns the specified
// element and whether it was found
func (a VerifyUserEmailRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for VerifyUserEmailRequest
func (a *VerifyUserEmailRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for VerifyUserEmailRequest to handle AdditionalProperties
func (a *VerifyUserEmailRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["email"]; found {
		err = json.Unmarshal(raw, &a.Email)
		if err != nil {
			return fmt.Errorf("error reading 'email': %w", err)
		}
		delete(object, "email")
	}

	if raw, found := object["return_to"]; found {
		err = json.Unmarshal(raw, &a.ReturnTo)
		if err != nil {
			return fmt.Errorf("error reading 'return_to': %w", err)
		}
		delete(object, "return_to")
	}

	if raw, found := object["subdomain"]; found {
		err = json.Unmarshal(raw, &a.Subdomain)
		if err != nil {
			return fmt.Errorf("error reading 'subdomain': %w", err)
		}
		delete(object, "subdomain")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for VerifyUserEmailRequest to handle AdditionalProperties
func (a VerifyUserEmailRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["email"], err = json.Marshal(a.Email)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'email': %w", err)
	}

	if a.ReturnTo != nil {
		object["return_to"], err = json.Marshal(a.ReturnTo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'return_to': %w", err)
		}
	}

	if a.Subdomain != nil {
		object["subdomain"], err = json.Marshal(a.Subdomain)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subdomain': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}
