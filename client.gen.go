// Package cloudquery_api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.3 DO NOT EDIT.
package cloudquery_api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// HealthCheck request
	HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPlugins request
	ListPlugins(ctx context.Context, params *ListPluginsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePluginWithBody request with any body
	CreatePluginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlugin(ctx context.Context, body CreatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePluginByTeamAndPluginName request
	DeletePluginByTeamAndPluginName(ctx context.Context, teamName TeamName, pluginName PluginName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlugin request
	GetPlugin(ctx context.Context, teamName TeamName, pluginName PluginName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePluginWithBody request with any body
	UpdatePluginWithBody(ctx context.Context, teamName TeamName, pluginName PluginName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePlugin(ctx context.Context, teamName TeamName, pluginName PluginName, body UpdatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPluginVersions request
	ListPluginVersions(ctx context.Context, teamName TeamName, pluginName PluginName, params *ListPluginVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPluginVersion request
	GetPluginVersion(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePluginVersionWithBody request with any body
	UpdatePluginVersionWithBody(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePluginVersion(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body UpdatePluginVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePluginVersionWithBody request with any body
	CreatePluginVersionWithBody(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePluginVersion(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body CreatePluginVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadPluginAsset request
	DownloadPluginAsset(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, targetName TargetName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadPluginAsset request
	UploadPluginAsset(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, targetName TargetName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePluginVersionDocsWithBody request with any body
	DeletePluginVersionDocsWithBody(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePluginVersionDocs(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body DeletePluginVersionDocsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPluginVersionDocs request
	ListPluginVersionDocs(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, params *ListPluginVersionDocsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePluginVersionDocsWithBody request with any body
	CreatePluginVersionDocsWithBody(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePluginVersionDocs(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body CreatePluginVersionDocsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePluginVersionTablesWithBody request with any body
	DeletePluginVersionTablesWithBody(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePluginVersionTables(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body DeletePluginVersionTablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPluginVersionTables request
	ListPluginVersionTables(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, params *ListPluginVersionTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePluginVersionTablesWithBody request with any body
	CreatePluginVersionTablesWithBody(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePluginVersionTables(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body CreatePluginVersionTablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPluginVersionTable request
	GetPluginVersionTable(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, tableName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTeams request
	ListTeams(ctx context.Context, params *ListTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTeamWithBody request with any body
	CreateTeamWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTeam(ctx context.Context, body CreateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamByName request
	GetTeamByName(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTeamWithBody request with any body
	UpdateTeamWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTeam(ctx context.Context, teamName TeamName, body UpdateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTeamAPIKeys request
	ListTeamAPIKeys(ctx context.Context, teamName TeamName, params *ListTeamAPIKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTeamAPIKeyWithBody request with any body
	CreateTeamAPIKeyWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTeamAPIKey(ctx context.Context, teamName TeamName, body CreateTeamAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTeamAPIKey request
	DeleteTeamAPIKey(ctx context.Context, teamName TeamName, aPIKeyName APIKeyName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTeamInvitations request
	ListTeamInvitations(ctx context.Context, teamName TeamName, params *ListTeamInvitationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmailTeamInvitationWithBody request with any body
	EmailTeamInvitationWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EmailTeamInvitation(ctx context.Context, teamName TeamName, body EmailTeamInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptTeamInvitation request
	AcceptTeamInvitation(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelTeamInvitation request
	CancelTeamInvitation(ctx context.Context, teamName TeamName, email Email, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamMemberships request
	GetTeamMemberships(ctx context.Context, teamName TeamName, params *GetTeamMembershipsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePluginsByTeam request
	DeletePluginsByTeam(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPluginsByTeam request
	ListPluginsByTeam(ctx context.Context, teamName TeamName, params *ListPluginsByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsersByTeam request
	ListUsersByTeam(ctx context.Context, teamName TeamName, params *ListUsersByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadImage request
	UploadImage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentUser request
	GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCurrentUserWithBody request with any body
	UpdateCurrentUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCurrentUser(ctx context.Context, body UpdateCurrentUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCurrentUserInvitations request
	ListCurrentUserInvitations(ctx context.Context, params *ListCurrentUserInvitationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentUserMemberships request
	GetCurrentUserMemberships(ctx context.Context, params *GetCurrentUserMembershipsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPlugins(ctx context.Context, params *ListPluginsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPluginsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlugin(ctx context.Context, body CreatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePluginByTeamAndPluginName(ctx context.Context, teamName TeamName, pluginName PluginName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePluginByTeamAndPluginNameRequest(c.Server, teamName, pluginName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlugin(ctx context.Context, teamName TeamName, pluginName PluginName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPluginRequest(c.Server, teamName, pluginName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePluginWithBody(ctx context.Context, teamName TeamName, pluginName PluginName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePluginRequestWithBody(c.Server, teamName, pluginName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlugin(ctx context.Context, teamName TeamName, pluginName PluginName, body UpdatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePluginRequest(c.Server, teamName, pluginName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPluginVersions(ctx context.Context, teamName TeamName, pluginName PluginName, params *ListPluginVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPluginVersionsRequest(c.Server, teamName, pluginName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPluginVersion(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPluginVersionRequest(c.Server, teamName, pluginName, versionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePluginVersionWithBody(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePluginVersionRequestWithBody(c.Server, teamName, pluginName, versionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePluginVersion(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body UpdatePluginVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePluginVersionRequest(c.Server, teamName, pluginName, versionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginVersionWithBody(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginVersionRequestWithBody(c.Server, teamName, pluginName, versionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginVersion(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body CreatePluginVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginVersionRequest(c.Server, teamName, pluginName, versionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadPluginAsset(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, targetName TargetName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadPluginAssetRequest(c.Server, teamName, pluginName, versionName, targetName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadPluginAsset(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, targetName TargetName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadPluginAssetRequest(c.Server, teamName, pluginName, versionName, targetName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePluginVersionDocsWithBody(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePluginVersionDocsRequestWithBody(c.Server, teamName, pluginName, versionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePluginVersionDocs(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body DeletePluginVersionDocsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePluginVersionDocsRequest(c.Server, teamName, pluginName, versionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPluginVersionDocs(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, params *ListPluginVersionDocsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPluginVersionDocsRequest(c.Server, teamName, pluginName, versionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginVersionDocsWithBody(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginVersionDocsRequestWithBody(c.Server, teamName, pluginName, versionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginVersionDocs(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body CreatePluginVersionDocsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginVersionDocsRequest(c.Server, teamName, pluginName, versionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePluginVersionTablesWithBody(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePluginVersionTablesRequestWithBody(c.Server, teamName, pluginName, versionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePluginVersionTables(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body DeletePluginVersionTablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePluginVersionTablesRequest(c.Server, teamName, pluginName, versionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPluginVersionTables(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, params *ListPluginVersionTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPluginVersionTablesRequest(c.Server, teamName, pluginName, versionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginVersionTablesWithBody(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginVersionTablesRequestWithBody(c.Server, teamName, pluginName, versionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginVersionTables(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body CreatePluginVersionTablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginVersionTablesRequest(c.Server, teamName, pluginName, versionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPluginVersionTable(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, tableName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPluginVersionTableRequest(c.Server, teamName, pluginName, versionName, tableName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTeams(ctx context.Context, params *ListTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTeamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTeamWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTeamRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTeam(ctx context.Context, body CreateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTeamRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamByName(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamByNameRequest(c.Server, teamName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeamWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamRequestWithBody(c.Server, teamName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeam(ctx context.Context, teamName TeamName, body UpdateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamRequest(c.Server, teamName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTeamAPIKeys(ctx context.Context, teamName TeamName, params *ListTeamAPIKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTeamAPIKeysRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTeamAPIKeyWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTeamAPIKeyRequestWithBody(c.Server, teamName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTeamAPIKey(ctx context.Context, teamName TeamName, body CreateTeamAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTeamAPIKeyRequest(c.Server, teamName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTeamAPIKey(ctx context.Context, teamName TeamName, aPIKeyName APIKeyName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTeamAPIKeyRequest(c.Server, teamName, aPIKeyName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTeamInvitations(ctx context.Context, teamName TeamName, params *ListTeamInvitationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTeamInvitationsRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailTeamInvitationWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailTeamInvitationRequestWithBody(c.Server, teamName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailTeamInvitation(ctx context.Context, teamName TeamName, body EmailTeamInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailTeamInvitationRequest(c.Server, teamName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptTeamInvitation(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptTeamInvitationRequest(c.Server, teamName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelTeamInvitation(ctx context.Context, teamName TeamName, email Email, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelTeamInvitationRequest(c.Server, teamName, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamMemberships(ctx context.Context, teamName TeamName, params *GetTeamMembershipsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamMembershipsRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePluginsByTeam(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePluginsByTeamRequest(c.Server, teamName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPluginsByTeam(ctx context.Context, teamName TeamName, params *ListPluginsByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPluginsByTeamRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsersByTeam(ctx context.Context, teamName TeamName, params *ListUsersByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersByTeamRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadImage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadImageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCurrentUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCurrentUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCurrentUser(ctx context.Context, body UpdateCurrentUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCurrentUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCurrentUserInvitations(ctx context.Context, params *ListCurrentUserInvitationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCurrentUserInvitationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentUserMemberships(ctx context.Context, params *GetCurrentUserMembershipsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentUserMembershipsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewHealthCheckRequest generates requests for HealthCheck
func NewHealthCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPluginsRequest generates requests for ListPlugins
func NewListPluginsRequest(server string, params *ListPluginsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePluginRequest calls the generic CreatePlugin builder with application/json body
func NewCreatePluginRequest(server string, body CreatePluginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePluginRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePluginRequestWithBody generates requests for CreatePlugin with any type of body
func NewCreatePluginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePluginByTeamAndPluginNameRequest generates requests for DeletePluginByTeamAndPluginName
func NewDeletePluginByTeamAndPluginNameRequest(server string, teamName TeamName, pluginName PluginName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPluginRequest generates requests for GetPlugin
func NewGetPluginRequest(server string, teamName TeamName, pluginName PluginName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePluginRequest calls the generic UpdatePlugin builder with application/json body
func NewUpdatePluginRequest(server string, teamName TeamName, pluginName PluginName, body UpdatePluginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePluginRequestWithBody(server, teamName, pluginName, "application/json", bodyReader)
}

// NewUpdatePluginRequestWithBody generates requests for UpdatePlugin with any type of body
func NewUpdatePluginRequestWithBody(server string, teamName TeamName, pluginName PluginName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPluginVersionsRequest generates requests for ListPluginVersions
func NewListPluginVersionsRequest(server string, teamName TeamName, pluginName PluginName, params *ListPluginVersionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/versions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDrafts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_drafts", runtime.ParamLocationQuery, *params.IncludeDrafts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPluginVersionRequest generates requests for GetPluginVersion
func NewGetPluginVersionRequest(server string, teamName TeamName, pluginName PluginName, versionName VersionName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/versions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePluginVersionRequest calls the generic UpdatePluginVersion builder with application/json body
func NewUpdatePluginVersionRequest(server string, teamName TeamName, pluginName PluginName, versionName VersionName, body UpdatePluginVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePluginVersionRequestWithBody(server, teamName, pluginName, versionName, "application/json", bodyReader)
}

// NewUpdatePluginVersionRequestWithBody generates requests for UpdatePluginVersion with any type of body
func NewUpdatePluginVersionRequestWithBody(server string, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/versions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePluginVersionRequest calls the generic CreatePluginVersion builder with application/json body
func NewCreatePluginVersionRequest(server string, teamName TeamName, pluginName PluginName, versionName VersionName, body CreatePluginVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePluginVersionRequestWithBody(server, teamName, pluginName, versionName, "application/json", bodyReader)
}

// NewCreatePluginVersionRequestWithBody generates requests for CreatePluginVersion with any type of body
func NewCreatePluginVersionRequestWithBody(server string, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/versions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadPluginAssetRequest generates requests for DownloadPluginAsset
func NewDownloadPluginAssetRequest(server string, teamName TeamName, pluginName PluginName, versionName VersionName, targetName TargetName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "target_name", runtime.ParamLocationPath, targetName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/versions/%s/assets/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadPluginAssetRequest generates requests for UploadPluginAsset
func NewUploadPluginAssetRequest(server string, teamName TeamName, pluginName PluginName, versionName VersionName, targetName TargetName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "target_name", runtime.ParamLocationPath, targetName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/versions/%s/assets/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePluginVersionDocsRequest calls the generic DeletePluginVersionDocs builder with application/json body
func NewDeletePluginVersionDocsRequest(server string, teamName TeamName, pluginName PluginName, versionName VersionName, body DeletePluginVersionDocsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePluginVersionDocsRequestWithBody(server, teamName, pluginName, versionName, "application/json", bodyReader)
}

// NewDeletePluginVersionDocsRequestWithBody generates requests for DeletePluginVersionDocs with any type of body
func NewDeletePluginVersionDocsRequestWithBody(server string, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/versions/%s/docs", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPluginVersionDocsRequest generates requests for ListPluginVersionDocs
func NewListPluginVersionDocsRequest(server string, teamName TeamName, pluginName PluginName, versionName VersionName, params *ListPluginVersionDocsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/versions/%s/docs", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePluginVersionDocsRequest calls the generic CreatePluginVersionDocs builder with application/json body
func NewCreatePluginVersionDocsRequest(server string, teamName TeamName, pluginName PluginName, versionName VersionName, body CreatePluginVersionDocsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePluginVersionDocsRequestWithBody(server, teamName, pluginName, versionName, "application/json", bodyReader)
}

// NewCreatePluginVersionDocsRequestWithBody generates requests for CreatePluginVersionDocs with any type of body
func NewCreatePluginVersionDocsRequestWithBody(server string, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/versions/%s/docs", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePluginVersionTablesRequest calls the generic DeletePluginVersionTables builder with application/json body
func NewDeletePluginVersionTablesRequest(server string, teamName TeamName, pluginName PluginName, versionName VersionName, body DeletePluginVersionTablesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePluginVersionTablesRequestWithBody(server, teamName, pluginName, versionName, "application/json", bodyReader)
}

// NewDeletePluginVersionTablesRequestWithBody generates requests for DeletePluginVersionTables with any type of body
func NewDeletePluginVersionTablesRequestWithBody(server string, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/versions/%s/tables", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPluginVersionTablesRequest generates requests for ListPluginVersionTables
func NewListPluginVersionTablesRequest(server string, teamName TeamName, pluginName PluginName, versionName VersionName, params *ListPluginVersionTablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/versions/%s/tables", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePluginVersionTablesRequest calls the generic CreatePluginVersionTables builder with application/json body
func NewCreatePluginVersionTablesRequest(server string, teamName TeamName, pluginName PluginName, versionName VersionName, body CreatePluginVersionTablesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePluginVersionTablesRequestWithBody(server, teamName, pluginName, versionName, "application/json", bodyReader)
}

// NewCreatePluginVersionTablesRequestWithBody generates requests for CreatePluginVersionTables with any type of body
func NewCreatePluginVersionTablesRequestWithBody(server string, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/versions/%s/tables", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPluginVersionTableRequest generates requests for GetPluginVersionTable
func NewGetPluginVersionTableRequest(server string, teamName TeamName, pluginName PluginName, versionName VersionName, tableName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "table_name", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/versions/%s/tables/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTeamsRequest generates requests for ListTeams
func NewListTeamsRequest(server string, params *ListTeamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTeamRequest calls the generic CreateTeam builder with application/json body
func NewCreateTeamRequest(server string, body CreateTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTeamRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTeamRequestWithBody generates requests for CreateTeam with any type of body
func NewCreateTeamRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTeamByNameRequest generates requests for GetTeamByName
func NewGetTeamByNameRequest(server string, teamName TeamName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTeamRequest calls the generic UpdateTeam builder with application/json body
func NewUpdateTeamRequest(server string, teamName TeamName, body UpdateTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTeamRequestWithBody(server, teamName, "application/json", bodyReader)
}

// NewUpdateTeamRequestWithBody generates requests for UpdateTeam with any type of body
func NewUpdateTeamRequestWithBody(server string, teamName TeamName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTeamAPIKeysRequest generates requests for ListTeamAPIKeys
func NewListTeamAPIKeysRequest(server string, teamName TeamName, params *ListTeamAPIKeysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/apikeys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTeamAPIKeyRequest calls the generic CreateTeamAPIKey builder with application/json body
func NewCreateTeamAPIKeyRequest(server string, teamName TeamName, body CreateTeamAPIKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTeamAPIKeyRequestWithBody(server, teamName, "application/json", bodyReader)
}

// NewCreateTeamAPIKeyRequestWithBody generates requests for CreateTeamAPIKey with any type of body
func NewCreateTeamAPIKeyRequestWithBody(server string, teamName TeamName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/apikeys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTeamAPIKeyRequest generates requests for DeleteTeamAPIKey
func NewDeleteTeamAPIKeyRequest(server string, teamName TeamName, aPIKeyName APIKeyName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "apikey_name", runtime.ParamLocationPath, aPIKeyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/apikeys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTeamInvitationsRequest generates requests for ListTeamInvitations
func NewListTeamInvitationsRequest(server string, teamName TeamName, params *ListTeamInvitationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/invitations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEmailTeamInvitationRequest calls the generic EmailTeamInvitation builder with application/json body
func NewEmailTeamInvitationRequest(server string, teamName TeamName, body EmailTeamInvitationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEmailTeamInvitationRequestWithBody(server, teamName, "application/json", bodyReader)
}

// NewEmailTeamInvitationRequestWithBody generates requests for EmailTeamInvitation with any type of body
func NewEmailTeamInvitationRequestWithBody(server string, teamName TeamName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/invitations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAcceptTeamInvitationRequest generates requests for AcceptTeamInvitation
func NewAcceptTeamInvitationRequest(server string, teamName TeamName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/invitations/accept", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelTeamInvitationRequest generates requests for CancelTeamInvitation
func NewCancelTeamInvitationRequest(server string, teamName TeamName, email Email) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/invitations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamMembershipsRequest generates requests for GetTeamMemberships
func NewGetTeamMembershipsRequest(server string, teamName TeamName, params *GetTeamMembershipsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/memberships", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePluginsByTeamRequest generates requests for DeletePluginsByTeam
func NewDeletePluginsByTeamRequest(server string, teamName TeamName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/plugins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPluginsByTeamRequest generates requests for ListPluginsByTeam
func NewListPluginsByTeamRequest(server string, teamName TeamName, params *ListPluginsByTeamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/plugins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeUnlisted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_unlisted", runtime.ParamLocationQuery, *params.IncludeUnlisted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsersByTeamRequest generates requests for ListUsersByTeam
func NewListUsersByTeamRequest(server string, teamName TeamName, params *ListUsersByTeamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadImageRequest generates requests for UploadImage
func NewUploadImageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upload/image")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentUserRequest generates requests for GetCurrentUser
func NewGetCurrentUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCurrentUserRequest calls the generic UpdateCurrentUser builder with application/json body
func NewUpdateCurrentUserRequest(server string, body UpdateCurrentUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCurrentUserRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateCurrentUserRequestWithBody generates requests for UpdateCurrentUser with any type of body
func NewUpdateCurrentUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCurrentUserInvitationsRequest generates requests for ListCurrentUserInvitations
func NewListCurrentUserInvitationsRequest(server string, params *ListCurrentUserInvitationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/invitations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentUserMembershipsRequest generates requests for GetCurrentUserMemberships
func NewGetCurrentUserMembershipsRequest(server string, params *GetCurrentUserMembershipsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/memberships")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// HealthCheckWithResponse request
	HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error)

	// ListPluginsWithResponse request
	ListPluginsWithResponse(ctx context.Context, params *ListPluginsParams, reqEditors ...RequestEditorFn) (*ListPluginsResponse, error)

	// CreatePluginWithBodyWithResponse request with any body
	CreatePluginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginResponse, error)

	CreatePluginWithResponse(ctx context.Context, body CreatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginResponse, error)

	// DeletePluginByTeamAndPluginNameWithResponse request
	DeletePluginByTeamAndPluginNameWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, reqEditors ...RequestEditorFn) (*DeletePluginByTeamAndPluginNameResponse, error)

	// GetPluginWithResponse request
	GetPluginWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, reqEditors ...RequestEditorFn) (*GetPluginResponse, error)

	// UpdatePluginWithBodyWithResponse request with any body
	UpdatePluginWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePluginResponse, error)

	UpdatePluginWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, body UpdatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePluginResponse, error)

	// ListPluginVersionsWithResponse request
	ListPluginVersionsWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, params *ListPluginVersionsParams, reqEditors ...RequestEditorFn) (*ListPluginVersionsResponse, error)

	// GetPluginVersionWithResponse request
	GetPluginVersionWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, reqEditors ...RequestEditorFn) (*GetPluginVersionResponse, error)

	// UpdatePluginVersionWithBodyWithResponse request with any body
	UpdatePluginVersionWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePluginVersionResponse, error)

	UpdatePluginVersionWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body UpdatePluginVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePluginVersionResponse, error)

	// CreatePluginVersionWithBodyWithResponse request with any body
	CreatePluginVersionWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginVersionResponse, error)

	CreatePluginVersionWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body CreatePluginVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginVersionResponse, error)

	// DownloadPluginAssetWithResponse request
	DownloadPluginAssetWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, targetName TargetName, reqEditors ...RequestEditorFn) (*DownloadPluginAssetResponse, error)

	// UploadPluginAssetWithResponse request
	UploadPluginAssetWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, targetName TargetName, reqEditors ...RequestEditorFn) (*UploadPluginAssetResponse, error)

	// DeletePluginVersionDocsWithBodyWithResponse request with any body
	DeletePluginVersionDocsWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePluginVersionDocsResponse, error)

	DeletePluginVersionDocsWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body DeletePluginVersionDocsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePluginVersionDocsResponse, error)

	// ListPluginVersionDocsWithResponse request
	ListPluginVersionDocsWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, params *ListPluginVersionDocsParams, reqEditors ...RequestEditorFn) (*ListPluginVersionDocsResponse, error)

	// CreatePluginVersionDocsWithBodyWithResponse request with any body
	CreatePluginVersionDocsWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginVersionDocsResponse, error)

	CreatePluginVersionDocsWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body CreatePluginVersionDocsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginVersionDocsResponse, error)

	// DeletePluginVersionTablesWithBodyWithResponse request with any body
	DeletePluginVersionTablesWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePluginVersionTablesResponse, error)

	DeletePluginVersionTablesWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body DeletePluginVersionTablesJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePluginVersionTablesResponse, error)

	// ListPluginVersionTablesWithResponse request
	ListPluginVersionTablesWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, params *ListPluginVersionTablesParams, reqEditors ...RequestEditorFn) (*ListPluginVersionTablesResponse, error)

	// CreatePluginVersionTablesWithBodyWithResponse request with any body
	CreatePluginVersionTablesWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginVersionTablesResponse, error)

	CreatePluginVersionTablesWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body CreatePluginVersionTablesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginVersionTablesResponse, error)

	// GetPluginVersionTableWithResponse request
	GetPluginVersionTableWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, tableName string, reqEditors ...RequestEditorFn) (*GetPluginVersionTableResponse, error)

	// ListTeamsWithResponse request
	ListTeamsWithResponse(ctx context.Context, params *ListTeamsParams, reqEditors ...RequestEditorFn) (*ListTeamsResponse, error)

	// CreateTeamWithBodyWithResponse request with any body
	CreateTeamWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTeamResponse, error)

	CreateTeamWithResponse(ctx context.Context, body CreateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTeamResponse, error)

	// GetTeamByNameWithResponse request
	GetTeamByNameWithResponse(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*GetTeamByNameResponse, error)

	// UpdateTeamWithBodyWithResponse request with any body
	UpdateTeamWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamResponse, error)

	UpdateTeamWithResponse(ctx context.Context, teamName TeamName, body UpdateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamResponse, error)

	// ListTeamAPIKeysWithResponse request
	ListTeamAPIKeysWithResponse(ctx context.Context, teamName TeamName, params *ListTeamAPIKeysParams, reqEditors ...RequestEditorFn) (*ListTeamAPIKeysResponse, error)

	// CreateTeamAPIKeyWithBodyWithResponse request with any body
	CreateTeamAPIKeyWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTeamAPIKeyResponse, error)

	CreateTeamAPIKeyWithResponse(ctx context.Context, teamName TeamName, body CreateTeamAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTeamAPIKeyResponse, error)

	// DeleteTeamAPIKeyWithResponse request
	DeleteTeamAPIKeyWithResponse(ctx context.Context, teamName TeamName, aPIKeyName APIKeyName, reqEditors ...RequestEditorFn) (*DeleteTeamAPIKeyResponse, error)

	// ListTeamInvitationsWithResponse request
	ListTeamInvitationsWithResponse(ctx context.Context, teamName TeamName, params *ListTeamInvitationsParams, reqEditors ...RequestEditorFn) (*ListTeamInvitationsResponse, error)

	// EmailTeamInvitationWithBodyWithResponse request with any body
	EmailTeamInvitationWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmailTeamInvitationResponse, error)

	EmailTeamInvitationWithResponse(ctx context.Context, teamName TeamName, body EmailTeamInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*EmailTeamInvitationResponse, error)

	// AcceptTeamInvitationWithResponse request
	AcceptTeamInvitationWithResponse(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*AcceptTeamInvitationResponse, error)

	// CancelTeamInvitationWithResponse request
	CancelTeamInvitationWithResponse(ctx context.Context, teamName TeamName, email Email, reqEditors ...RequestEditorFn) (*CancelTeamInvitationResponse, error)

	// GetTeamMembershipsWithResponse request
	GetTeamMembershipsWithResponse(ctx context.Context, teamName TeamName, params *GetTeamMembershipsParams, reqEditors ...RequestEditorFn) (*GetTeamMembershipsResponse, error)

	// DeletePluginsByTeamWithResponse request
	DeletePluginsByTeamWithResponse(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*DeletePluginsByTeamResponse, error)

	// ListPluginsByTeamWithResponse request
	ListPluginsByTeamWithResponse(ctx context.Context, teamName TeamName, params *ListPluginsByTeamParams, reqEditors ...RequestEditorFn) (*ListPluginsByTeamResponse, error)

	// ListUsersByTeamWithResponse request
	ListUsersByTeamWithResponse(ctx context.Context, teamName TeamName, params *ListUsersByTeamParams, reqEditors ...RequestEditorFn) (*ListUsersByTeamResponse, error)

	// UploadImageWithResponse request
	UploadImageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UploadImageResponse, error)

	// GetCurrentUserWithResponse request
	GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error)

	// UpdateCurrentUserWithBodyWithResponse request with any body
	UpdateCurrentUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCurrentUserResponse, error)

	UpdateCurrentUserWithResponse(ctx context.Context, body UpdateCurrentUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCurrentUserResponse, error)

	// ListCurrentUserInvitationsWithResponse request
	ListCurrentUserInvitationsWithResponse(ctx context.Context, params *ListCurrentUserInvitationsParams, reqEditors ...RequestEditorFn) (*ListCurrentUserInvitationsResponse, error)

	// GetCurrentUserMembershipsWithResponse request
	GetCurrentUserMembershipsWithResponse(ctx context.Context, params *GetCurrentUserMembershipsParams, reqEditors ...RequestEditorFn) (*GetCurrentUserMembershipsResponse, error)
}

type HealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPluginsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []Plugin     `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListPluginsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPluginsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Plugin
	JSON403      *Forbidden
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreatePluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePluginByTeamAndPluginNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeletePluginByTeamAndPluginNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePluginByTeamAndPluginNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plugin
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetPluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plugin
	JSON403      *Forbidden
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdatePluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPluginVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []PluginVersion `json:"items"`
		Metadata ListMetadata    `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListPluginVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPluginVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPluginVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PluginVersion
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetPluginVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPluginVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePluginVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PluginVersion
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdatePluginVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePluginVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePluginVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PluginVersion
	JSON201      *PluginVersion
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreatePluginVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePluginVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadPluginAssetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DownloadPluginAssetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadPluginAssetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadPluginAssetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ReleaseURL
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UploadPluginAssetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadPluginAssetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePluginVersionDocsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeletePluginVersionDocsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePluginVersionDocsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPluginVersionDocsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []PluginDocsPage `json:"items"`
		Metadata ListMetadata     `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListPluginVersionDocsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPluginVersionDocsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePluginVersionDocsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Names *[]PluginDocsPageName `json:"names,omitempty"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r CreatePluginVersionDocsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePluginVersionDocsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePluginVersionTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeletePluginVersionTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePluginVersionTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPluginVersionTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []PluginTable `json:"items"`
		Metadata ListMetadata  `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListPluginVersionTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPluginVersionTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePluginVersionTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Names *[]PluginTableName `json:"names,omitempty"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r CreatePluginVersionTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePluginVersionTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPluginVersionTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PluginTableDetails
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetPluginVersionTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPluginVersionTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []Team       `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Team
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Team
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetTeamByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Team
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTeamAPIKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []APIKey     `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListTeamAPIKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTeamAPIKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTeamAPIKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *APIKey
	JSON401      *RequiresAuthentication
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateTeamAPIKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTeamAPIKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTeamAPIKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteTeamAPIKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTeamAPIKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTeamInvitationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []Invitation `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON403 *Forbidden
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListTeamInvitationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTeamInvitationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmailTeamInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Invitation
	JSON403      *Forbidden
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r EmailTeamInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmailTeamInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptTeamInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Membership
	JSON303      *Membership
	JSON403      *Forbidden
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r AcceptTeamInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptTeamInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelTeamInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CancelTeamInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelTeamInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamMembershipsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []Membership `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r GetTeamMembershipsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamMembershipsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePluginsByTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeletePluginsByTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePluginsByTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPluginsByTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []Plugin     `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListPluginsByTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPluginsByTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersByTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []User       `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON422 *UnprocessableEntity
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListUsersByTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersByTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImageURL
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UploadImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON405      *MethodNotAllowed
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCurrentUserInvitationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []Invitation `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r ListCurrentUserInvitationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCurrentUserInvitationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentUserMembershipsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []Membership `json:"items"`
		Metadata ListMetadata `json:"metadata"`
	}
	JSON401 *RequiresAuthentication
	JSON403 *Forbidden
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r GetCurrentUserMembershipsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentUserMembershipsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// HealthCheckWithResponse request returning *HealthCheckResponse
func (c *ClientWithResponses) HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error) {
	rsp, err := c.HealthCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckResponse(rsp)
}

// ListPluginsWithResponse request returning *ListPluginsResponse
func (c *ClientWithResponses) ListPluginsWithResponse(ctx context.Context, params *ListPluginsParams, reqEditors ...RequestEditorFn) (*ListPluginsResponse, error) {
	rsp, err := c.ListPlugins(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPluginsResponse(rsp)
}

// CreatePluginWithBodyWithResponse request with arbitrary body returning *CreatePluginResponse
func (c *ClientWithResponses) CreatePluginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginResponse, error) {
	rsp, err := c.CreatePluginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginResponse(rsp)
}

func (c *ClientWithResponses) CreatePluginWithResponse(ctx context.Context, body CreatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginResponse, error) {
	rsp, err := c.CreatePlugin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginResponse(rsp)
}

// DeletePluginByTeamAndPluginNameWithResponse request returning *DeletePluginByTeamAndPluginNameResponse
func (c *ClientWithResponses) DeletePluginByTeamAndPluginNameWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, reqEditors ...RequestEditorFn) (*DeletePluginByTeamAndPluginNameResponse, error) {
	rsp, err := c.DeletePluginByTeamAndPluginName(ctx, teamName, pluginName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePluginByTeamAndPluginNameResponse(rsp)
}

// GetPluginWithResponse request returning *GetPluginResponse
func (c *ClientWithResponses) GetPluginWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, reqEditors ...RequestEditorFn) (*GetPluginResponse, error) {
	rsp, err := c.GetPlugin(ctx, teamName, pluginName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPluginResponse(rsp)
}

// UpdatePluginWithBodyWithResponse request with arbitrary body returning *UpdatePluginResponse
func (c *ClientWithResponses) UpdatePluginWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePluginResponse, error) {
	rsp, err := c.UpdatePluginWithBody(ctx, teamName, pluginName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePluginResponse(rsp)
}

func (c *ClientWithResponses) UpdatePluginWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, body UpdatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePluginResponse, error) {
	rsp, err := c.UpdatePlugin(ctx, teamName, pluginName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePluginResponse(rsp)
}

// ListPluginVersionsWithResponse request returning *ListPluginVersionsResponse
func (c *ClientWithResponses) ListPluginVersionsWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, params *ListPluginVersionsParams, reqEditors ...RequestEditorFn) (*ListPluginVersionsResponse, error) {
	rsp, err := c.ListPluginVersions(ctx, teamName, pluginName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPluginVersionsResponse(rsp)
}

// GetPluginVersionWithResponse request returning *GetPluginVersionResponse
func (c *ClientWithResponses) GetPluginVersionWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, reqEditors ...RequestEditorFn) (*GetPluginVersionResponse, error) {
	rsp, err := c.GetPluginVersion(ctx, teamName, pluginName, versionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPluginVersionResponse(rsp)
}

// UpdatePluginVersionWithBodyWithResponse request with arbitrary body returning *UpdatePluginVersionResponse
func (c *ClientWithResponses) UpdatePluginVersionWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePluginVersionResponse, error) {
	rsp, err := c.UpdatePluginVersionWithBody(ctx, teamName, pluginName, versionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePluginVersionResponse(rsp)
}

func (c *ClientWithResponses) UpdatePluginVersionWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body UpdatePluginVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePluginVersionResponse, error) {
	rsp, err := c.UpdatePluginVersion(ctx, teamName, pluginName, versionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePluginVersionResponse(rsp)
}

// CreatePluginVersionWithBodyWithResponse request with arbitrary body returning *CreatePluginVersionResponse
func (c *ClientWithResponses) CreatePluginVersionWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginVersionResponse, error) {
	rsp, err := c.CreatePluginVersionWithBody(ctx, teamName, pluginName, versionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginVersionResponse(rsp)
}

func (c *ClientWithResponses) CreatePluginVersionWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body CreatePluginVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginVersionResponse, error) {
	rsp, err := c.CreatePluginVersion(ctx, teamName, pluginName, versionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginVersionResponse(rsp)
}

// DownloadPluginAssetWithResponse request returning *DownloadPluginAssetResponse
func (c *ClientWithResponses) DownloadPluginAssetWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, targetName TargetName, reqEditors ...RequestEditorFn) (*DownloadPluginAssetResponse, error) {
	rsp, err := c.DownloadPluginAsset(ctx, teamName, pluginName, versionName, targetName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadPluginAssetResponse(rsp)
}

// UploadPluginAssetWithResponse request returning *UploadPluginAssetResponse
func (c *ClientWithResponses) UploadPluginAssetWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, targetName TargetName, reqEditors ...RequestEditorFn) (*UploadPluginAssetResponse, error) {
	rsp, err := c.UploadPluginAsset(ctx, teamName, pluginName, versionName, targetName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadPluginAssetResponse(rsp)
}

// DeletePluginVersionDocsWithBodyWithResponse request with arbitrary body returning *DeletePluginVersionDocsResponse
func (c *ClientWithResponses) DeletePluginVersionDocsWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePluginVersionDocsResponse, error) {
	rsp, err := c.DeletePluginVersionDocsWithBody(ctx, teamName, pluginName, versionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePluginVersionDocsResponse(rsp)
}

func (c *ClientWithResponses) DeletePluginVersionDocsWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body DeletePluginVersionDocsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePluginVersionDocsResponse, error) {
	rsp, err := c.DeletePluginVersionDocs(ctx, teamName, pluginName, versionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePluginVersionDocsResponse(rsp)
}

// ListPluginVersionDocsWithResponse request returning *ListPluginVersionDocsResponse
func (c *ClientWithResponses) ListPluginVersionDocsWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, params *ListPluginVersionDocsParams, reqEditors ...RequestEditorFn) (*ListPluginVersionDocsResponse, error) {
	rsp, err := c.ListPluginVersionDocs(ctx, teamName, pluginName, versionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPluginVersionDocsResponse(rsp)
}

// CreatePluginVersionDocsWithBodyWithResponse request with arbitrary body returning *CreatePluginVersionDocsResponse
func (c *ClientWithResponses) CreatePluginVersionDocsWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginVersionDocsResponse, error) {
	rsp, err := c.CreatePluginVersionDocsWithBody(ctx, teamName, pluginName, versionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginVersionDocsResponse(rsp)
}

func (c *ClientWithResponses) CreatePluginVersionDocsWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body CreatePluginVersionDocsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginVersionDocsResponse, error) {
	rsp, err := c.CreatePluginVersionDocs(ctx, teamName, pluginName, versionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginVersionDocsResponse(rsp)
}

// DeletePluginVersionTablesWithBodyWithResponse request with arbitrary body returning *DeletePluginVersionTablesResponse
func (c *ClientWithResponses) DeletePluginVersionTablesWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePluginVersionTablesResponse, error) {
	rsp, err := c.DeletePluginVersionTablesWithBody(ctx, teamName, pluginName, versionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePluginVersionTablesResponse(rsp)
}

func (c *ClientWithResponses) DeletePluginVersionTablesWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body DeletePluginVersionTablesJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePluginVersionTablesResponse, error) {
	rsp, err := c.DeletePluginVersionTables(ctx, teamName, pluginName, versionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePluginVersionTablesResponse(rsp)
}

// ListPluginVersionTablesWithResponse request returning *ListPluginVersionTablesResponse
func (c *ClientWithResponses) ListPluginVersionTablesWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, params *ListPluginVersionTablesParams, reqEditors ...RequestEditorFn) (*ListPluginVersionTablesResponse, error) {
	rsp, err := c.ListPluginVersionTables(ctx, teamName, pluginName, versionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPluginVersionTablesResponse(rsp)
}

// CreatePluginVersionTablesWithBodyWithResponse request with arbitrary body returning *CreatePluginVersionTablesResponse
func (c *ClientWithResponses) CreatePluginVersionTablesWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginVersionTablesResponse, error) {
	rsp, err := c.CreatePluginVersionTablesWithBody(ctx, teamName, pluginName, versionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginVersionTablesResponse(rsp)
}

func (c *ClientWithResponses) CreatePluginVersionTablesWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, body CreatePluginVersionTablesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginVersionTablesResponse, error) {
	rsp, err := c.CreatePluginVersionTables(ctx, teamName, pluginName, versionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginVersionTablesResponse(rsp)
}

// GetPluginVersionTableWithResponse request returning *GetPluginVersionTableResponse
func (c *ClientWithResponses) GetPluginVersionTableWithResponse(ctx context.Context, teamName TeamName, pluginName PluginName, versionName VersionName, tableName string, reqEditors ...RequestEditorFn) (*GetPluginVersionTableResponse, error) {
	rsp, err := c.GetPluginVersionTable(ctx, teamName, pluginName, versionName, tableName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPluginVersionTableResponse(rsp)
}

// ListTeamsWithResponse request returning *ListTeamsResponse
func (c *ClientWithResponses) ListTeamsWithResponse(ctx context.Context, params *ListTeamsParams, reqEditors ...RequestEditorFn) (*ListTeamsResponse, error) {
	rsp, err := c.ListTeams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTeamsResponse(rsp)
}

// CreateTeamWithBodyWithResponse request with arbitrary body returning *CreateTeamResponse
func (c *ClientWithResponses) CreateTeamWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTeamResponse, error) {
	rsp, err := c.CreateTeamWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTeamResponse(rsp)
}

func (c *ClientWithResponses) CreateTeamWithResponse(ctx context.Context, body CreateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTeamResponse, error) {
	rsp, err := c.CreateTeam(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTeamResponse(rsp)
}

// GetTeamByNameWithResponse request returning *GetTeamByNameResponse
func (c *ClientWithResponses) GetTeamByNameWithResponse(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*GetTeamByNameResponse, error) {
	rsp, err := c.GetTeamByName(ctx, teamName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamByNameResponse(rsp)
}

// UpdateTeamWithBodyWithResponse request with arbitrary body returning *UpdateTeamResponse
func (c *ClientWithResponses) UpdateTeamWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamResponse, error) {
	rsp, err := c.UpdateTeamWithBody(ctx, teamName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamResponse(rsp)
}

func (c *ClientWithResponses) UpdateTeamWithResponse(ctx context.Context, teamName TeamName, body UpdateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamResponse, error) {
	rsp, err := c.UpdateTeam(ctx, teamName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamResponse(rsp)
}

// ListTeamAPIKeysWithResponse request returning *ListTeamAPIKeysResponse
func (c *ClientWithResponses) ListTeamAPIKeysWithResponse(ctx context.Context, teamName TeamName, params *ListTeamAPIKeysParams, reqEditors ...RequestEditorFn) (*ListTeamAPIKeysResponse, error) {
	rsp, err := c.ListTeamAPIKeys(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTeamAPIKeysResponse(rsp)
}

// CreateTeamAPIKeyWithBodyWithResponse request with arbitrary body returning *CreateTeamAPIKeyResponse
func (c *ClientWithResponses) CreateTeamAPIKeyWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTeamAPIKeyResponse, error) {
	rsp, err := c.CreateTeamAPIKeyWithBody(ctx, teamName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTeamAPIKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateTeamAPIKeyWithResponse(ctx context.Context, teamName TeamName, body CreateTeamAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTeamAPIKeyResponse, error) {
	rsp, err := c.CreateTeamAPIKey(ctx, teamName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTeamAPIKeyResponse(rsp)
}

// DeleteTeamAPIKeyWithResponse request returning *DeleteTeamAPIKeyResponse
func (c *ClientWithResponses) DeleteTeamAPIKeyWithResponse(ctx context.Context, teamName TeamName, aPIKeyName APIKeyName, reqEditors ...RequestEditorFn) (*DeleteTeamAPIKeyResponse, error) {
	rsp, err := c.DeleteTeamAPIKey(ctx, teamName, aPIKeyName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTeamAPIKeyResponse(rsp)
}

// ListTeamInvitationsWithResponse request returning *ListTeamInvitationsResponse
func (c *ClientWithResponses) ListTeamInvitationsWithResponse(ctx context.Context, teamName TeamName, params *ListTeamInvitationsParams, reqEditors ...RequestEditorFn) (*ListTeamInvitationsResponse, error) {
	rsp, err := c.ListTeamInvitations(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTeamInvitationsResponse(rsp)
}

// EmailTeamInvitationWithBodyWithResponse request with arbitrary body returning *EmailTeamInvitationResponse
func (c *ClientWithResponses) EmailTeamInvitationWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmailTeamInvitationResponse, error) {
	rsp, err := c.EmailTeamInvitationWithBody(ctx, teamName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailTeamInvitationResponse(rsp)
}

func (c *ClientWithResponses) EmailTeamInvitationWithResponse(ctx context.Context, teamName TeamName, body EmailTeamInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*EmailTeamInvitationResponse, error) {
	rsp, err := c.EmailTeamInvitation(ctx, teamName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailTeamInvitationResponse(rsp)
}

// AcceptTeamInvitationWithResponse request returning *AcceptTeamInvitationResponse
func (c *ClientWithResponses) AcceptTeamInvitationWithResponse(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*AcceptTeamInvitationResponse, error) {
	rsp, err := c.AcceptTeamInvitation(ctx, teamName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptTeamInvitationResponse(rsp)
}

// CancelTeamInvitationWithResponse request returning *CancelTeamInvitationResponse
func (c *ClientWithResponses) CancelTeamInvitationWithResponse(ctx context.Context, teamName TeamName, email Email, reqEditors ...RequestEditorFn) (*CancelTeamInvitationResponse, error) {
	rsp, err := c.CancelTeamInvitation(ctx, teamName, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelTeamInvitationResponse(rsp)
}

// GetTeamMembershipsWithResponse request returning *GetTeamMembershipsResponse
func (c *ClientWithResponses) GetTeamMembershipsWithResponse(ctx context.Context, teamName TeamName, params *GetTeamMembershipsParams, reqEditors ...RequestEditorFn) (*GetTeamMembershipsResponse, error) {
	rsp, err := c.GetTeamMemberships(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamMembershipsResponse(rsp)
}

// DeletePluginsByTeamWithResponse request returning *DeletePluginsByTeamResponse
func (c *ClientWithResponses) DeletePluginsByTeamWithResponse(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*DeletePluginsByTeamResponse, error) {
	rsp, err := c.DeletePluginsByTeam(ctx, teamName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePluginsByTeamResponse(rsp)
}

// ListPluginsByTeamWithResponse request returning *ListPluginsByTeamResponse
func (c *ClientWithResponses) ListPluginsByTeamWithResponse(ctx context.Context, teamName TeamName, params *ListPluginsByTeamParams, reqEditors ...RequestEditorFn) (*ListPluginsByTeamResponse, error) {
	rsp, err := c.ListPluginsByTeam(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPluginsByTeamResponse(rsp)
}

// ListUsersByTeamWithResponse request returning *ListUsersByTeamResponse
func (c *ClientWithResponses) ListUsersByTeamWithResponse(ctx context.Context, teamName TeamName, params *ListUsersByTeamParams, reqEditors ...RequestEditorFn) (*ListUsersByTeamResponse, error) {
	rsp, err := c.ListUsersByTeam(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersByTeamResponse(rsp)
}

// UploadImageWithResponse request returning *UploadImageResponse
func (c *ClientWithResponses) UploadImageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UploadImageResponse, error) {
	rsp, err := c.UploadImage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadImageResponse(rsp)
}

// GetCurrentUserWithResponse request returning *GetCurrentUserResponse
func (c *ClientWithResponses) GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error) {
	rsp, err := c.GetCurrentUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentUserResponse(rsp)
}

// UpdateCurrentUserWithBodyWithResponse request with arbitrary body returning *UpdateCurrentUserResponse
func (c *ClientWithResponses) UpdateCurrentUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCurrentUserResponse, error) {
	rsp, err := c.UpdateCurrentUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCurrentUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateCurrentUserWithResponse(ctx context.Context, body UpdateCurrentUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCurrentUserResponse, error) {
	rsp, err := c.UpdateCurrentUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCurrentUserResponse(rsp)
}

// ListCurrentUserInvitationsWithResponse request returning *ListCurrentUserInvitationsResponse
func (c *ClientWithResponses) ListCurrentUserInvitationsWithResponse(ctx context.Context, params *ListCurrentUserInvitationsParams, reqEditors ...RequestEditorFn) (*ListCurrentUserInvitationsResponse, error) {
	rsp, err := c.ListCurrentUserInvitations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCurrentUserInvitationsResponse(rsp)
}

// GetCurrentUserMembershipsWithResponse request returning *GetCurrentUserMembershipsResponse
func (c *ClientWithResponses) GetCurrentUserMembershipsWithResponse(ctx context.Context, params *GetCurrentUserMembershipsParams, reqEditors ...RequestEditorFn) (*GetCurrentUserMembershipsResponse, error) {
	rsp, err := c.GetCurrentUserMemberships(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentUserMembershipsResponse(rsp)
}

// ParseHealthCheckResponse parses an HTTP response from a HealthCheckWithResponse call
func ParseHealthCheckResponse(rsp *http.Response) (*HealthCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListPluginsResponse parses an HTTP response from a ListPluginsWithResponse call
func ParseListPluginsResponse(rsp *http.Response) (*ListPluginsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPluginsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []Plugin     `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreatePluginResponse parses an HTTP response from a CreatePluginWithResponse call
func ParseCreatePluginResponse(rsp *http.Response) (*CreatePluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Plugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePluginByTeamAndPluginNameResponse parses an HTTP response from a DeletePluginByTeamAndPluginNameWithResponse call
func ParseDeletePluginByTeamAndPluginNameResponse(rsp *http.Response) (*DeletePluginByTeamAndPluginNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePluginByTeamAndPluginNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPluginResponse parses an HTTP response from a GetPluginWithResponse call
func ParseGetPluginResponse(rsp *http.Response) (*GetPluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdatePluginResponse parses an HTTP response from a UpdatePluginWithResponse call
func ParseUpdatePluginResponse(rsp *http.Response) (*UpdatePluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPluginVersionsResponse parses an HTTP response from a ListPluginVersionsWithResponse call
func ParseListPluginVersionsResponse(rsp *http.Response) (*ListPluginVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPluginVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []PluginVersion `json:"items"`
			Metadata ListMetadata    `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPluginVersionResponse parses an HTTP response from a GetPluginVersionWithResponse call
func ParseGetPluginVersionResponse(rsp *http.Response) (*GetPluginVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPluginVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PluginVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdatePluginVersionResponse parses an HTTP response from a UpdatePluginVersionWithResponse call
func ParseUpdatePluginVersionResponse(rsp *http.Response) (*UpdatePluginVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePluginVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PluginVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreatePluginVersionResponse parses an HTTP response from a CreatePluginVersionWithResponse call
func ParseCreatePluginVersionResponse(rsp *http.Response) (*CreatePluginVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePluginVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PluginVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PluginVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDownloadPluginAssetResponse parses an HTTP response from a DownloadPluginAssetWithResponse call
func ParseDownloadPluginAssetResponse(rsp *http.Response) (*DownloadPluginAssetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadPluginAssetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadPluginAssetResponse parses an HTTP response from a UploadPluginAssetWithResponse call
func ParseUploadPluginAssetResponse(rsp *http.Response) (*UploadPluginAssetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadPluginAssetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ReleaseURL
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePluginVersionDocsResponse parses an HTTP response from a DeletePluginVersionDocsWithResponse call
func ParseDeletePluginVersionDocsResponse(rsp *http.Response) (*DeletePluginVersionDocsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePluginVersionDocsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPluginVersionDocsResponse parses an HTTP response from a ListPluginVersionDocsWithResponse call
func ParseListPluginVersionDocsResponse(rsp *http.Response) (*ListPluginVersionDocsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPluginVersionDocsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []PluginDocsPage `json:"items"`
			Metadata ListMetadata     `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreatePluginVersionDocsResponse parses an HTTP response from a CreatePluginVersionDocsWithResponse call
func ParseCreatePluginVersionDocsResponse(rsp *http.Response) (*CreatePluginVersionDocsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePluginVersionDocsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Names *[]PluginDocsPageName `json:"names,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePluginVersionTablesResponse parses an HTTP response from a DeletePluginVersionTablesWithResponse call
func ParseDeletePluginVersionTablesResponse(rsp *http.Response) (*DeletePluginVersionTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePluginVersionTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPluginVersionTablesResponse parses an HTTP response from a ListPluginVersionTablesWithResponse call
func ParseListPluginVersionTablesResponse(rsp *http.Response) (*ListPluginVersionTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPluginVersionTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []PluginTable `json:"items"`
			Metadata ListMetadata  `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreatePluginVersionTablesResponse parses an HTTP response from a CreatePluginVersionTablesWithResponse call
func ParseCreatePluginVersionTablesResponse(rsp *http.Response) (*CreatePluginVersionTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePluginVersionTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Names *[]PluginTableName `json:"names,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPluginVersionTableResponse parses an HTTP response from a GetPluginVersionTableWithResponse call
func ParseGetPluginVersionTableResponse(rsp *http.Response) (*GetPluginVersionTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPluginVersionTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PluginTableDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTeamsResponse parses an HTTP response from a ListTeamsWithResponse call
func ParseListTeamsResponse(rsp *http.Response) (*ListTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []Team       `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateTeamResponse parses an HTTP response from a CreateTeamWithResponse call
func ParseCreateTeamResponse(rsp *http.Response) (*CreateTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTeamByNameResponse parses an HTTP response from a GetTeamByNameWithResponse call
func ParseGetTeamByNameResponse(rsp *http.Response) (*GetTeamByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateTeamResponse parses an HTTP response from a UpdateTeamWithResponse call
func ParseUpdateTeamResponse(rsp *http.Response) (*UpdateTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTeamAPIKeysResponse parses an HTTP response from a ListTeamAPIKeysWithResponse call
func ParseListTeamAPIKeysResponse(rsp *http.Response) (*ListTeamAPIKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTeamAPIKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []APIKey     `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateTeamAPIKeyResponse parses an HTTP response from a CreateTeamAPIKeyWithResponse call
func ParseCreateTeamAPIKeyResponse(rsp *http.Response) (*CreateTeamAPIKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTeamAPIKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest APIKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTeamAPIKeyResponse parses an HTTP response from a DeleteTeamAPIKeyWithResponse call
func ParseDeleteTeamAPIKeyResponse(rsp *http.Response) (*DeleteTeamAPIKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTeamAPIKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTeamInvitationsResponse parses an HTTP response from a ListTeamInvitationsWithResponse call
func ParseListTeamInvitationsResponse(rsp *http.Response) (*ListTeamInvitationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTeamInvitationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []Invitation `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEmailTeamInvitationResponse parses an HTTP response from a EmailTeamInvitationWithResponse call
func ParseEmailTeamInvitationResponse(rsp *http.Response) (*EmailTeamInvitationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmailTeamInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Invitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAcceptTeamInvitationResponse parses an HTTP response from a AcceptTeamInvitationWithResponse call
func ParseAcceptTeamInvitationResponse(rsp *http.Response) (*AcceptTeamInvitationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptTeamInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Membership
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 303:
		var dest Membership
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON303 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCancelTeamInvitationResponse parses an HTTP response from a CancelTeamInvitationWithResponse call
func ParseCancelTeamInvitationResponse(rsp *http.Response) (*CancelTeamInvitationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelTeamInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTeamMembershipsResponse parses an HTTP response from a GetTeamMembershipsWithResponse call
func ParseGetTeamMembershipsResponse(rsp *http.Response) (*GetTeamMembershipsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamMembershipsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []Membership `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePluginsByTeamResponse parses an HTTP response from a DeletePluginsByTeamWithResponse call
func ParseDeletePluginsByTeamResponse(rsp *http.Response) (*DeletePluginsByTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePluginsByTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPluginsByTeamResponse parses an HTTP response from a ListPluginsByTeamWithResponse call
func ParseListPluginsByTeamResponse(rsp *http.Response) (*ListPluginsByTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPluginsByTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []Plugin     `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListUsersByTeamResponse parses an HTTP response from a ListUsersByTeamWithResponse call
func ParseListUsersByTeamResponse(rsp *http.Response) (*ListUsersByTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersByTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []User       `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadImageResponse parses an HTTP response from a UploadImageWithResponse call
func ParseUploadImageResponse(rsp *http.Response) (*UploadImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImageURL
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCurrentUserResponse parses an HTTP response from a GetCurrentUserWithResponse call
func ParseGetCurrentUserResponse(rsp *http.Response) (*GetCurrentUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateCurrentUserResponse parses an HTTP response from a UpdateCurrentUserWithResponse call
func ParseUpdateCurrentUserResponse(rsp *http.Response) (*UpdateCurrentUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListCurrentUserInvitationsResponse parses an HTTP response from a ListCurrentUserInvitationsWithResponse call
func ParseListCurrentUserInvitationsResponse(rsp *http.Response) (*ListCurrentUserInvitationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCurrentUserInvitationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []Invitation `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCurrentUserMembershipsResponse parses an HTTP response from a GetCurrentUserMembershipsWithResponse call
func ParseGetCurrentUserMembershipsResponse(rsp *http.Response) (*GetCurrentUserMembershipsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentUserMembershipsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []Membership `json:"items"`
			Metadata ListMetadata `json:"metadata"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
