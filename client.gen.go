// Package cloudquery_api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.3 DO NOT EDIT.
package cloudquery_api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/hashicorp/go-retryablehttp"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	retryClient := retryablehttp.NewClient()
	retryClient.Logger = nil
	opts = append([]ClientOption{WithHTTPClient(retryClient.StandardClient())}, opts...)
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// HealthCheck request
	HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAddons request
	ListAddons(ctx context.Context, params *ListAddonsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAddonWithBody request with any body
	CreateAddonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAddon(ctx context.Context, body CreateAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAddonByTeamAndName request
	DeleteAddonByTeamAndName(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAddon request
	GetAddon(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAddonWithBody request with any body
	UpdateAddonWithBody(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAddon(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, body UpdateAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAddonVersions request
	ListAddonVersions(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, params *ListAddonVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAddonVersion request
	GetAddonVersion(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAddonVersionWithBody request with any body
	UpdateAddonVersionWithBody(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAddonVersion(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, body UpdateAddonVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAddonVersionWithBody request with any body
	CreateAddonVersionWithBody(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAddonVersion(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, body CreateAddonVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadAddonAsset request
	DownloadAddonAsset(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, params *DownloadAddonAssetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadAddonAsset request
	UploadAddonAsset(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CQHealthCheck request
	CQHealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPluginNotificationRequests request
	ListPluginNotificationRequests(ctx context.Context, params *ListPluginNotificationRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePluginNotificationRequestWithBody request with any body
	CreatePluginNotificationRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePluginNotificationRequest(ctx context.Context, body CreatePluginNotificationRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePluginNotificationRequest request
	DeletePluginNotificationRequest(ctx context.Context, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPluginNotificationRequest request
	GetPluginNotificationRequest(ctx context.Context, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPlugins request
	ListPlugins(ctx context.Context, params *ListPluginsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePluginWithBody request with any body
	CreatePluginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlugin(ctx context.Context, body CreatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePluginByTeamAndPluginName request
	DeletePluginByTeamAndPluginName(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlugin request
	GetPlugin(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePluginWithBody request with any body
	UpdatePluginWithBody(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePlugin(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, body UpdatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePluginUpcomingPriceChanges request
	DeletePluginUpcomingPriceChanges(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPluginUpcomingPriceChanges request
	ListPluginUpcomingPriceChanges(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePluginUpcomingPriceChangeWithBody request with any body
	CreatePluginUpcomingPriceChangeWithBody(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePluginUpcomingPriceChange(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, body CreatePluginUpcomingPriceChangeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPluginVersions request
	ListPluginVersions(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, params *ListPluginVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPluginVersion request
	GetPluginVersion(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePluginVersionWithBody request with any body
	UpdatePluginVersionWithBody(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePluginVersion(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body UpdatePluginVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePluginVersionWithBody request with any body
	CreatePluginVersionWithBody(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePluginVersion(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body CreatePluginVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadPluginAsset request
	DownloadPluginAsset(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, params *DownloadPluginAssetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadPluginAsset request
	UploadPluginAsset(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePluginVersionDocsWithBody request with any body
	DeletePluginVersionDocsWithBody(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePluginVersionDocs(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body DeletePluginVersionDocsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPluginVersionDocs request
	ListPluginVersionDocs(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, params *ListPluginVersionDocsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplacePluginVersionDocsWithBody request with any body
	ReplacePluginVersionDocsWithBody(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplacePluginVersionDocs(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body ReplacePluginVersionDocsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePluginVersionDocsWithBody request with any body
	CreatePluginVersionDocsWithBody(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePluginVersionDocs(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body CreatePluginVersionDocsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePluginVersionTablesWithBody request with any body
	DeletePluginVersionTablesWithBody(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePluginVersionTables(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body DeletePluginVersionTablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPluginVersionTables request
	ListPluginVersionTables(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, params *ListPluginVersionTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePluginVersionTablesWithBody request with any body
	CreatePluginVersionTablesWithBody(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePluginVersionTables(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body CreatePluginVersionTablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPluginVersionTable request
	GetPluginVersionTable(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, tableName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthRegistryRequest request
	AuthRegistryRequest(ctx context.Context, params *AuthRegistryRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTeams request
	ListTeams(ctx context.Context, params *ListTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTeamWithBody request with any body
	CreateTeamWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTeam(ctx context.Context, body CreateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTeam request
	DeleteTeam(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamByName request
	GetTeamByName(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTeamWithBody request with any body
	UpdateTeamWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTeam(ctx context.Context, teamName TeamName, body UpdateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAddonOrdersByTeam request
	ListAddonOrdersByTeam(ctx context.Context, teamName TeamName, params *ListAddonOrdersByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAddonOrderForTeamWithBody request with any body
	CreateAddonOrderForTeamWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAddonOrderForTeam(ctx context.Context, teamName TeamName, body CreateAddonOrderForTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAddonOrderByTeam request
	GetAddonOrderByTeam(ctx context.Context, teamName TeamName, addonOrderID AddonOrderID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAddonsByTeam request
	DeleteAddonsByTeam(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAddonsByTeam request
	ListAddonsByTeam(ctx context.Context, teamName TeamName, params *ListAddonsByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadAddonAssetByTeam request
	DownloadAddonAssetByTeam(ctx context.Context, teamName TeamName, addonTeam AddonTeam, addonType AddonType, addonName AddonName, versionName VersionName, params *DownloadAddonAssetByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTeamAPIKeys request
	ListTeamAPIKeys(ctx context.Context, teamName TeamName, params *ListTeamAPIKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTeamAPIKeyWithBody request with any body
	CreateTeamAPIKeyWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTeamAPIKey(ctx context.Context, teamName TeamName, body CreateTeamAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTeamAPIKey request
	DeleteTeamAPIKey(ctx context.Context, teamName TeamName, aPIKeyID APIKeyID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTeamImagesWithBody request with any body
	CreateTeamImagesWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTeamImages(ctx context.Context, teamName TeamName, body CreateTeamImagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTeamInvitationWithBody request with any body
	DeleteTeamInvitationWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteTeamInvitation(ctx context.Context, teamName TeamName, body DeleteTeamInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTeamInvitations request
	ListTeamInvitations(ctx context.Context, teamName TeamName, params *ListTeamInvitationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmailTeamInvitationWithBody request with any body
	EmailTeamInvitationWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EmailTeamInvitation(ctx context.Context, teamName TeamName, body EmailTeamInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptTeamInvitationWithBody request with any body
	AcceptTeamInvitationWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AcceptTeamInvitation(ctx context.Context, teamName TeamName, body AcceptTeamInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelTeamInvitation request
	CancelTeamInvitation(ctx context.Context, teamName TeamName, email Email, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInvoicesByTeam request
	ListInvoicesByTeam(ctx context.Context, teamName TeamName, params *ListInvoicesByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetManagedDatabases request
	GetManagedDatabases(ctx context.Context, teamName TeamName, params *GetManagedDatabasesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateManagedDatabaseWithBody request with any body
	CreateManagedDatabaseWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateManagedDatabase(ctx context.Context, teamName TeamName, body CreateManagedDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteManagedDatabase request
	DeleteManagedDatabase(ctx context.Context, teamName TeamName, managedDatabaseID ManagedDatabaseID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetManagedDatabase request
	GetManagedDatabase(ctx context.Context, teamName TeamName, managedDatabaseID ManagedDatabaseID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamMemberships request
	GetTeamMemberships(ctx context.Context, teamName TeamName, params *GetTeamMembershipsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTeamMembership request
	DeleteTeamMembership(ctx context.Context, teamName TeamName, email Email, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePluginsByTeam request
	DeletePluginsByTeam(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPluginsByTeam request
	ListPluginsByTeam(ctx context.Context, teamName TeamName, params *ListPluginsByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadPluginAssetByTeam request
	DownloadPluginAssetByTeam(ctx context.Context, teamName TeamName, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, params *DownloadPluginAssetByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamSpend request
	GetTeamSpend(ctx context.Context, teamName TeamName, params *GetTeamSpendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpendingLimit request
	DeleteSpendingLimit(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpendingLimit request
	GetSpendingLimit(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpendingLimitWithBody request with any body
	CreateSpendingLimitWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpendingLimit(ctx context.Context, teamName TeamName, body CreateSpendingLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSpendingLimitWithBody request with any body
	UpdateSpendingLimitWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSpendingLimit(ctx context.Context, teamName TeamName, body UpdateSpendingLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSubscriptionOrdersByTeam request
	ListSubscriptionOrdersByTeam(ctx context.Context, teamName TeamName, params *ListSubscriptionOrdersByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSubscriptionOrderForTeamWithBody request with any body
	CreateSubscriptionOrderForTeamWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSubscriptionOrderForTeam(ctx context.Context, teamName TeamName, body CreateSubscriptionOrderForTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptionOrderByTeam request
	GetSubscriptionOrderByTeam(ctx context.Context, teamName TeamName, teamSubscriptionOrderID TeamSubscriptionOrderID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSyncDestinations request
	ListSyncDestinations(ctx context.Context, teamName TeamName, params *ListSyncDestinationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSyncDestinationWithBody request with any body
	CreateSyncDestinationWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSyncDestination(ctx context.Context, teamName TeamName, body CreateSyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestSyncDestinationWithBody request with any body
	TestSyncDestinationWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestSyncDestination(ctx context.Context, teamName TeamName, body TestSyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSyncDestination request
	DeleteSyncDestination(ctx context.Context, teamName TeamName, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyncDestination request
	GetSyncDestination(ctx context.Context, teamName TeamName, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSyncDestinationWithBody request with any body
	UpdateSyncDestinationWithBody(ctx context.Context, teamName TeamName, syncDestinationName SyncDestinationName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSyncDestination(ctx context.Context, teamName TeamName, syncDestinationName SyncDestinationName, body UpdateSyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSyncSources request
	ListSyncSources(ctx context.Context, teamName TeamName, params *ListSyncSourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSyncSourceWithBody request with any body
	CreateSyncSourceWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSyncSource(ctx context.Context, teamName TeamName, body CreateSyncSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TestSyncSourceWithBody request with any body
	TestSyncSourceWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TestSyncSource(ctx context.Context, teamName TeamName, body TestSyncSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSyncSource request
	DeleteSyncSource(ctx context.Context, teamName TeamName, syncSourceName SyncSourceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyncSource request
	GetSyncSource(ctx context.Context, teamName TeamName, syncSourceName SyncSourceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSyncSourceWithBody request with any body
	UpdateSyncSourceWithBody(ctx context.Context, teamName TeamName, syncSourceName SyncSourceName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSyncSource(ctx context.Context, teamName TeamName, syncSourceName SyncSourceName, body UpdateSyncSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSyncs request
	ListSyncs(ctx context.Context, teamName TeamName, params *ListSyncsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSyncWithBody request with any body
	CreateSyncWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSync(ctx context.Context, teamName TeamName, body CreateSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyncTestConnection request
	GetSyncTestConnection(ctx context.Context, teamName TeamName, syncTestConnectionId SyncTestConnectionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSyncTestConnectionWithBody request with any body
	UpdateSyncTestConnectionWithBody(ctx context.Context, teamName TeamName, syncTestConnectionId SyncTestConnectionId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSyncTestConnection(ctx context.Context, teamName TeamName, syncTestConnectionId SyncTestConnectionId, body UpdateSyncTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSync request
	DeleteSync(ctx context.Context, teamName TeamName, syncName SyncName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSync request
	GetSync(ctx context.Context, teamName TeamName, syncName SyncName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSyncWithBody request with any body
	UpdateSyncWithBody(ctx context.Context, teamName TeamName, syncName SyncName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSync(ctx context.Context, teamName TeamName, syncName SyncName, body UpdateSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSyncRuns request
	ListSyncRuns(ctx context.Context, teamName TeamName, syncName SyncName, params *ListSyncRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSyncRun request
	CreateSyncRun(ctx context.Context, teamName TeamName, syncName SyncName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyncRun request
	GetSyncRun(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSyncRunWithBody request with any body
	UpdateSyncRunWithBody(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSyncRun(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, body UpdateSyncRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyncRunLogs request
	GetSyncRunLogs(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, params *GetSyncRunLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSyncRunProgressWithBody request with any body
	CreateSyncRunProgressWithBody(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSyncRunProgress(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, body CreateSyncRunProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTeamPluginUsage request
	ListTeamPluginUsage(ctx context.Context, teamName TeamName, params *ListTeamPluginUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IncreaseTeamPluginUsageWithBody request with any body
	IncreaseTeamPluginUsageWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IncreaseTeamPluginUsage(ctx context.Context, teamName TeamName, body IncreaseTeamPluginUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamUsageSummary request
	GetTeamUsageSummary(ctx context.Context, teamName TeamName, params *GetTeamUsageSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupedTeamUsageSummary request
	GetGroupedTeamUsageSummary(ctx context.Context, teamName TeamName, groupBy GetGroupedTeamUsageSummaryParamsGroupBy, params *GetGroupedTeamUsageSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamPluginUsage request
	GetTeamPluginUsage(ctx context.Context, teamName TeamName, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsersByTeam request
	ListUsersByTeam(ctx context.Context, teamName TeamName, params *ListUsersByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadImage request
	UploadImage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentUser request
	GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCurrentUserWithBody request with any body
	UpdateCurrentUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCurrentUser(ctx context.Context, body UpdateCurrentUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCurrentUserInvitations request
	ListCurrentUserInvitations(ctx context.Context, params *ListCurrentUserInvitationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentUserMemberships request
	GetCurrentUserMemberships(ctx context.Context, params *GetCurrentUserMembershipsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAddons(ctx context.Context, params *ListAddonsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAddonsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAddonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAddonRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAddon(ctx context.Context, body CreateAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAddonRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAddonByTeamAndName(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAddonByTeamAndNameRequest(c.Server, teamName, addonType, addonName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAddon(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAddonRequest(c.Server, teamName, addonType, addonName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAddonWithBody(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAddonRequestWithBody(c.Server, teamName, addonType, addonName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAddon(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, body UpdateAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAddonRequest(c.Server, teamName, addonType, addonName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAddonVersions(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, params *ListAddonVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAddonVersionsRequest(c.Server, teamName, addonType, addonName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAddonVersion(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAddonVersionRequest(c.Server, teamName, addonType, addonName, versionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAddonVersionWithBody(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAddonVersionRequestWithBody(c.Server, teamName, addonType, addonName, versionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAddonVersion(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, body UpdateAddonVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAddonVersionRequest(c.Server, teamName, addonType, addonName, versionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAddonVersionWithBody(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAddonVersionRequestWithBody(c.Server, teamName, addonType, addonName, versionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAddonVersion(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, body CreateAddonVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAddonVersionRequest(c.Server, teamName, addonType, addonName, versionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadAddonAsset(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, params *DownloadAddonAssetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadAddonAssetRequest(c.Server, teamName, addonType, addonName, versionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadAddonAsset(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadAddonAssetRequest(c.Server, teamName, addonType, addonName, versionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CQHealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCQHealthCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPluginNotificationRequests(ctx context.Context, params *ListPluginNotificationRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPluginNotificationRequestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginNotificationRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginNotificationRequestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginNotificationRequest(ctx context.Context, body CreatePluginNotificationRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginNotificationRequestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePluginNotificationRequest(ctx context.Context, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePluginNotificationRequestRequest(c.Server, pluginTeam, pluginKind, pluginName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPluginNotificationRequest(ctx context.Context, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPluginNotificationRequestRequest(c.Server, pluginTeam, pluginKind, pluginName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPlugins(ctx context.Context, params *ListPluginsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPluginsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlugin(ctx context.Context, body CreatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePluginByTeamAndPluginName(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePluginByTeamAndPluginNameRequest(c.Server, teamName, pluginKind, pluginName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlugin(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPluginRequest(c.Server, teamName, pluginKind, pluginName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePluginWithBody(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePluginRequestWithBody(c.Server, teamName, pluginKind, pluginName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlugin(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, body UpdatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePluginRequest(c.Server, teamName, pluginKind, pluginName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePluginUpcomingPriceChanges(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePluginUpcomingPriceChangesRequest(c.Server, teamName, pluginKind, pluginName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPluginUpcomingPriceChanges(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPluginUpcomingPriceChangesRequest(c.Server, teamName, pluginKind, pluginName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginUpcomingPriceChangeWithBody(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginUpcomingPriceChangeRequestWithBody(c.Server, teamName, pluginKind, pluginName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginUpcomingPriceChange(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, body CreatePluginUpcomingPriceChangeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginUpcomingPriceChangeRequest(c.Server, teamName, pluginKind, pluginName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPluginVersions(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, params *ListPluginVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPluginVersionsRequest(c.Server, teamName, pluginKind, pluginName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPluginVersion(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPluginVersionRequest(c.Server, teamName, pluginKind, pluginName, versionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePluginVersionWithBody(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePluginVersionRequestWithBody(c.Server, teamName, pluginKind, pluginName, versionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePluginVersion(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body UpdatePluginVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePluginVersionRequest(c.Server, teamName, pluginKind, pluginName, versionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginVersionWithBody(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginVersionRequestWithBody(c.Server, teamName, pluginKind, pluginName, versionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginVersion(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body CreatePluginVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginVersionRequest(c.Server, teamName, pluginKind, pluginName, versionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadPluginAsset(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, params *DownloadPluginAssetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadPluginAssetRequest(c.Server, teamName, pluginKind, pluginName, versionName, targetName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadPluginAsset(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadPluginAssetRequest(c.Server, teamName, pluginKind, pluginName, versionName, targetName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePluginVersionDocsWithBody(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePluginVersionDocsRequestWithBody(c.Server, teamName, pluginKind, pluginName, versionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePluginVersionDocs(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body DeletePluginVersionDocsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePluginVersionDocsRequest(c.Server, teamName, pluginKind, pluginName, versionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPluginVersionDocs(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, params *ListPluginVersionDocsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPluginVersionDocsRequest(c.Server, teamName, pluginKind, pluginName, versionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplacePluginVersionDocsWithBody(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplacePluginVersionDocsRequestWithBody(c.Server, teamName, pluginKind, pluginName, versionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplacePluginVersionDocs(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body ReplacePluginVersionDocsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplacePluginVersionDocsRequest(c.Server, teamName, pluginKind, pluginName, versionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginVersionDocsWithBody(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginVersionDocsRequestWithBody(c.Server, teamName, pluginKind, pluginName, versionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginVersionDocs(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body CreatePluginVersionDocsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginVersionDocsRequest(c.Server, teamName, pluginKind, pluginName, versionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePluginVersionTablesWithBody(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePluginVersionTablesRequestWithBody(c.Server, teamName, pluginKind, pluginName, versionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePluginVersionTables(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body DeletePluginVersionTablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePluginVersionTablesRequest(c.Server, teamName, pluginKind, pluginName, versionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPluginVersionTables(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, params *ListPluginVersionTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPluginVersionTablesRequest(c.Server, teamName, pluginKind, pluginName, versionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginVersionTablesWithBody(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginVersionTablesRequestWithBody(c.Server, teamName, pluginKind, pluginName, versionName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePluginVersionTables(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body CreatePluginVersionTablesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePluginVersionTablesRequest(c.Server, teamName, pluginKind, pluginName, versionName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPluginVersionTable(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, tableName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPluginVersionTableRequest(c.Server, teamName, pluginKind, pluginName, versionName, tableName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthRegistryRequest(ctx context.Context, params *AuthRegistryRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthRegistryRequestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTeams(ctx context.Context, params *ListTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTeamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTeamWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTeamRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTeam(ctx context.Context, body CreateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTeamRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTeam(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTeamRequest(c.Server, teamName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamByName(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamByNameRequest(c.Server, teamName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeamWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamRequestWithBody(c.Server, teamName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeam(ctx context.Context, teamName TeamName, body UpdateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamRequest(c.Server, teamName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAddonOrdersByTeam(ctx context.Context, teamName TeamName, params *ListAddonOrdersByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAddonOrdersByTeamRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAddonOrderForTeamWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAddonOrderForTeamRequestWithBody(c.Server, teamName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAddonOrderForTeam(ctx context.Context, teamName TeamName, body CreateAddonOrderForTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAddonOrderForTeamRequest(c.Server, teamName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAddonOrderByTeam(ctx context.Context, teamName TeamName, addonOrderID AddonOrderID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAddonOrderByTeamRequest(c.Server, teamName, addonOrderID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAddonsByTeam(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAddonsByTeamRequest(c.Server, teamName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAddonsByTeam(ctx context.Context, teamName TeamName, params *ListAddonsByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAddonsByTeamRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadAddonAssetByTeam(ctx context.Context, teamName TeamName, addonTeam AddonTeam, addonType AddonType, addonName AddonName, versionName VersionName, params *DownloadAddonAssetByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadAddonAssetByTeamRequest(c.Server, teamName, addonTeam, addonType, addonName, versionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTeamAPIKeys(ctx context.Context, teamName TeamName, params *ListTeamAPIKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTeamAPIKeysRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTeamAPIKeyWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTeamAPIKeyRequestWithBody(c.Server, teamName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTeamAPIKey(ctx context.Context, teamName TeamName, body CreateTeamAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTeamAPIKeyRequest(c.Server, teamName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTeamAPIKey(ctx context.Context, teamName TeamName, aPIKeyID APIKeyID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTeamAPIKeyRequest(c.Server, teamName, aPIKeyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTeamImagesWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTeamImagesRequestWithBody(c.Server, teamName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTeamImages(ctx context.Context, teamName TeamName, body CreateTeamImagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTeamImagesRequest(c.Server, teamName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTeamInvitationWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTeamInvitationRequestWithBody(c.Server, teamName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTeamInvitation(ctx context.Context, teamName TeamName, body DeleteTeamInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTeamInvitationRequest(c.Server, teamName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTeamInvitations(ctx context.Context, teamName TeamName, params *ListTeamInvitationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTeamInvitationsRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailTeamInvitationWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailTeamInvitationRequestWithBody(c.Server, teamName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmailTeamInvitation(ctx context.Context, teamName TeamName, body EmailTeamInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmailTeamInvitationRequest(c.Server, teamName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptTeamInvitationWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptTeamInvitationRequestWithBody(c.Server, teamName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptTeamInvitation(ctx context.Context, teamName TeamName, body AcceptTeamInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptTeamInvitationRequest(c.Server, teamName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelTeamInvitation(ctx context.Context, teamName TeamName, email Email, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelTeamInvitationRequest(c.Server, teamName, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInvoicesByTeam(ctx context.Context, teamName TeamName, params *ListInvoicesByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInvoicesByTeamRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetManagedDatabases(ctx context.Context, teamName TeamName, params *GetManagedDatabasesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetManagedDatabasesRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManagedDatabaseWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManagedDatabaseRequestWithBody(c.Server, teamName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManagedDatabase(ctx context.Context, teamName TeamName, body CreateManagedDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManagedDatabaseRequest(c.Server, teamName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManagedDatabase(ctx context.Context, teamName TeamName, managedDatabaseID ManagedDatabaseID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManagedDatabaseRequest(c.Server, teamName, managedDatabaseID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetManagedDatabase(ctx context.Context, teamName TeamName, managedDatabaseID ManagedDatabaseID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetManagedDatabaseRequest(c.Server, teamName, managedDatabaseID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamMemberships(ctx context.Context, teamName TeamName, params *GetTeamMembershipsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamMembershipsRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTeamMembership(ctx context.Context, teamName TeamName, email Email, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTeamMembershipRequest(c.Server, teamName, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePluginsByTeam(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePluginsByTeamRequest(c.Server, teamName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPluginsByTeam(ctx context.Context, teamName TeamName, params *ListPluginsByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPluginsByTeamRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadPluginAssetByTeam(ctx context.Context, teamName TeamName, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, params *DownloadPluginAssetByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadPluginAssetByTeamRequest(c.Server, teamName, pluginTeam, pluginKind, pluginName, versionName, targetName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamSpend(ctx context.Context, teamName TeamName, params *GetTeamSpendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamSpendRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpendingLimit(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpendingLimitRequest(c.Server, teamName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpendingLimit(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpendingLimitRequest(c.Server, teamName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpendingLimitWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpendingLimitRequestWithBody(c.Server, teamName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpendingLimit(ctx context.Context, teamName TeamName, body CreateSpendingLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpendingLimitRequest(c.Server, teamName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSpendingLimitWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSpendingLimitRequestWithBody(c.Server, teamName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSpendingLimit(ctx context.Context, teamName TeamName, body UpdateSpendingLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSpendingLimitRequest(c.Server, teamName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSubscriptionOrdersByTeam(ctx context.Context, teamName TeamName, params *ListSubscriptionOrdersByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSubscriptionOrdersByTeamRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubscriptionOrderForTeamWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubscriptionOrderForTeamRequestWithBody(c.Server, teamName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubscriptionOrderForTeam(ctx context.Context, teamName TeamName, body CreateSubscriptionOrderForTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubscriptionOrderForTeamRequest(c.Server, teamName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptionOrderByTeam(ctx context.Context, teamName TeamName, teamSubscriptionOrderID TeamSubscriptionOrderID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionOrderByTeamRequest(c.Server, teamName, teamSubscriptionOrderID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSyncDestinations(ctx context.Context, teamName TeamName, params *ListSyncDestinationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSyncDestinationsRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSyncDestinationWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSyncDestinationRequestWithBody(c.Server, teamName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSyncDestination(ctx context.Context, teamName TeamName, body CreateSyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSyncDestinationRequest(c.Server, teamName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestSyncDestinationWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestSyncDestinationRequestWithBody(c.Server, teamName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestSyncDestination(ctx context.Context, teamName TeamName, body TestSyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestSyncDestinationRequest(c.Server, teamName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSyncDestination(ctx context.Context, teamName TeamName, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSyncDestinationRequest(c.Server, teamName, syncDestinationName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyncDestination(ctx context.Context, teamName TeamName, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncDestinationRequest(c.Server, teamName, syncDestinationName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncDestinationWithBody(ctx context.Context, teamName TeamName, syncDestinationName SyncDestinationName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncDestinationRequestWithBody(c.Server, teamName, syncDestinationName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncDestination(ctx context.Context, teamName TeamName, syncDestinationName SyncDestinationName, body UpdateSyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncDestinationRequest(c.Server, teamName, syncDestinationName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSyncSources(ctx context.Context, teamName TeamName, params *ListSyncSourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSyncSourcesRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSyncSourceWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSyncSourceRequestWithBody(c.Server, teamName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSyncSource(ctx context.Context, teamName TeamName, body CreateSyncSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSyncSourceRequest(c.Server, teamName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestSyncSourceWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestSyncSourceRequestWithBody(c.Server, teamName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TestSyncSource(ctx context.Context, teamName TeamName, body TestSyncSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTestSyncSourceRequest(c.Server, teamName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSyncSource(ctx context.Context, teamName TeamName, syncSourceName SyncSourceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSyncSourceRequest(c.Server, teamName, syncSourceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyncSource(ctx context.Context, teamName TeamName, syncSourceName SyncSourceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncSourceRequest(c.Server, teamName, syncSourceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncSourceWithBody(ctx context.Context, teamName TeamName, syncSourceName SyncSourceName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncSourceRequestWithBody(c.Server, teamName, syncSourceName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncSource(ctx context.Context, teamName TeamName, syncSourceName SyncSourceName, body UpdateSyncSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncSourceRequest(c.Server, teamName, syncSourceName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSyncs(ctx context.Context, teamName TeamName, params *ListSyncsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSyncsRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSyncWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSyncRequestWithBody(c.Server, teamName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSync(ctx context.Context, teamName TeamName, body CreateSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSyncRequest(c.Server, teamName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyncTestConnection(ctx context.Context, teamName TeamName, syncTestConnectionId SyncTestConnectionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncTestConnectionRequest(c.Server, teamName, syncTestConnectionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncTestConnectionWithBody(ctx context.Context, teamName TeamName, syncTestConnectionId SyncTestConnectionId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncTestConnectionRequestWithBody(c.Server, teamName, syncTestConnectionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncTestConnection(ctx context.Context, teamName TeamName, syncTestConnectionId SyncTestConnectionId, body UpdateSyncTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncTestConnectionRequest(c.Server, teamName, syncTestConnectionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSync(ctx context.Context, teamName TeamName, syncName SyncName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSyncRequest(c.Server, teamName, syncName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSync(ctx context.Context, teamName TeamName, syncName SyncName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncRequest(c.Server, teamName, syncName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncWithBody(ctx context.Context, teamName TeamName, syncName SyncName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncRequestWithBody(c.Server, teamName, syncName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSync(ctx context.Context, teamName TeamName, syncName SyncName, body UpdateSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncRequest(c.Server, teamName, syncName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSyncRuns(ctx context.Context, teamName TeamName, syncName SyncName, params *ListSyncRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSyncRunsRequest(c.Server, teamName, syncName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSyncRun(ctx context.Context, teamName TeamName, syncName SyncName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSyncRunRequest(c.Server, teamName, syncName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyncRun(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncRunRequest(c.Server, teamName, syncName, syncRunId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncRunWithBody(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncRunRequestWithBody(c.Server, teamName, syncName, syncRunId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSyncRun(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, body UpdateSyncRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSyncRunRequest(c.Server, teamName, syncName, syncRunId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyncRunLogs(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, params *GetSyncRunLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncRunLogsRequest(c.Server, teamName, syncName, syncRunId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSyncRunProgressWithBody(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSyncRunProgressRequestWithBody(c.Server, teamName, syncName, syncRunId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSyncRunProgress(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, body CreateSyncRunProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSyncRunProgressRequest(c.Server, teamName, syncName, syncRunId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTeamPluginUsage(ctx context.Context, teamName TeamName, params *ListTeamPluginUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTeamPluginUsageRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IncreaseTeamPluginUsageWithBody(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIncreaseTeamPluginUsageRequestWithBody(c.Server, teamName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IncreaseTeamPluginUsage(ctx context.Context, teamName TeamName, body IncreaseTeamPluginUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIncreaseTeamPluginUsageRequest(c.Server, teamName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamUsageSummary(ctx context.Context, teamName TeamName, params *GetTeamUsageSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamUsageSummaryRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupedTeamUsageSummary(ctx context.Context, teamName TeamName, groupBy GetGroupedTeamUsageSummaryParamsGroupBy, params *GetGroupedTeamUsageSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupedTeamUsageSummaryRequest(c.Server, teamName, groupBy, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamPluginUsage(ctx context.Context, teamName TeamName, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamPluginUsageRequest(c.Server, teamName, pluginTeam, pluginKind, pluginName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsersByTeam(ctx context.Context, teamName TeamName, params *ListUsersByTeamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersByTeamRequest(c.Server, teamName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadImage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadImageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCurrentUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCurrentUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCurrentUser(ctx context.Context, body UpdateCurrentUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCurrentUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCurrentUserInvitations(ctx context.Context, params *ListCurrentUserInvitationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCurrentUserInvitationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentUserMemberships(ctx context.Context, params *GetCurrentUserMembershipsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentUserMembershipsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, userID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewHealthCheckRequest generates requests for HealthCheck
func NewHealthCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAddonsRequest generates requests for ListAddons
func NewListAddonsRequest(server string, params *ListAddonsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAddonRequest calls the generic CreateAddon builder with application/json body
func NewCreateAddonRequest(server string, body CreateAddonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAddonRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAddonRequestWithBody generates requests for CreateAddon with any type of body
func NewCreateAddonRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAddonByTeamAndNameRequest generates requests for DeleteAddonByTeamAndName
func NewDeleteAddonByTeamAndNameRequest(server string, teamName TeamName, addonType AddonType, addonName AddonName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "addon_type", runtime.ParamLocationPath, addonType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "addon_name", runtime.ParamLocationPath, addonName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAddonRequest generates requests for GetAddon
func NewGetAddonRequest(server string, teamName TeamName, addonType AddonType, addonName AddonName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "addon_type", runtime.ParamLocationPath, addonType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "addon_name", runtime.ParamLocationPath, addonName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAddonRequest calls the generic UpdateAddon builder with application/json body
func NewUpdateAddonRequest(server string, teamName TeamName, addonType AddonType, addonName AddonName, body UpdateAddonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAddonRequestWithBody(server, teamName, addonType, addonName, "application/json", bodyReader)
}

// NewUpdateAddonRequestWithBody generates requests for UpdateAddon with any type of body
func NewUpdateAddonRequestWithBody(server string, teamName TeamName, addonType AddonType, addonName AddonName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "addon_type", runtime.ParamLocationPath, addonType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "addon_name", runtime.ParamLocationPath, addonName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAddonVersionsRequest generates requests for ListAddonVersions
func NewListAddonVersionsRequest(server string, teamName TeamName, addonType AddonType, addonName AddonName, params *ListAddonVersionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "addon_type", runtime.ParamLocationPath, addonType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "addon_name", runtime.ParamLocationPath, addonName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s/%s/%s/versions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDrafts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_drafts", runtime.ParamLocationQuery, *params.IncludeDrafts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAddonVersionRequest generates requests for GetAddonVersion
func NewGetAddonVersionRequest(server string, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "addon_type", runtime.ParamLocationPath, addonType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "addon_name", runtime.ParamLocationPath, addonName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s/%s/%s/versions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAddonVersionRequest calls the generic UpdateAddonVersion builder with application/json body
func NewUpdateAddonVersionRequest(server string, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, body UpdateAddonVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAddonVersionRequestWithBody(server, teamName, addonType, addonName, versionName, "application/json", bodyReader)
}

// NewUpdateAddonVersionRequestWithBody generates requests for UpdateAddonVersion with any type of body
func NewUpdateAddonVersionRequestWithBody(server string, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "addon_type", runtime.ParamLocationPath, addonType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "addon_name", runtime.ParamLocationPath, addonName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s/%s/%s/versions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAddonVersionRequest calls the generic CreateAddonVersion builder with application/json body
func NewCreateAddonVersionRequest(server string, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, body CreateAddonVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAddonVersionRequestWithBody(server, teamName, addonType, addonName, versionName, "application/json", bodyReader)
}

// NewCreateAddonVersionRequestWithBody generates requests for CreateAddonVersion with any type of body
func NewCreateAddonVersionRequestWithBody(server string, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "addon_type", runtime.ParamLocationPath, addonType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "addon_name", runtime.ParamLocationPath, addonName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s/%s/%s/versions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadAddonAssetRequest generates requests for DownloadAddonAsset
func NewDownloadAddonAssetRequest(server string, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, params *DownloadAddonAssetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "addon_type", runtime.ParamLocationPath, addonType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "addon_name", runtime.ParamLocationPath, addonName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s/%s/%s/versions/%s/assets", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewUploadAddonAssetRequest generates requests for UploadAddonAsset
func NewUploadAddonAssetRequest(server string, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "addon_type", runtime.ParamLocationPath, addonType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "addon_name", runtime.ParamLocationPath, addonName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addons/%s/%s/%s/versions/%s/assets", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCQHealthCheckRequest generates requests for CQHealthCheck
func NewCQHealthCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cq-healthcheck")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPluginNotificationRequestsRequest generates requests for ListPluginNotificationRequests
func NewListPluginNotificationRequestsRequest(server string, params *ListPluginNotificationRequestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugin-notification-requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePluginNotificationRequestRequest calls the generic CreatePluginNotificationRequest builder with application/json body
func NewCreatePluginNotificationRequestRequest(server string, body CreatePluginNotificationRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePluginNotificationRequestRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePluginNotificationRequestRequestWithBody generates requests for CreatePluginNotificationRequest with any type of body
func NewCreatePluginNotificationRequestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugin-notification-requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePluginNotificationRequestRequest generates requests for DeletePluginNotificationRequest
func NewDeletePluginNotificationRequestRequest(server string, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "plugin_team", runtime.ParamLocationPath, pluginTeam)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugin-notification-requests/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPluginNotificationRequestRequest generates requests for GetPluginNotificationRequest
func NewGetPluginNotificationRequestRequest(server string, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "plugin_team", runtime.ParamLocationPath, pluginTeam)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugin-notification-requests/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPluginsRequest generates requests for ListPlugins
func NewListPluginsRequest(server string, params *ListPluginsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePluginRequest calls the generic CreatePlugin builder with application/json body
func NewCreatePluginRequest(server string, body CreatePluginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePluginRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePluginRequestWithBody generates requests for CreatePlugin with any type of body
func NewCreatePluginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePluginByTeamAndPluginNameRequest generates requests for DeletePluginByTeamAndPluginName
func NewDeletePluginByTeamAndPluginNameRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPluginRequest generates requests for GetPlugin
func NewGetPluginRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePluginRequest calls the generic UpdatePlugin builder with application/json body
func NewUpdatePluginRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, body UpdatePluginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePluginRequestWithBody(server, teamName, pluginKind, pluginName, "application/json", bodyReader)
}

// NewUpdatePluginRequestWithBody generates requests for UpdatePlugin with any type of body
func NewUpdatePluginRequestWithBody(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePluginUpcomingPriceChangesRequest generates requests for DeletePluginUpcomingPriceChanges
func NewDeletePluginUpcomingPriceChangesRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/upcoming-price-changes", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPluginUpcomingPriceChangesRequest generates requests for ListPluginUpcomingPriceChanges
func NewListPluginUpcomingPriceChangesRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/upcoming-price-changes", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePluginUpcomingPriceChangeRequest calls the generic CreatePluginUpcomingPriceChange builder with application/json body
func NewCreatePluginUpcomingPriceChangeRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, body CreatePluginUpcomingPriceChangeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePluginUpcomingPriceChangeRequestWithBody(server, teamName, pluginKind, pluginName, "application/json", bodyReader)
}

// NewCreatePluginUpcomingPriceChangeRequestWithBody generates requests for CreatePluginUpcomingPriceChange with any type of body
func NewCreatePluginUpcomingPriceChangeRequestWithBody(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/upcoming-price-changes", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPluginVersionsRequest generates requests for ListPluginVersions
func NewListPluginVersionsRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, params *ListPluginVersionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/versions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDrafts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_drafts", runtime.ParamLocationQuery, *params.IncludeDrafts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludePrereleases != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_prereleases", runtime.ParamLocationQuery, *params.IncludePrereleases); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPluginVersionRequest generates requests for GetPluginVersion
func NewGetPluginVersionRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/versions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePluginVersionRequest calls the generic UpdatePluginVersion builder with application/json body
func NewUpdatePluginVersionRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body UpdatePluginVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePluginVersionRequestWithBody(server, teamName, pluginKind, pluginName, versionName, "application/json", bodyReader)
}

// NewUpdatePluginVersionRequestWithBody generates requests for UpdatePluginVersion with any type of body
func NewUpdatePluginVersionRequestWithBody(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/versions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePluginVersionRequest calls the generic CreatePluginVersion builder with application/json body
func NewCreatePluginVersionRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body CreatePluginVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePluginVersionRequestWithBody(server, teamName, pluginKind, pluginName, versionName, "application/json", bodyReader)
}

// NewCreatePluginVersionRequestWithBody generates requests for CreatePluginVersion with any type of body
func NewCreatePluginVersionRequestWithBody(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/versions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadPluginAssetRequest generates requests for DownloadPluginAsset
func NewDownloadPluginAssetRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, params *DownloadPluginAssetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "target_name", runtime.ParamLocationPath, targetName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/versions/%s/assets/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewUploadPluginAssetRequest generates requests for UploadPluginAsset
func NewUploadPluginAssetRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "target_name", runtime.ParamLocationPath, targetName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/versions/%s/assets/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePluginVersionDocsRequest calls the generic DeletePluginVersionDocs builder with application/json body
func NewDeletePluginVersionDocsRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body DeletePluginVersionDocsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePluginVersionDocsRequestWithBody(server, teamName, pluginKind, pluginName, versionName, "application/json", bodyReader)
}

// NewDeletePluginVersionDocsRequestWithBody generates requests for DeletePluginVersionDocs with any type of body
func NewDeletePluginVersionDocsRequestWithBody(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/versions/%s/docs", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPluginVersionDocsRequest generates requests for ListPluginVersionDocs
func NewListPluginVersionDocsRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, params *ListPluginVersionDocsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/versions/%s/docs", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplacePluginVersionDocsRequest calls the generic ReplacePluginVersionDocs builder with application/json body
func NewReplacePluginVersionDocsRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body ReplacePluginVersionDocsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplacePluginVersionDocsRequestWithBody(server, teamName, pluginKind, pluginName, versionName, "application/json", bodyReader)
}

// NewReplacePluginVersionDocsRequestWithBody generates requests for ReplacePluginVersionDocs with any type of body
func NewReplacePluginVersionDocsRequestWithBody(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/versions/%s/docs", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePluginVersionDocsRequest calls the generic CreatePluginVersionDocs builder with application/json body
func NewCreatePluginVersionDocsRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body CreatePluginVersionDocsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePluginVersionDocsRequestWithBody(server, teamName, pluginKind, pluginName, versionName, "application/json", bodyReader)
}

// NewCreatePluginVersionDocsRequestWithBody generates requests for CreatePluginVersionDocs with any type of body
func NewCreatePluginVersionDocsRequestWithBody(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/versions/%s/docs", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePluginVersionTablesRequest calls the generic DeletePluginVersionTables builder with application/json body
func NewDeletePluginVersionTablesRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body DeletePluginVersionTablesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePluginVersionTablesRequestWithBody(server, teamName, pluginKind, pluginName, versionName, "application/json", bodyReader)
}

// NewDeletePluginVersionTablesRequestWithBody generates requests for DeletePluginVersionTables with any type of body
func NewDeletePluginVersionTablesRequestWithBody(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/versions/%s/tables", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPluginVersionTablesRequest generates requests for ListPluginVersionTables
func NewListPluginVersionTablesRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, params *ListPluginVersionTablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/versions/%s/tables", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePluginVersionTablesRequest calls the generic CreatePluginVersionTables builder with application/json body
func NewCreatePluginVersionTablesRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body CreatePluginVersionTablesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePluginVersionTablesRequestWithBody(server, teamName, pluginKind, pluginName, versionName, "application/json", bodyReader)
}

// NewCreatePluginVersionTablesRequestWithBody generates requests for CreatePluginVersionTables with any type of body
func NewCreatePluginVersionTablesRequestWithBody(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/versions/%s/tables", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPluginVersionTableRequest generates requests for GetPluginVersionTable
func NewGetPluginVersionTableRequest(server string, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, tableName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "table_name", runtime.ParamLocationPath, tableName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/%s/%s/%s/versions/%s/tables/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthRegistryRequestRequest generates requests for AuthRegistryRequest
func NewAuthRegistryRequestRequest(server string, params *AuthRegistryRequestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registry/auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Service != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, *params.Service); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XMetaPluginVersion != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Meta-Plugin-Version", runtime.ParamLocationHeader, *params.XMetaPluginVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Meta-Plugin-Version", headerParam0)
		}

		if params.XMetaUserTeamName != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Meta-User-Team-Name", runtime.ParamLocationHeader, *params.XMetaUserTeamName)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Meta-User-Team-Name", headerParam1)
		}

	}

	return req, nil
}

// NewListTeamsRequest generates requests for ListTeams
func NewListTeamsRequest(server string, params *ListTeamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTeamRequest calls the generic CreateTeam builder with application/json body
func NewCreateTeamRequest(server string, body CreateTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTeamRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTeamRequestWithBody generates requests for CreateTeam with any type of body
func NewCreateTeamRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTeamRequest generates requests for DeleteTeam
func NewDeleteTeamRequest(server string, teamName TeamName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamByNameRequest generates requests for GetTeamByName
func NewGetTeamByNameRequest(server string, teamName TeamName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTeamRequest calls the generic UpdateTeam builder with application/json body
func NewUpdateTeamRequest(server string, teamName TeamName, body UpdateTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTeamRequestWithBody(server, teamName, "application/json", bodyReader)
}

// NewUpdateTeamRequestWithBody generates requests for UpdateTeam with any type of body
func NewUpdateTeamRequestWithBody(server string, teamName TeamName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAddonOrdersByTeamRequest generates requests for ListAddonOrdersByTeam
func NewListAddonOrdersByTeamRequest(server string, teamName TeamName, params *ListAddonOrdersByTeamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/addon-orders", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAddonOrderForTeamRequest calls the generic CreateAddonOrderForTeam builder with application/json body
func NewCreateAddonOrderForTeamRequest(server string, teamName TeamName, body CreateAddonOrderForTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAddonOrderForTeamRequestWithBody(server, teamName, "application/json", bodyReader)
}

// NewCreateAddonOrderForTeamRequestWithBody generates requests for CreateAddonOrderForTeam with any type of body
func NewCreateAddonOrderForTeamRequestWithBody(server string, teamName TeamName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/addon-orders", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAddonOrderByTeamRequest generates requests for GetAddonOrderByTeam
func NewGetAddonOrderByTeamRequest(server string, teamName TeamName, addonOrderID AddonOrderID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "addon_order_id", runtime.ParamLocationPath, addonOrderID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/addon-orders/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAddonsByTeamRequest generates requests for DeleteAddonsByTeam
func NewDeleteAddonsByTeamRequest(server string, teamName TeamName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/addons", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAddonsByTeamRequest generates requests for ListAddonsByTeam
func NewListAddonsByTeamRequest(server string, teamName TeamName, params *ListAddonsByTeamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/addons", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludePrivate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_private", runtime.ParamLocationQuery, *params.IncludePrivate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadAddonAssetByTeamRequest generates requests for DownloadAddonAssetByTeam
func NewDownloadAddonAssetByTeamRequest(server string, teamName TeamName, addonTeam AddonTeam, addonType AddonType, addonName AddonName, versionName VersionName, params *DownloadAddonAssetByTeamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "addon_team", runtime.ParamLocationPath, addonTeam)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "addon_type", runtime.ParamLocationPath, addonType)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "addon_name", runtime.ParamLocationPath, addonName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/addons/%s/%s/%s/versions/%s/assets", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewListTeamAPIKeysRequest generates requests for ListTeamAPIKeys
func NewListTeamAPIKeysRequest(server string, teamName TeamName, params *ListTeamAPIKeysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/apikeys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTeamAPIKeyRequest calls the generic CreateTeamAPIKey builder with application/json body
func NewCreateTeamAPIKeyRequest(server string, teamName TeamName, body CreateTeamAPIKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTeamAPIKeyRequestWithBody(server, teamName, "application/json", bodyReader)
}

// NewCreateTeamAPIKeyRequestWithBody generates requests for CreateTeamAPIKey with any type of body
func NewCreateTeamAPIKeyRequestWithBody(server string, teamName TeamName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/apikeys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTeamAPIKeyRequest generates requests for DeleteTeamAPIKey
func NewDeleteTeamAPIKeyRequest(server string, teamName TeamName, aPIKeyID APIKeyID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "apikey_id", runtime.ParamLocationPath, aPIKeyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/apikeys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTeamImagesRequest calls the generic CreateTeamImages builder with application/json body
func NewCreateTeamImagesRequest(server string, teamName TeamName, body CreateTeamImagesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTeamImagesRequestWithBody(server, teamName, "application/json", bodyReader)
}

// NewCreateTeamImagesRequestWithBody generates requests for CreateTeamImages with any type of body
func NewCreateTeamImagesRequestWithBody(server string, teamName TeamName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTeamInvitationRequest calls the generic DeleteTeamInvitation builder with application/json body
func NewDeleteTeamInvitationRequest(server string, teamName TeamName, body DeleteTeamInvitationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTeamInvitationRequestWithBody(server, teamName, "application/json", bodyReader)
}

// NewDeleteTeamInvitationRequestWithBody generates requests for DeleteTeamInvitation with any type of body
func NewDeleteTeamInvitationRequestWithBody(server string, teamName TeamName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/invitations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTeamInvitationsRequest generates requests for ListTeamInvitations
func NewListTeamInvitationsRequest(server string, teamName TeamName, params *ListTeamInvitationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/invitations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEmailTeamInvitationRequest calls the generic EmailTeamInvitation builder with application/json body
func NewEmailTeamInvitationRequest(server string, teamName TeamName, body EmailTeamInvitationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEmailTeamInvitationRequestWithBody(server, teamName, "application/json", bodyReader)
}

// NewEmailTeamInvitationRequestWithBody generates requests for EmailTeamInvitation with any type of body
func NewEmailTeamInvitationRequestWithBody(server string, teamName TeamName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/invitations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAcceptTeamInvitationRequest calls the generic AcceptTeamInvitation builder with application/json body
func NewAcceptTeamInvitationRequest(server string, teamName TeamName, body AcceptTeamInvitationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAcceptTeamInvitationRequestWithBody(server, teamName, "application/json", bodyReader)
}

// NewAcceptTeamInvitationRequestWithBody generates requests for AcceptTeamInvitation with any type of body
func NewAcceptTeamInvitationRequestWithBody(server string, teamName TeamName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/invitations/accept", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelTeamInvitationRequest generates requests for CancelTeamInvitation
func NewCancelTeamInvitationRequest(server string, teamName TeamName, email Email) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/invitations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInvoicesByTeamRequest generates requests for ListInvoicesByTeam
func NewListInvoicesByTeamRequest(server string, teamName TeamName, params *ListInvoicesByTeamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/invoices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetManagedDatabasesRequest generates requests for GetManagedDatabases
func NewGetManagedDatabasesRequest(server string, teamName TeamName, params *GetManagedDatabasesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/managed-databases", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateManagedDatabaseRequest calls the generic CreateManagedDatabase builder with application/json body
func NewCreateManagedDatabaseRequest(server string, teamName TeamName, body CreateManagedDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManagedDatabaseRequestWithBody(server, teamName, "application/json", bodyReader)
}

// NewCreateManagedDatabaseRequestWithBody generates requests for CreateManagedDatabase with any type of body
func NewCreateManagedDatabaseRequestWithBody(server string, teamName TeamName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/managed-databases", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManagedDatabaseRequest generates requests for DeleteManagedDatabase
func NewDeleteManagedDatabaseRequest(server string, teamName TeamName, managedDatabaseID ManagedDatabaseID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "managed_database_id", runtime.ParamLocationPath, managedDatabaseID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/managed-databases/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetManagedDatabaseRequest generates requests for GetManagedDatabase
func NewGetManagedDatabaseRequest(server string, teamName TeamName, managedDatabaseID ManagedDatabaseID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "managed_database_id", runtime.ParamLocationPath, managedDatabaseID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/managed-databases/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamMembershipsRequest generates requests for GetTeamMemberships
func NewGetTeamMembershipsRequest(server string, teamName TeamName, params *GetTeamMembershipsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/memberships", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTeamMembershipRequest generates requests for DeleteTeamMembership
func NewDeleteTeamMembershipRequest(server string, teamName TeamName, email Email) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/memberships/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePluginsByTeamRequest generates requests for DeletePluginsByTeam
func NewDeletePluginsByTeamRequest(server string, teamName TeamName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/plugins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPluginsByTeamRequest generates requests for ListPluginsByTeam
func NewListPluginsByTeamRequest(server string, teamName TeamName, params *ListPluginsByTeamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/plugins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludePrivate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_private", runtime.ParamLocationQuery, *params.IncludePrivate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadPluginAssetByTeamRequest generates requests for DownloadPluginAssetByTeam
func NewDownloadPluginAssetByTeamRequest(server string, teamName TeamName, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, params *DownloadPluginAssetByTeamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_team", runtime.ParamLocationPath, pluginTeam)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "version_name", runtime.ParamLocationPath, versionName)
	if err != nil {
		return nil, err
	}

	var pathParam5 string

	pathParam5, err = runtime.StyleParamWithLocation("simple", false, "target_name", runtime.ParamLocationPath, targetName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/plugins/%s/%s/%s/versions/%s/assets/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4, pathParam5)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewGetTeamSpendRequest generates requests for GetTeamSpend
func NewGetTeamSpendRequest(server string, teamName TeamName, params *GetTeamSpendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/spend", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSpendingLimitRequest generates requests for DeleteSpendingLimit
func NewDeleteSpendingLimitRequest(server string, teamName TeamName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/spending-limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpendingLimitRequest generates requests for GetSpendingLimit
func NewGetSpendingLimitRequest(server string, teamName TeamName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/spending-limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpendingLimitRequest calls the generic CreateSpendingLimit builder with application/json body
func NewCreateSpendingLimitRequest(server string, teamName TeamName, body CreateSpendingLimitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpendingLimitRequestWithBody(server, teamName, "application/json", bodyReader)
}

// NewCreateSpendingLimitRequestWithBody generates requests for CreateSpendingLimit with any type of body
func NewCreateSpendingLimitRequestWithBody(server string, teamName TeamName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/spending-limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateSpendingLimitRequest calls the generic UpdateSpendingLimit builder with application/json body
func NewUpdateSpendingLimitRequest(server string, teamName TeamName, body UpdateSpendingLimitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSpendingLimitRequestWithBody(server, teamName, "application/json", bodyReader)
}

// NewUpdateSpendingLimitRequestWithBody generates requests for UpdateSpendingLimit with any type of body
func NewUpdateSpendingLimitRequestWithBody(server string, teamName TeamName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/spending-limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSubscriptionOrdersByTeamRequest generates requests for ListSubscriptionOrdersByTeam
func NewListSubscriptionOrdersByTeamRequest(server string, teamName TeamName, params *ListSubscriptionOrdersByTeamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/subscription-orders", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSubscriptionOrderForTeamRequest calls the generic CreateSubscriptionOrderForTeam builder with application/json body
func NewCreateSubscriptionOrderForTeamRequest(server string, teamName TeamName, body CreateSubscriptionOrderForTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSubscriptionOrderForTeamRequestWithBody(server, teamName, "application/json", bodyReader)
}

// NewCreateSubscriptionOrderForTeamRequestWithBody generates requests for CreateSubscriptionOrderForTeam with any type of body
func NewCreateSubscriptionOrderForTeamRequestWithBody(server string, teamName TeamName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/subscription-orders", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSubscriptionOrderByTeamRequest generates requests for GetSubscriptionOrderByTeam
func NewGetSubscriptionOrderByTeamRequest(server string, teamName TeamName, teamSubscriptionOrderID TeamSubscriptionOrderID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "subscription_order_id", runtime.ParamLocationPath, teamSubscriptionOrderID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/subscription-orders/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSyncDestinationsRequest generates requests for ListSyncDestinations
func NewListSyncDestinationsRequest(server string, teamName TeamName, params *ListSyncDestinationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/sync-destinations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSyncDestinationRequest calls the generic CreateSyncDestination builder with application/json body
func NewCreateSyncDestinationRequest(server string, teamName TeamName, body CreateSyncDestinationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSyncDestinationRequestWithBody(server, teamName, "application/json", bodyReader)
}

// NewCreateSyncDestinationRequestWithBody generates requests for CreateSyncDestination with any type of body
func NewCreateSyncDestinationRequestWithBody(server string, teamName TeamName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/sync-destinations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestSyncDestinationRequest calls the generic TestSyncDestination builder with application/json body
func NewTestSyncDestinationRequest(server string, teamName TeamName, body TestSyncDestinationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestSyncDestinationRequestWithBody(server, teamName, "application/json", bodyReader)
}

// NewTestSyncDestinationRequestWithBody generates requests for TestSyncDestination with any type of body
func NewTestSyncDestinationRequestWithBody(server string, teamName TeamName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/sync-destinations/test", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSyncDestinationRequest generates requests for DeleteSyncDestination
func NewDeleteSyncDestinationRequest(server string, teamName TeamName, syncDestinationName SyncDestinationName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_destination_name", runtime.ParamLocationPath, syncDestinationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/sync-destinations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSyncDestinationRequest generates requests for GetSyncDestination
func NewGetSyncDestinationRequest(server string, teamName TeamName, syncDestinationName SyncDestinationName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_destination_name", runtime.ParamLocationPath, syncDestinationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/sync-destinations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSyncDestinationRequest calls the generic UpdateSyncDestination builder with application/json body
func NewUpdateSyncDestinationRequest(server string, teamName TeamName, syncDestinationName SyncDestinationName, body UpdateSyncDestinationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSyncDestinationRequestWithBody(server, teamName, syncDestinationName, "application/json", bodyReader)
}

// NewUpdateSyncDestinationRequestWithBody generates requests for UpdateSyncDestination with any type of body
func NewUpdateSyncDestinationRequestWithBody(server string, teamName TeamName, syncDestinationName SyncDestinationName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_destination_name", runtime.ParamLocationPath, syncDestinationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/sync-destinations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSyncSourcesRequest generates requests for ListSyncSources
func NewListSyncSourcesRequest(server string, teamName TeamName, params *ListSyncSourcesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/sync-sources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSyncSourceRequest calls the generic CreateSyncSource builder with application/json body
func NewCreateSyncSourceRequest(server string, teamName TeamName, body CreateSyncSourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSyncSourceRequestWithBody(server, teamName, "application/json", bodyReader)
}

// NewCreateSyncSourceRequestWithBody generates requests for CreateSyncSource with any type of body
func NewCreateSyncSourceRequestWithBody(server string, teamName TeamName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/sync-sources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTestSyncSourceRequest calls the generic TestSyncSource builder with application/json body
func NewTestSyncSourceRequest(server string, teamName TeamName, body TestSyncSourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTestSyncSourceRequestWithBody(server, teamName, "application/json", bodyReader)
}

// NewTestSyncSourceRequestWithBody generates requests for TestSyncSource with any type of body
func NewTestSyncSourceRequestWithBody(server string, teamName TeamName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/sync-sources/test", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSyncSourceRequest generates requests for DeleteSyncSource
func NewDeleteSyncSourceRequest(server string, teamName TeamName, syncSourceName SyncSourceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_source_name", runtime.ParamLocationPath, syncSourceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/sync-sources/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSyncSourceRequest generates requests for GetSyncSource
func NewGetSyncSourceRequest(server string, teamName TeamName, syncSourceName SyncSourceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_source_name", runtime.ParamLocationPath, syncSourceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/sync-sources/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSyncSourceRequest calls the generic UpdateSyncSource builder with application/json body
func NewUpdateSyncSourceRequest(server string, teamName TeamName, syncSourceName SyncSourceName, body UpdateSyncSourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSyncSourceRequestWithBody(server, teamName, syncSourceName, "application/json", bodyReader)
}

// NewUpdateSyncSourceRequestWithBody generates requests for UpdateSyncSource with any type of body
func NewUpdateSyncSourceRequestWithBody(server string, teamName TeamName, syncSourceName SyncSourceName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_source_name", runtime.ParamLocationPath, syncSourceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/sync-sources/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSyncsRequest generates requests for ListSyncs
func NewListSyncsRequest(server string, teamName TeamName, params *ListSyncsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/syncs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSyncRequest calls the generic CreateSync builder with application/json body
func NewCreateSyncRequest(server string, teamName TeamName, body CreateSyncJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSyncRequestWithBody(server, teamName, "application/json", bodyReader)
}

// NewCreateSyncRequestWithBody generates requests for CreateSync with any type of body
func NewCreateSyncRequestWithBody(server string, teamName TeamName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/syncs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSyncTestConnectionRequest generates requests for GetSyncTestConnection
func NewGetSyncTestConnectionRequest(server string, teamName TeamName, syncTestConnectionId SyncTestConnectionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_test_connection_id", runtime.ParamLocationPath, syncTestConnectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/syncs/test-connections/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSyncTestConnectionRequest calls the generic UpdateSyncTestConnection builder with application/json body
func NewUpdateSyncTestConnectionRequest(server string, teamName TeamName, syncTestConnectionId SyncTestConnectionId, body UpdateSyncTestConnectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSyncTestConnectionRequestWithBody(server, teamName, syncTestConnectionId, "application/json", bodyReader)
}

// NewUpdateSyncTestConnectionRequestWithBody generates requests for UpdateSyncTestConnection with any type of body
func NewUpdateSyncTestConnectionRequestWithBody(server string, teamName TeamName, syncTestConnectionId SyncTestConnectionId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_test_connection_id", runtime.ParamLocationPath, syncTestConnectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/syncs/test-connections/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSyncRequest generates requests for DeleteSync
func NewDeleteSyncRequest(server string, teamName TeamName, syncName SyncName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/syncs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSyncRequest generates requests for GetSync
func NewGetSyncRequest(server string, teamName TeamName, syncName SyncName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/syncs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSyncRequest calls the generic UpdateSync builder with application/json body
func NewUpdateSyncRequest(server string, teamName TeamName, syncName SyncName, body UpdateSyncJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSyncRequestWithBody(server, teamName, syncName, "application/json", bodyReader)
}

// NewUpdateSyncRequestWithBody generates requests for UpdateSync with any type of body
func NewUpdateSyncRequestWithBody(server string, teamName TeamName, syncName SyncName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/syncs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSyncRunsRequest generates requests for ListSyncRuns
func NewListSyncRunsRequest(server string, teamName TeamName, syncName SyncName, params *ListSyncRunsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/syncs/%s/runs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSyncRunRequest generates requests for CreateSyncRun
func NewCreateSyncRunRequest(server string, teamName TeamName, syncName SyncName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/syncs/%s/runs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSyncRunRequest generates requests for GetSyncRun
func NewGetSyncRunRequest(server string, teamName TeamName, syncName SyncName, syncRunId SyncRunId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sync_run_id", runtime.ParamLocationPath, syncRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/syncs/%s/runs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSyncRunRequest calls the generic UpdateSyncRun builder with application/json body
func NewUpdateSyncRunRequest(server string, teamName TeamName, syncName SyncName, syncRunId SyncRunId, body UpdateSyncRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSyncRunRequestWithBody(server, teamName, syncName, syncRunId, "application/json", bodyReader)
}

// NewUpdateSyncRunRequestWithBody generates requests for UpdateSyncRun with any type of body
func NewUpdateSyncRunRequestWithBody(server string, teamName TeamName, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sync_run_id", runtime.ParamLocationPath, syncRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/syncs/%s/runs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSyncRunLogsRequest generates requests for GetSyncRunLogs
func NewGetSyncRunLogsRequest(server string, teamName TeamName, syncName SyncName, syncRunId SyncRunId, params *GetSyncRunLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sync_run_id", runtime.ParamLocationPath, syncRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/syncs/%s/runs/%s/logs", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewCreateSyncRunProgressRequest calls the generic CreateSyncRunProgress builder with application/json body
func NewCreateSyncRunProgressRequest(server string, teamName TeamName, syncName SyncName, syncRunId SyncRunId, body CreateSyncRunProgressJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSyncRunProgressRequestWithBody(server, teamName, syncName, syncRunId, "application/json", bodyReader)
}

// NewCreateSyncRunProgressRequestWithBody generates requests for CreateSyncRunProgress with any type of body
func NewCreateSyncRunProgressRequestWithBody(server string, teamName TeamName, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sync_name", runtime.ParamLocationPath, syncName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sync_run_id", runtime.ParamLocationPath, syncRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/syncs/%s/runs/%s/progress", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTeamPluginUsageRequest generates requests for ListTeamPluginUsage
func NewListTeamPluginUsageRequest(server string, teamName TeamName, params *ListTeamPluginUsageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/usage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIncreaseTeamPluginUsageRequest calls the generic IncreaseTeamPluginUsage builder with application/json body
func NewIncreaseTeamPluginUsageRequest(server string, teamName TeamName, body IncreaseTeamPluginUsageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIncreaseTeamPluginUsageRequestWithBody(server, teamName, "application/json", bodyReader)
}

// NewIncreaseTeamPluginUsageRequestWithBody generates requests for IncreaseTeamPluginUsage with any type of body
func NewIncreaseTeamPluginUsageRequestWithBody(server string, teamName TeamName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/usage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTeamUsageSummaryRequest generates requests for GetTeamUsageSummary
func NewGetTeamUsageSummaryRequest(server string, teamName TeamName, params *GetTeamUsageSummaryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/usage-summary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Metrics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metrics", runtime.ParamLocationQuery, *params.Metrics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AggregationPeriod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aggregation_period", runtime.ParamLocationQuery, *params.AggregationPeriod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupedTeamUsageSummaryRequest generates requests for GetGroupedTeamUsageSummary
func NewGetGroupedTeamUsageSummaryRequest(server string, teamName TeamName, groupBy GetGroupedTeamUsageSummaryParamsGroupBy, params *GetGroupedTeamUsageSummaryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "group_by", runtime.ParamLocationPath, groupBy)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/usage-summary/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Metrics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metrics", runtime.ParamLocationQuery, *params.Metrics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AggregationPeriod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aggregation_period", runtime.ParamLocationQuery, *params.AggregationPeriod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamPluginUsageRequest generates requests for GetTeamPluginUsage
func NewGetTeamPluginUsageRequest(server string, teamName TeamName, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_team", runtime.ParamLocationPath, pluginTeam)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_kind", runtime.ParamLocationPath, pluginKind)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "plugin_name", runtime.ParamLocationPath, pluginName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/usage/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsersByTeamRequest generates requests for ListUsersByTeam
func NewListUsersByTeamRequest(server string, teamName TeamName, params *ListUsersByTeamParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_name", runtime.ParamLocationPath, teamName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadImageRequest generates requests for UploadImage
func NewUploadImageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upload/image")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentUserRequest generates requests for GetCurrentUser
func NewGetCurrentUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCurrentUserRequest calls the generic UpdateCurrentUser builder with application/json body
func NewUpdateCurrentUserRequest(server string, body UpdateCurrentUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCurrentUserRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateCurrentUserRequestWithBody generates requests for UpdateCurrentUser with any type of body
func NewUpdateCurrentUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCurrentUserInvitationsRequest generates requests for ListCurrentUserInvitations
func NewListCurrentUserInvitationsRequest(server string, params *ListCurrentUserInvitationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/invitations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentUserMembershipsRequest generates requests for GetCurrentUserMemberships
func NewGetCurrentUserMembershipsRequest(server string, params *GetCurrentUserMembershipsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/memberships")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, userID UserID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// HealthCheckWithResponse request
	HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error)

	// ListAddonsWithResponse request
	ListAddonsWithResponse(ctx context.Context, params *ListAddonsParams, reqEditors ...RequestEditorFn) (*ListAddonsResponse, error)

	// CreateAddonWithBodyWithResponse request with any body
	CreateAddonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAddonResponse, error)

	CreateAddonWithResponse(ctx context.Context, body CreateAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAddonResponse, error)

	// DeleteAddonByTeamAndNameWithResponse request
	DeleteAddonByTeamAndNameWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, reqEditors ...RequestEditorFn) (*DeleteAddonByTeamAndNameResponse, error)

	// GetAddonWithResponse request
	GetAddonWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, reqEditors ...RequestEditorFn) (*GetAddonResponse, error)

	// UpdateAddonWithBodyWithResponse request with any body
	UpdateAddonWithBodyWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAddonResponse, error)

	UpdateAddonWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, body UpdateAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAddonResponse, error)

	// ListAddonVersionsWithResponse request
	ListAddonVersionsWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, params *ListAddonVersionsParams, reqEditors ...RequestEditorFn) (*ListAddonVersionsResponse, error)

	// GetAddonVersionWithResponse request
	GetAddonVersionWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, reqEditors ...RequestEditorFn) (*GetAddonVersionResponse, error)

	// UpdateAddonVersionWithBodyWithResponse request with any body
	UpdateAddonVersionWithBodyWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAddonVersionResponse, error)

	UpdateAddonVersionWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, body UpdateAddonVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAddonVersionResponse, error)

	// CreateAddonVersionWithBodyWithResponse request with any body
	CreateAddonVersionWithBodyWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAddonVersionResponse, error)

	CreateAddonVersionWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, body CreateAddonVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAddonVersionResponse, error)

	// DownloadAddonAssetWithResponse request
	DownloadAddonAssetWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, params *DownloadAddonAssetParams, reqEditors ...RequestEditorFn) (*DownloadAddonAssetResponse, error)

	// UploadAddonAssetWithResponse request
	UploadAddonAssetWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, reqEditors ...RequestEditorFn) (*UploadAddonAssetResponse, error)

	// CQHealthCheckWithResponse request
	CQHealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CQHealthCheckResponse, error)

	// ListPluginNotificationRequestsWithResponse request
	ListPluginNotificationRequestsWithResponse(ctx context.Context, params *ListPluginNotificationRequestsParams, reqEditors ...RequestEditorFn) (*ListPluginNotificationRequestsResponse, error)

	// CreatePluginNotificationRequestWithBodyWithResponse request with any body
	CreatePluginNotificationRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginNotificationRequestResponse, error)

	CreatePluginNotificationRequestWithResponse(ctx context.Context, body CreatePluginNotificationRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginNotificationRequestResponse, error)

	// DeletePluginNotificationRequestWithResponse request
	DeletePluginNotificationRequestWithResponse(ctx context.Context, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*DeletePluginNotificationRequestResponse, error)

	// GetPluginNotificationRequestWithResponse request
	GetPluginNotificationRequestWithResponse(ctx context.Context, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*GetPluginNotificationRequestResponse, error)

	// ListPluginsWithResponse request
	ListPluginsWithResponse(ctx context.Context, params *ListPluginsParams, reqEditors ...RequestEditorFn) (*ListPluginsResponse, error)

	// CreatePluginWithBodyWithResponse request with any body
	CreatePluginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginResponse, error)

	CreatePluginWithResponse(ctx context.Context, body CreatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginResponse, error)

	// DeletePluginByTeamAndPluginNameWithResponse request
	DeletePluginByTeamAndPluginNameWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*DeletePluginByTeamAndPluginNameResponse, error)

	// GetPluginWithResponse request
	GetPluginWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*GetPluginResponse, error)

	// UpdatePluginWithBodyWithResponse request with any body
	UpdatePluginWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePluginResponse, error)

	UpdatePluginWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, body UpdatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePluginResponse, error)

	// DeletePluginUpcomingPriceChangesWithResponse request
	DeletePluginUpcomingPriceChangesWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*DeletePluginUpcomingPriceChangesResponse, error)

	// ListPluginUpcomingPriceChangesWithResponse request
	ListPluginUpcomingPriceChangesWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*ListPluginUpcomingPriceChangesResponse, error)

	// CreatePluginUpcomingPriceChangeWithBodyWithResponse request with any body
	CreatePluginUpcomingPriceChangeWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginUpcomingPriceChangeResponse, error)

	CreatePluginUpcomingPriceChangeWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, body CreatePluginUpcomingPriceChangeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginUpcomingPriceChangeResponse, error)

	// ListPluginVersionsWithResponse request
	ListPluginVersionsWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, params *ListPluginVersionsParams, reqEditors ...RequestEditorFn) (*ListPluginVersionsResponse, error)

	// GetPluginVersionWithResponse request
	GetPluginVersionWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, reqEditors ...RequestEditorFn) (*GetPluginVersionResponse, error)

	// UpdatePluginVersionWithBodyWithResponse request with any body
	UpdatePluginVersionWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePluginVersionResponse, error)

	UpdatePluginVersionWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body UpdatePluginVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePluginVersionResponse, error)

	// CreatePluginVersionWithBodyWithResponse request with any body
	CreatePluginVersionWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginVersionResponse, error)

	CreatePluginVersionWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body CreatePluginVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginVersionResponse, error)

	// DownloadPluginAssetWithResponse request
	DownloadPluginAssetWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, params *DownloadPluginAssetParams, reqEditors ...RequestEditorFn) (*DownloadPluginAssetResponse, error)

	// UploadPluginAssetWithResponse request
	UploadPluginAssetWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, reqEditors ...RequestEditorFn) (*UploadPluginAssetResponse, error)

	// DeletePluginVersionDocsWithBodyWithResponse request with any body
	DeletePluginVersionDocsWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePluginVersionDocsResponse, error)

	DeletePluginVersionDocsWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body DeletePluginVersionDocsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePluginVersionDocsResponse, error)

	// ListPluginVersionDocsWithResponse request
	ListPluginVersionDocsWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, params *ListPluginVersionDocsParams, reqEditors ...RequestEditorFn) (*ListPluginVersionDocsResponse, error)

	// ReplacePluginVersionDocsWithBodyWithResponse request with any body
	ReplacePluginVersionDocsWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplacePluginVersionDocsResponse, error)

	ReplacePluginVersionDocsWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body ReplacePluginVersionDocsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplacePluginVersionDocsResponse, error)

	// CreatePluginVersionDocsWithBodyWithResponse request with any body
	CreatePluginVersionDocsWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginVersionDocsResponse, error)

	CreatePluginVersionDocsWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body CreatePluginVersionDocsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginVersionDocsResponse, error)

	// DeletePluginVersionTablesWithBodyWithResponse request with any body
	DeletePluginVersionTablesWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePluginVersionTablesResponse, error)

	DeletePluginVersionTablesWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body DeletePluginVersionTablesJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePluginVersionTablesResponse, error)

	// ListPluginVersionTablesWithResponse request
	ListPluginVersionTablesWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, params *ListPluginVersionTablesParams, reqEditors ...RequestEditorFn) (*ListPluginVersionTablesResponse, error)

	// CreatePluginVersionTablesWithBodyWithResponse request with any body
	CreatePluginVersionTablesWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginVersionTablesResponse, error)

	CreatePluginVersionTablesWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body CreatePluginVersionTablesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginVersionTablesResponse, error)

	// GetPluginVersionTableWithResponse request
	GetPluginVersionTableWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, tableName string, reqEditors ...RequestEditorFn) (*GetPluginVersionTableResponse, error)

	// AuthRegistryRequestWithResponse request
	AuthRegistryRequestWithResponse(ctx context.Context, params *AuthRegistryRequestParams, reqEditors ...RequestEditorFn) (*AuthRegistryRequestResponse, error)

	// ListTeamsWithResponse request
	ListTeamsWithResponse(ctx context.Context, params *ListTeamsParams, reqEditors ...RequestEditorFn) (*ListTeamsResponse, error)

	// CreateTeamWithBodyWithResponse request with any body
	CreateTeamWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTeamResponse, error)

	CreateTeamWithResponse(ctx context.Context, body CreateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTeamResponse, error)

	// DeleteTeamWithResponse request
	DeleteTeamWithResponse(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*DeleteTeamResponse, error)

	// GetTeamByNameWithResponse request
	GetTeamByNameWithResponse(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*GetTeamByNameResponse, error)

	// UpdateTeamWithBodyWithResponse request with any body
	UpdateTeamWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamResponse, error)

	UpdateTeamWithResponse(ctx context.Context, teamName TeamName, body UpdateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamResponse, error)

	// ListAddonOrdersByTeamWithResponse request
	ListAddonOrdersByTeamWithResponse(ctx context.Context, teamName TeamName, params *ListAddonOrdersByTeamParams, reqEditors ...RequestEditorFn) (*ListAddonOrdersByTeamResponse, error)

	// CreateAddonOrderForTeamWithBodyWithResponse request with any body
	CreateAddonOrderForTeamWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAddonOrderForTeamResponse, error)

	CreateAddonOrderForTeamWithResponse(ctx context.Context, teamName TeamName, body CreateAddonOrderForTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAddonOrderForTeamResponse, error)

	// GetAddonOrderByTeamWithResponse request
	GetAddonOrderByTeamWithResponse(ctx context.Context, teamName TeamName, addonOrderID AddonOrderID, reqEditors ...RequestEditorFn) (*GetAddonOrderByTeamResponse, error)

	// DeleteAddonsByTeamWithResponse request
	DeleteAddonsByTeamWithResponse(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*DeleteAddonsByTeamResponse, error)

	// ListAddonsByTeamWithResponse request
	ListAddonsByTeamWithResponse(ctx context.Context, teamName TeamName, params *ListAddonsByTeamParams, reqEditors ...RequestEditorFn) (*ListAddonsByTeamResponse, error)

	// DownloadAddonAssetByTeamWithResponse request
	DownloadAddonAssetByTeamWithResponse(ctx context.Context, teamName TeamName, addonTeam AddonTeam, addonType AddonType, addonName AddonName, versionName VersionName, params *DownloadAddonAssetByTeamParams, reqEditors ...RequestEditorFn) (*DownloadAddonAssetByTeamResponse, error)

	// ListTeamAPIKeysWithResponse request
	ListTeamAPIKeysWithResponse(ctx context.Context, teamName TeamName, params *ListTeamAPIKeysParams, reqEditors ...RequestEditorFn) (*ListTeamAPIKeysResponse, error)

	// CreateTeamAPIKeyWithBodyWithResponse request with any body
	CreateTeamAPIKeyWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTeamAPIKeyResponse, error)

	CreateTeamAPIKeyWithResponse(ctx context.Context, teamName TeamName, body CreateTeamAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTeamAPIKeyResponse, error)

	// DeleteTeamAPIKeyWithResponse request
	DeleteTeamAPIKeyWithResponse(ctx context.Context, teamName TeamName, aPIKeyID APIKeyID, reqEditors ...RequestEditorFn) (*DeleteTeamAPIKeyResponse, error)

	// CreateTeamImagesWithBodyWithResponse request with any body
	CreateTeamImagesWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTeamImagesResponse, error)

	CreateTeamImagesWithResponse(ctx context.Context, teamName TeamName, body CreateTeamImagesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTeamImagesResponse, error)

	// DeleteTeamInvitationWithBodyWithResponse request with any body
	DeleteTeamInvitationWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTeamInvitationResponse, error)

	DeleteTeamInvitationWithResponse(ctx context.Context, teamName TeamName, body DeleteTeamInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTeamInvitationResponse, error)

	// ListTeamInvitationsWithResponse request
	ListTeamInvitationsWithResponse(ctx context.Context, teamName TeamName, params *ListTeamInvitationsParams, reqEditors ...RequestEditorFn) (*ListTeamInvitationsResponse, error)

	// EmailTeamInvitationWithBodyWithResponse request with any body
	EmailTeamInvitationWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmailTeamInvitationResponse, error)

	EmailTeamInvitationWithResponse(ctx context.Context, teamName TeamName, body EmailTeamInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*EmailTeamInvitationResponse, error)

	// AcceptTeamInvitationWithBodyWithResponse request with any body
	AcceptTeamInvitationWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AcceptTeamInvitationResponse, error)

	AcceptTeamInvitationWithResponse(ctx context.Context, teamName TeamName, body AcceptTeamInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*AcceptTeamInvitationResponse, error)

	// CancelTeamInvitationWithResponse request
	CancelTeamInvitationWithResponse(ctx context.Context, teamName TeamName, email Email, reqEditors ...RequestEditorFn) (*CancelTeamInvitationResponse, error)

	// ListInvoicesByTeamWithResponse request
	ListInvoicesByTeamWithResponse(ctx context.Context, teamName TeamName, params *ListInvoicesByTeamParams, reqEditors ...RequestEditorFn) (*ListInvoicesByTeamResponse, error)

	// GetManagedDatabasesWithResponse request
	GetManagedDatabasesWithResponse(ctx context.Context, teamName TeamName, params *GetManagedDatabasesParams, reqEditors ...RequestEditorFn) (*GetManagedDatabasesResponse, error)

	// CreateManagedDatabaseWithBodyWithResponse request with any body
	CreateManagedDatabaseWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManagedDatabaseResponse, error)

	CreateManagedDatabaseWithResponse(ctx context.Context, teamName TeamName, body CreateManagedDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManagedDatabaseResponse, error)

	// DeleteManagedDatabaseWithResponse request
	DeleteManagedDatabaseWithResponse(ctx context.Context, teamName TeamName, managedDatabaseID ManagedDatabaseID, reqEditors ...RequestEditorFn) (*DeleteManagedDatabaseResponse, error)

	// GetManagedDatabaseWithResponse request
	GetManagedDatabaseWithResponse(ctx context.Context, teamName TeamName, managedDatabaseID ManagedDatabaseID, reqEditors ...RequestEditorFn) (*GetManagedDatabaseResponse, error)

	// GetTeamMembershipsWithResponse request
	GetTeamMembershipsWithResponse(ctx context.Context, teamName TeamName, params *GetTeamMembershipsParams, reqEditors ...RequestEditorFn) (*GetTeamMembershipsResponse, error)

	// DeleteTeamMembershipWithResponse request
	DeleteTeamMembershipWithResponse(ctx context.Context, teamName TeamName, email Email, reqEditors ...RequestEditorFn) (*DeleteTeamMembershipResponse, error)

	// DeletePluginsByTeamWithResponse request
	DeletePluginsByTeamWithResponse(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*DeletePluginsByTeamResponse, error)

	// ListPluginsByTeamWithResponse request
	ListPluginsByTeamWithResponse(ctx context.Context, teamName TeamName, params *ListPluginsByTeamParams, reqEditors ...RequestEditorFn) (*ListPluginsByTeamResponse, error)

	// DownloadPluginAssetByTeamWithResponse request
	DownloadPluginAssetByTeamWithResponse(ctx context.Context, teamName TeamName, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, params *DownloadPluginAssetByTeamParams, reqEditors ...RequestEditorFn) (*DownloadPluginAssetByTeamResponse, error)

	// GetTeamSpendWithResponse request
	GetTeamSpendWithResponse(ctx context.Context, teamName TeamName, params *GetTeamSpendParams, reqEditors ...RequestEditorFn) (*GetTeamSpendResponse, error)

	// DeleteSpendingLimitWithResponse request
	DeleteSpendingLimitWithResponse(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*DeleteSpendingLimitResponse, error)

	// GetSpendingLimitWithResponse request
	GetSpendingLimitWithResponse(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*GetSpendingLimitResponse, error)

	// CreateSpendingLimitWithBodyWithResponse request with any body
	CreateSpendingLimitWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpendingLimitResponse, error)

	CreateSpendingLimitWithResponse(ctx context.Context, teamName TeamName, body CreateSpendingLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpendingLimitResponse, error)

	// UpdateSpendingLimitWithBodyWithResponse request with any body
	UpdateSpendingLimitWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSpendingLimitResponse, error)

	UpdateSpendingLimitWithResponse(ctx context.Context, teamName TeamName, body UpdateSpendingLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSpendingLimitResponse, error)

	// ListSubscriptionOrdersByTeamWithResponse request
	ListSubscriptionOrdersByTeamWithResponse(ctx context.Context, teamName TeamName, params *ListSubscriptionOrdersByTeamParams, reqEditors ...RequestEditorFn) (*ListSubscriptionOrdersByTeamResponse, error)

	// CreateSubscriptionOrderForTeamWithBodyWithResponse request with any body
	CreateSubscriptionOrderForTeamWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionOrderForTeamResponse, error)

	CreateSubscriptionOrderForTeamWithResponse(ctx context.Context, teamName TeamName, body CreateSubscriptionOrderForTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubscriptionOrderForTeamResponse, error)

	// GetSubscriptionOrderByTeamWithResponse request
	GetSubscriptionOrderByTeamWithResponse(ctx context.Context, teamName TeamName, teamSubscriptionOrderID TeamSubscriptionOrderID, reqEditors ...RequestEditorFn) (*GetSubscriptionOrderByTeamResponse, error)

	// ListSyncDestinationsWithResponse request
	ListSyncDestinationsWithResponse(ctx context.Context, teamName TeamName, params *ListSyncDestinationsParams, reqEditors ...RequestEditorFn) (*ListSyncDestinationsResponse, error)

	// CreateSyncDestinationWithBodyWithResponse request with any body
	CreateSyncDestinationWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSyncDestinationResponse, error)

	CreateSyncDestinationWithResponse(ctx context.Context, teamName TeamName, body CreateSyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSyncDestinationResponse, error)

	// TestSyncDestinationWithBodyWithResponse request with any body
	TestSyncDestinationWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestSyncDestinationResponse, error)

	TestSyncDestinationWithResponse(ctx context.Context, teamName TeamName, body TestSyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*TestSyncDestinationResponse, error)

	// DeleteSyncDestinationWithResponse request
	DeleteSyncDestinationWithResponse(ctx context.Context, teamName TeamName, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*DeleteSyncDestinationResponse, error)

	// GetSyncDestinationWithResponse request
	GetSyncDestinationWithResponse(ctx context.Context, teamName TeamName, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*GetSyncDestinationResponse, error)

	// UpdateSyncDestinationWithBodyWithResponse request with any body
	UpdateSyncDestinationWithBodyWithResponse(ctx context.Context, teamName TeamName, syncDestinationName SyncDestinationName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncDestinationResponse, error)

	UpdateSyncDestinationWithResponse(ctx context.Context, teamName TeamName, syncDestinationName SyncDestinationName, body UpdateSyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncDestinationResponse, error)

	// ListSyncSourcesWithResponse request
	ListSyncSourcesWithResponse(ctx context.Context, teamName TeamName, params *ListSyncSourcesParams, reqEditors ...RequestEditorFn) (*ListSyncSourcesResponse, error)

	// CreateSyncSourceWithBodyWithResponse request with any body
	CreateSyncSourceWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSyncSourceResponse, error)

	CreateSyncSourceWithResponse(ctx context.Context, teamName TeamName, body CreateSyncSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSyncSourceResponse, error)

	// TestSyncSourceWithBodyWithResponse request with any body
	TestSyncSourceWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestSyncSourceResponse, error)

	TestSyncSourceWithResponse(ctx context.Context, teamName TeamName, body TestSyncSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*TestSyncSourceResponse, error)

	// DeleteSyncSourceWithResponse request
	DeleteSyncSourceWithResponse(ctx context.Context, teamName TeamName, syncSourceName SyncSourceName, reqEditors ...RequestEditorFn) (*DeleteSyncSourceResponse, error)

	// GetSyncSourceWithResponse request
	GetSyncSourceWithResponse(ctx context.Context, teamName TeamName, syncSourceName SyncSourceName, reqEditors ...RequestEditorFn) (*GetSyncSourceResponse, error)

	// UpdateSyncSourceWithBodyWithResponse request with any body
	UpdateSyncSourceWithBodyWithResponse(ctx context.Context, teamName TeamName, syncSourceName SyncSourceName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncSourceResponse, error)

	UpdateSyncSourceWithResponse(ctx context.Context, teamName TeamName, syncSourceName SyncSourceName, body UpdateSyncSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncSourceResponse, error)

	// ListSyncsWithResponse request
	ListSyncsWithResponse(ctx context.Context, teamName TeamName, params *ListSyncsParams, reqEditors ...RequestEditorFn) (*ListSyncsResponse, error)

	// CreateSyncWithBodyWithResponse request with any body
	CreateSyncWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSyncResponse, error)

	CreateSyncWithResponse(ctx context.Context, teamName TeamName, body CreateSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSyncResponse, error)

	// GetSyncTestConnectionWithResponse request
	GetSyncTestConnectionWithResponse(ctx context.Context, teamName TeamName, syncTestConnectionId SyncTestConnectionId, reqEditors ...RequestEditorFn) (*GetSyncTestConnectionResponse, error)

	// UpdateSyncTestConnectionWithBodyWithResponse request with any body
	UpdateSyncTestConnectionWithBodyWithResponse(ctx context.Context, teamName TeamName, syncTestConnectionId SyncTestConnectionId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncTestConnectionResponse, error)

	UpdateSyncTestConnectionWithResponse(ctx context.Context, teamName TeamName, syncTestConnectionId SyncTestConnectionId, body UpdateSyncTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncTestConnectionResponse, error)

	// DeleteSyncWithResponse request
	DeleteSyncWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, reqEditors ...RequestEditorFn) (*DeleteSyncResponse, error)

	// GetSyncWithResponse request
	GetSyncWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, reqEditors ...RequestEditorFn) (*GetSyncResponse, error)

	// UpdateSyncWithBodyWithResponse request with any body
	UpdateSyncWithBodyWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncResponse, error)

	UpdateSyncWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, body UpdateSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncResponse, error)

	// ListSyncRunsWithResponse request
	ListSyncRunsWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, params *ListSyncRunsParams, reqEditors ...RequestEditorFn) (*ListSyncRunsResponse, error)

	// CreateSyncRunWithResponse request
	CreateSyncRunWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, reqEditors ...RequestEditorFn) (*CreateSyncRunResponse, error)

	// GetSyncRunWithResponse request
	GetSyncRunWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, reqEditors ...RequestEditorFn) (*GetSyncRunResponse, error)

	// UpdateSyncRunWithBodyWithResponse request with any body
	UpdateSyncRunWithBodyWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncRunResponse, error)

	UpdateSyncRunWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, body UpdateSyncRunJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncRunResponse, error)

	// GetSyncRunLogsWithResponse request
	GetSyncRunLogsWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, params *GetSyncRunLogsParams, reqEditors ...RequestEditorFn) (*GetSyncRunLogsResponse, error)

	// CreateSyncRunProgressWithBodyWithResponse request with any body
	CreateSyncRunProgressWithBodyWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSyncRunProgressResponse, error)

	CreateSyncRunProgressWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, body CreateSyncRunProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSyncRunProgressResponse, error)

	// ListTeamPluginUsageWithResponse request
	ListTeamPluginUsageWithResponse(ctx context.Context, teamName TeamName, params *ListTeamPluginUsageParams, reqEditors ...RequestEditorFn) (*ListTeamPluginUsageResponse, error)

	// IncreaseTeamPluginUsageWithBodyWithResponse request with any body
	IncreaseTeamPluginUsageWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IncreaseTeamPluginUsageResponse, error)

	IncreaseTeamPluginUsageWithResponse(ctx context.Context, teamName TeamName, body IncreaseTeamPluginUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*IncreaseTeamPluginUsageResponse, error)

	// GetTeamUsageSummaryWithResponse request
	GetTeamUsageSummaryWithResponse(ctx context.Context, teamName TeamName, params *GetTeamUsageSummaryParams, reqEditors ...RequestEditorFn) (*GetTeamUsageSummaryResponse, error)

	// GetGroupedTeamUsageSummaryWithResponse request
	GetGroupedTeamUsageSummaryWithResponse(ctx context.Context, teamName TeamName, groupBy GetGroupedTeamUsageSummaryParamsGroupBy, params *GetGroupedTeamUsageSummaryParams, reqEditors ...RequestEditorFn) (*GetGroupedTeamUsageSummaryResponse, error)

	// GetTeamPluginUsageWithResponse request
	GetTeamPluginUsageWithResponse(ctx context.Context, teamName TeamName, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*GetTeamPluginUsageResponse, error)

	// ListUsersByTeamWithResponse request
	ListUsersByTeamWithResponse(ctx context.Context, teamName TeamName, params *ListUsersByTeamParams, reqEditors ...RequestEditorFn) (*ListUsersByTeamResponse, error)

	// UploadImageWithResponse request
	UploadImageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UploadImageResponse, error)

	// GetCurrentUserWithResponse request
	GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error)

	// UpdateCurrentUserWithBodyWithResponse request with any body
	UpdateCurrentUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCurrentUserResponse, error)

	UpdateCurrentUserWithResponse(ctx context.Context, body UpdateCurrentUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCurrentUserResponse, error)

	// ListCurrentUserInvitationsWithResponse request
	ListCurrentUserInvitationsWithResponse(ctx context.Context, params *ListCurrentUserInvitationsParams, reqEditors ...RequestEditorFn) (*ListCurrentUserInvitationsResponse, error)

	// GetCurrentUserMembershipsWithResponse request
	GetCurrentUserMembershipsWithResponse(ctx context.Context, params *GetCurrentUserMembershipsParams, reqEditors ...RequestEditorFn) (*GetCurrentUserMembershipsResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)
}

type HealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAddonsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAddons200Response
	JSON401      *RequiresAuthentication
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListAddonsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAddonsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAddonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Addon
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateAddonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAddonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAddonByTeamAndNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteAddonByTeamAndNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAddonByTeamAndNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAddonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAddon
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetAddonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAddonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAddonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Addon
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateAddonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAddonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAddonVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAddonVersions200Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListAddonVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAddonVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAddonVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddonVersion
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetAddonVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAddonVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAddonVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddonVersion
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateAddonVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAddonVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAddonVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddonVersion
	JSON201      *AddonVersion
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateAddonVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAddonVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadAddonAssetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddonAsset
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DownloadAddonAssetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadAddonAssetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadAddonAssetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ReleaseURL
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UploadAddonAssetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadAddonAssetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CQHealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CQHealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CQHealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPluginNotificationRequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPluginNotificationRequests200Response
	JSON401      *RequiresAuthentication
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListPluginNotificationRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPluginNotificationRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePluginNotificationRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PluginNotificationRequest
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreatePluginNotificationRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePluginNotificationRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePluginNotificationRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeletePluginNotificationRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePluginNotificationRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPluginNotificationRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPluginNotificationRequests200Response
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetPluginNotificationRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPluginNotificationRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPluginsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPlugins200Response
	JSON401      *RequiresAuthentication
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListPluginsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPluginsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Plugin
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreatePluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePluginByTeamAndPluginNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeletePluginByTeamAndPluginNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePluginByTeamAndPluginNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPlugin
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetPluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePluginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plugin
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdatePluginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePluginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePluginUpcomingPriceChangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeletePluginUpcomingPriceChangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePluginUpcomingPriceChangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPluginUpcomingPriceChangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPluginUpcomingPriceChanges200Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListPluginUpcomingPriceChangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPluginUpcomingPriceChangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePluginUpcomingPriceChangeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PluginPrice
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreatePluginUpcomingPriceChangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePluginUpcomingPriceChangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPluginVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPluginVersions200Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListPluginVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPluginVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPluginVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PluginVersionDetails
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetPluginVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPluginVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePluginVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PluginVersion
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdatePluginVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePluginVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePluginVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PluginVersion
	JSON201      *PluginVersion
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreatePluginVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePluginVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadPluginAssetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PluginAsset
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DownloadPluginAssetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadPluginAssetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadPluginAssetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ReleaseURL
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UploadPluginAssetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadPluginAssetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePluginVersionDocsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeletePluginVersionDocsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePluginVersionDocsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPluginVersionDocsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPluginVersionDocs200Response
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListPluginVersionDocsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPluginVersionDocsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplacePluginVersionDocsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreatePluginVersionDocs201Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ReplacePluginVersionDocsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplacePluginVersionDocsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePluginVersionDocsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreatePluginVersionDocs201Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreatePluginVersionDocsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePluginVersionDocsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePluginVersionTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeletePluginVersionTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePluginVersionTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPluginVersionTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPluginVersionTables200Response
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListPluginVersionTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPluginVersionTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePluginVersionTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreatePluginVersionTables201Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreatePluginVersionTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePluginVersionTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPluginVersionTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PluginTableDetails
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetPluginVersionTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPluginVersionTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthRegistryRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegistryAuthToken
	JSON400      *DockerError
	JSON401      *DockerError
	JSON404      *DockerError
	JSON422      *DockerError
	JSON500      *DockerError
}

// Status returns HTTPResponse.Status
func (r AuthRegistryRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthRegistryRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTeams200Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Team
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Team
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetTeamByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Team
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAddonOrdersByTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAddonOrdersByTeam200Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListAddonOrdersByTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAddonOrdersByTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAddonOrderForTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AddonOrder
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateAddonOrderForTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAddonOrderForTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAddonOrderByTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddonOrder
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetAddonOrderByTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAddonOrderByTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAddonsByTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteAddonsByTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAddonsByTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAddonsByTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAddonsByTeam200Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListAddonsByTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAddonsByTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadAddonAssetByTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddonAsset
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DownloadAddonAssetByTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadAddonAssetByTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTeamAPIKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTeamAPIKeys200Response
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListTeamAPIKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTeamAPIKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTeamAPIKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *APIKey
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateTeamAPIKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTeamAPIKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTeamAPIKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteTeamAPIKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTeamAPIKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTeamImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateTeamImages201Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateTeamImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTeamImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTeamInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteTeamInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTeamInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTeamInvitationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTeamInvitations200Response
	JSON403      *Forbidden
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListTeamInvitationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTeamInvitationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmailTeamInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Invitation
	JSON202      *Invitation
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r EmailTeamInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmailTeamInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptTeamInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MembershipWithTeam
	JSON303      *MembershipWithTeam
	JSON403      *Forbidden
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r AcceptTeamInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptTeamInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelTeamInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CancelTeamInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelTeamInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInvoicesByTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListInvoicesByTeam200Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListInvoicesByTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInvoicesByTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetManagedDatabasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetManagedDatabases200Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetManagedDatabasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetManagedDatabasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManagedDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ManagedDatabase
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *Conflict
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateManagedDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManagedDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManagedDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteManagedDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManagedDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetManagedDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManagedDatabase
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetManagedDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetManagedDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamMembershipsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetTeamMemberships200Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetTeamMembershipsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamMembershipsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTeamMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteTeamMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTeamMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePluginsByTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeletePluginsByTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePluginsByTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPluginsByTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPluginsByTeam200Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListPluginsByTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPluginsByTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadPluginAssetByTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PluginAsset
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DownloadPluginAssetByTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadPluginAssetByTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamSpendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpendSummary
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetTeamSpendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamSpendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpendingLimitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteSpendingLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpendingLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpendingLimitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpendingLimit
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSpendingLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpendingLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpendingLimitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SpendingLimit
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateSpendingLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpendingLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSpendingLimitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpendingLimit
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateSpendingLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSpendingLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSubscriptionOrdersByTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListSubscriptionOrdersByTeam200Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListSubscriptionOrdersByTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSubscriptionOrdersByTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSubscriptionOrderForTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TeamSubscriptionOrder
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateSubscriptionOrderForTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSubscriptionOrderForTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionOrderByTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamSubscriptionOrder
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionOrderByTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionOrderByTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSyncDestinationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListSyncDestinations200Response
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListSyncDestinationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncDestinationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSyncDestinationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SyncDestination
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateSyncDestinationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSyncDestinationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestSyncDestinationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SyncTestConnection
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r TestSyncDestinationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestSyncDestinationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSyncDestinationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteSyncDestinationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSyncDestinationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncDestinationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncDestination
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncDestinationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncDestinationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSyncDestinationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncDestination
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateSyncDestinationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncDestinationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSyncSourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListSyncSources200Response
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListSyncSourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncSourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSyncSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SyncSource
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateSyncSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSyncSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TestSyncSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SyncTestConnection
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r TestSyncSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TestSyncSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSyncSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteSyncSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSyncSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncSource
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSyncSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncSource
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateSyncSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSyncsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListSyncs200Response
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListSyncsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Sync
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateSyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncTestConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncTestConnection
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncTestConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncTestConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSyncTestConnectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncTestConnection
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateSyncTestConnectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncTestConnectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteSyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sync
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sync
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateSyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSyncRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListSyncRuns200Response
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListSyncRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSyncRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SyncRun
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateSyncRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSyncRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncRunDetails
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSyncRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncRun
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateSyncRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncRunLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncRunLogs
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetSyncRunLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncRunLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSyncRunProgressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateSyncRunProgressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSyncRunProgressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTeamPluginUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTeamPluginUsage200Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListTeamPluginUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTeamPluginUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IncreaseTeamPluginUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
	JSON503      *ServiceUnavailable
}

// Status returns HTTPResponse.Status
func (r IncreaseTeamPluginUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IncreaseTeamPluginUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamUsageSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsageSummary
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetTeamUsageSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamUsageSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupedTeamUsageSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsageSummary
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetGroupedTeamUsageSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupedTeamUsageSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamPluginUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsageCurrent
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetTeamPluginUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamPluginUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersByTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListUsersByTeam200Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListUsersByTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersByTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImageURL
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UploadImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON405      *MethodNotAllowed
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UpdateCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCurrentUserInvitationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListCurrentUserInvitations200Response
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListCurrentUserInvitationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCurrentUserInvitationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentUserMembershipsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCurrentUserMemberships200Response
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetCurrentUserMembershipsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentUserMembershipsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *RequiresAuthentication
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// HealthCheckWithResponse request returning *HealthCheckResponse
func (c *ClientWithResponses) HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error) {
	rsp, err := c.HealthCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckResponse(rsp)
}

// ListAddonsWithResponse request returning *ListAddonsResponse
func (c *ClientWithResponses) ListAddonsWithResponse(ctx context.Context, params *ListAddonsParams, reqEditors ...RequestEditorFn) (*ListAddonsResponse, error) {
	rsp, err := c.ListAddons(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAddonsResponse(rsp)
}

// CreateAddonWithBodyWithResponse request with arbitrary body returning *CreateAddonResponse
func (c *ClientWithResponses) CreateAddonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAddonResponse, error) {
	rsp, err := c.CreateAddonWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAddonResponse(rsp)
}

func (c *ClientWithResponses) CreateAddonWithResponse(ctx context.Context, body CreateAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAddonResponse, error) {
	rsp, err := c.CreateAddon(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAddonResponse(rsp)
}

// DeleteAddonByTeamAndNameWithResponse request returning *DeleteAddonByTeamAndNameResponse
func (c *ClientWithResponses) DeleteAddonByTeamAndNameWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, reqEditors ...RequestEditorFn) (*DeleteAddonByTeamAndNameResponse, error) {
	rsp, err := c.DeleteAddonByTeamAndName(ctx, teamName, addonType, addonName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAddonByTeamAndNameResponse(rsp)
}

// GetAddonWithResponse request returning *GetAddonResponse
func (c *ClientWithResponses) GetAddonWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, reqEditors ...RequestEditorFn) (*GetAddonResponse, error) {
	rsp, err := c.GetAddon(ctx, teamName, addonType, addonName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAddonResponse(rsp)
}

// UpdateAddonWithBodyWithResponse request with arbitrary body returning *UpdateAddonResponse
func (c *ClientWithResponses) UpdateAddonWithBodyWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAddonResponse, error) {
	rsp, err := c.UpdateAddonWithBody(ctx, teamName, addonType, addonName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAddonResponse(rsp)
}

func (c *ClientWithResponses) UpdateAddonWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, body UpdateAddonJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAddonResponse, error) {
	rsp, err := c.UpdateAddon(ctx, teamName, addonType, addonName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAddonResponse(rsp)
}

// ListAddonVersionsWithResponse request returning *ListAddonVersionsResponse
func (c *ClientWithResponses) ListAddonVersionsWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, params *ListAddonVersionsParams, reqEditors ...RequestEditorFn) (*ListAddonVersionsResponse, error) {
	rsp, err := c.ListAddonVersions(ctx, teamName, addonType, addonName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAddonVersionsResponse(rsp)
}

// GetAddonVersionWithResponse request returning *GetAddonVersionResponse
func (c *ClientWithResponses) GetAddonVersionWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, reqEditors ...RequestEditorFn) (*GetAddonVersionResponse, error) {
	rsp, err := c.GetAddonVersion(ctx, teamName, addonType, addonName, versionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAddonVersionResponse(rsp)
}

// UpdateAddonVersionWithBodyWithResponse request with arbitrary body returning *UpdateAddonVersionResponse
func (c *ClientWithResponses) UpdateAddonVersionWithBodyWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAddonVersionResponse, error) {
	rsp, err := c.UpdateAddonVersionWithBody(ctx, teamName, addonType, addonName, versionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAddonVersionResponse(rsp)
}

func (c *ClientWithResponses) UpdateAddonVersionWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, body UpdateAddonVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAddonVersionResponse, error) {
	rsp, err := c.UpdateAddonVersion(ctx, teamName, addonType, addonName, versionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAddonVersionResponse(rsp)
}

// CreateAddonVersionWithBodyWithResponse request with arbitrary body returning *CreateAddonVersionResponse
func (c *ClientWithResponses) CreateAddonVersionWithBodyWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAddonVersionResponse, error) {
	rsp, err := c.CreateAddonVersionWithBody(ctx, teamName, addonType, addonName, versionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAddonVersionResponse(rsp)
}

func (c *ClientWithResponses) CreateAddonVersionWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, body CreateAddonVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAddonVersionResponse, error) {
	rsp, err := c.CreateAddonVersion(ctx, teamName, addonType, addonName, versionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAddonVersionResponse(rsp)
}

// DownloadAddonAssetWithResponse request returning *DownloadAddonAssetResponse
func (c *ClientWithResponses) DownloadAddonAssetWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, params *DownloadAddonAssetParams, reqEditors ...RequestEditorFn) (*DownloadAddonAssetResponse, error) {
	rsp, err := c.DownloadAddonAsset(ctx, teamName, addonType, addonName, versionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadAddonAssetResponse(rsp)
}

// UploadAddonAssetWithResponse request returning *UploadAddonAssetResponse
func (c *ClientWithResponses) UploadAddonAssetWithResponse(ctx context.Context, teamName TeamName, addonType AddonType, addonName AddonName, versionName VersionName, reqEditors ...RequestEditorFn) (*UploadAddonAssetResponse, error) {
	rsp, err := c.UploadAddonAsset(ctx, teamName, addonType, addonName, versionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadAddonAssetResponse(rsp)
}

// CQHealthCheckWithResponse request returning *CQHealthCheckResponse
func (c *ClientWithResponses) CQHealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CQHealthCheckResponse, error) {
	rsp, err := c.CQHealthCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCQHealthCheckResponse(rsp)
}

// ListPluginNotificationRequestsWithResponse request returning *ListPluginNotificationRequestsResponse
func (c *ClientWithResponses) ListPluginNotificationRequestsWithResponse(ctx context.Context, params *ListPluginNotificationRequestsParams, reqEditors ...RequestEditorFn) (*ListPluginNotificationRequestsResponse, error) {
	rsp, err := c.ListPluginNotificationRequests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPluginNotificationRequestsResponse(rsp)
}

// CreatePluginNotificationRequestWithBodyWithResponse request with arbitrary body returning *CreatePluginNotificationRequestResponse
func (c *ClientWithResponses) CreatePluginNotificationRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginNotificationRequestResponse, error) {
	rsp, err := c.CreatePluginNotificationRequestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginNotificationRequestResponse(rsp)
}

func (c *ClientWithResponses) CreatePluginNotificationRequestWithResponse(ctx context.Context, body CreatePluginNotificationRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginNotificationRequestResponse, error) {
	rsp, err := c.CreatePluginNotificationRequest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginNotificationRequestResponse(rsp)
}

// DeletePluginNotificationRequestWithResponse request returning *DeletePluginNotificationRequestResponse
func (c *ClientWithResponses) DeletePluginNotificationRequestWithResponse(ctx context.Context, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*DeletePluginNotificationRequestResponse, error) {
	rsp, err := c.DeletePluginNotificationRequest(ctx, pluginTeam, pluginKind, pluginName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePluginNotificationRequestResponse(rsp)
}

// GetPluginNotificationRequestWithResponse request returning *GetPluginNotificationRequestResponse
func (c *ClientWithResponses) GetPluginNotificationRequestWithResponse(ctx context.Context, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*GetPluginNotificationRequestResponse, error) {
	rsp, err := c.GetPluginNotificationRequest(ctx, pluginTeam, pluginKind, pluginName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPluginNotificationRequestResponse(rsp)
}

// ListPluginsWithResponse request returning *ListPluginsResponse
func (c *ClientWithResponses) ListPluginsWithResponse(ctx context.Context, params *ListPluginsParams, reqEditors ...RequestEditorFn) (*ListPluginsResponse, error) {
	rsp, err := c.ListPlugins(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPluginsResponse(rsp)
}

// CreatePluginWithBodyWithResponse request with arbitrary body returning *CreatePluginResponse
func (c *ClientWithResponses) CreatePluginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginResponse, error) {
	rsp, err := c.CreatePluginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginResponse(rsp)
}

func (c *ClientWithResponses) CreatePluginWithResponse(ctx context.Context, body CreatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginResponse, error) {
	rsp, err := c.CreatePlugin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginResponse(rsp)
}

// DeletePluginByTeamAndPluginNameWithResponse request returning *DeletePluginByTeamAndPluginNameResponse
func (c *ClientWithResponses) DeletePluginByTeamAndPluginNameWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*DeletePluginByTeamAndPluginNameResponse, error) {
	rsp, err := c.DeletePluginByTeamAndPluginName(ctx, teamName, pluginKind, pluginName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePluginByTeamAndPluginNameResponse(rsp)
}

// GetPluginWithResponse request returning *GetPluginResponse
func (c *ClientWithResponses) GetPluginWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*GetPluginResponse, error) {
	rsp, err := c.GetPlugin(ctx, teamName, pluginKind, pluginName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPluginResponse(rsp)
}

// UpdatePluginWithBodyWithResponse request with arbitrary body returning *UpdatePluginResponse
func (c *ClientWithResponses) UpdatePluginWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePluginResponse, error) {
	rsp, err := c.UpdatePluginWithBody(ctx, teamName, pluginKind, pluginName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePluginResponse(rsp)
}

func (c *ClientWithResponses) UpdatePluginWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, body UpdatePluginJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePluginResponse, error) {
	rsp, err := c.UpdatePlugin(ctx, teamName, pluginKind, pluginName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePluginResponse(rsp)
}

// DeletePluginUpcomingPriceChangesWithResponse request returning *DeletePluginUpcomingPriceChangesResponse
func (c *ClientWithResponses) DeletePluginUpcomingPriceChangesWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*DeletePluginUpcomingPriceChangesResponse, error) {
	rsp, err := c.DeletePluginUpcomingPriceChanges(ctx, teamName, pluginKind, pluginName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePluginUpcomingPriceChangesResponse(rsp)
}

// ListPluginUpcomingPriceChangesWithResponse request returning *ListPluginUpcomingPriceChangesResponse
func (c *ClientWithResponses) ListPluginUpcomingPriceChangesWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*ListPluginUpcomingPriceChangesResponse, error) {
	rsp, err := c.ListPluginUpcomingPriceChanges(ctx, teamName, pluginKind, pluginName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPluginUpcomingPriceChangesResponse(rsp)
}

// CreatePluginUpcomingPriceChangeWithBodyWithResponse request with arbitrary body returning *CreatePluginUpcomingPriceChangeResponse
func (c *ClientWithResponses) CreatePluginUpcomingPriceChangeWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginUpcomingPriceChangeResponse, error) {
	rsp, err := c.CreatePluginUpcomingPriceChangeWithBody(ctx, teamName, pluginKind, pluginName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginUpcomingPriceChangeResponse(rsp)
}

func (c *ClientWithResponses) CreatePluginUpcomingPriceChangeWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, body CreatePluginUpcomingPriceChangeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginUpcomingPriceChangeResponse, error) {
	rsp, err := c.CreatePluginUpcomingPriceChange(ctx, teamName, pluginKind, pluginName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginUpcomingPriceChangeResponse(rsp)
}

// ListPluginVersionsWithResponse request returning *ListPluginVersionsResponse
func (c *ClientWithResponses) ListPluginVersionsWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, params *ListPluginVersionsParams, reqEditors ...RequestEditorFn) (*ListPluginVersionsResponse, error) {
	rsp, err := c.ListPluginVersions(ctx, teamName, pluginKind, pluginName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPluginVersionsResponse(rsp)
}

// GetPluginVersionWithResponse request returning *GetPluginVersionResponse
func (c *ClientWithResponses) GetPluginVersionWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, reqEditors ...RequestEditorFn) (*GetPluginVersionResponse, error) {
	rsp, err := c.GetPluginVersion(ctx, teamName, pluginKind, pluginName, versionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPluginVersionResponse(rsp)
}

// UpdatePluginVersionWithBodyWithResponse request with arbitrary body returning *UpdatePluginVersionResponse
func (c *ClientWithResponses) UpdatePluginVersionWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePluginVersionResponse, error) {
	rsp, err := c.UpdatePluginVersionWithBody(ctx, teamName, pluginKind, pluginName, versionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePluginVersionResponse(rsp)
}

func (c *ClientWithResponses) UpdatePluginVersionWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body UpdatePluginVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePluginVersionResponse, error) {
	rsp, err := c.UpdatePluginVersion(ctx, teamName, pluginKind, pluginName, versionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePluginVersionResponse(rsp)
}

// CreatePluginVersionWithBodyWithResponse request with arbitrary body returning *CreatePluginVersionResponse
func (c *ClientWithResponses) CreatePluginVersionWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginVersionResponse, error) {
	rsp, err := c.CreatePluginVersionWithBody(ctx, teamName, pluginKind, pluginName, versionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginVersionResponse(rsp)
}

func (c *ClientWithResponses) CreatePluginVersionWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body CreatePluginVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginVersionResponse, error) {
	rsp, err := c.CreatePluginVersion(ctx, teamName, pluginKind, pluginName, versionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginVersionResponse(rsp)
}

// DownloadPluginAssetWithResponse request returning *DownloadPluginAssetResponse
func (c *ClientWithResponses) DownloadPluginAssetWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, params *DownloadPluginAssetParams, reqEditors ...RequestEditorFn) (*DownloadPluginAssetResponse, error) {
	rsp, err := c.DownloadPluginAsset(ctx, teamName, pluginKind, pluginName, versionName, targetName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadPluginAssetResponse(rsp)
}

// UploadPluginAssetWithResponse request returning *UploadPluginAssetResponse
func (c *ClientWithResponses) UploadPluginAssetWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, reqEditors ...RequestEditorFn) (*UploadPluginAssetResponse, error) {
	rsp, err := c.UploadPluginAsset(ctx, teamName, pluginKind, pluginName, versionName, targetName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadPluginAssetResponse(rsp)
}

// DeletePluginVersionDocsWithBodyWithResponse request with arbitrary body returning *DeletePluginVersionDocsResponse
func (c *ClientWithResponses) DeletePluginVersionDocsWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePluginVersionDocsResponse, error) {
	rsp, err := c.DeletePluginVersionDocsWithBody(ctx, teamName, pluginKind, pluginName, versionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePluginVersionDocsResponse(rsp)
}

func (c *ClientWithResponses) DeletePluginVersionDocsWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body DeletePluginVersionDocsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePluginVersionDocsResponse, error) {
	rsp, err := c.DeletePluginVersionDocs(ctx, teamName, pluginKind, pluginName, versionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePluginVersionDocsResponse(rsp)
}

// ListPluginVersionDocsWithResponse request returning *ListPluginVersionDocsResponse
func (c *ClientWithResponses) ListPluginVersionDocsWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, params *ListPluginVersionDocsParams, reqEditors ...RequestEditorFn) (*ListPluginVersionDocsResponse, error) {
	rsp, err := c.ListPluginVersionDocs(ctx, teamName, pluginKind, pluginName, versionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPluginVersionDocsResponse(rsp)
}

// ReplacePluginVersionDocsWithBodyWithResponse request with arbitrary body returning *ReplacePluginVersionDocsResponse
func (c *ClientWithResponses) ReplacePluginVersionDocsWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplacePluginVersionDocsResponse, error) {
	rsp, err := c.ReplacePluginVersionDocsWithBody(ctx, teamName, pluginKind, pluginName, versionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplacePluginVersionDocsResponse(rsp)
}

func (c *ClientWithResponses) ReplacePluginVersionDocsWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body ReplacePluginVersionDocsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplacePluginVersionDocsResponse, error) {
	rsp, err := c.ReplacePluginVersionDocs(ctx, teamName, pluginKind, pluginName, versionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplacePluginVersionDocsResponse(rsp)
}

// CreatePluginVersionDocsWithBodyWithResponse request with arbitrary body returning *CreatePluginVersionDocsResponse
func (c *ClientWithResponses) CreatePluginVersionDocsWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginVersionDocsResponse, error) {
	rsp, err := c.CreatePluginVersionDocsWithBody(ctx, teamName, pluginKind, pluginName, versionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginVersionDocsResponse(rsp)
}

func (c *ClientWithResponses) CreatePluginVersionDocsWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body CreatePluginVersionDocsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginVersionDocsResponse, error) {
	rsp, err := c.CreatePluginVersionDocs(ctx, teamName, pluginKind, pluginName, versionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginVersionDocsResponse(rsp)
}

// DeletePluginVersionTablesWithBodyWithResponse request with arbitrary body returning *DeletePluginVersionTablesResponse
func (c *ClientWithResponses) DeletePluginVersionTablesWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePluginVersionTablesResponse, error) {
	rsp, err := c.DeletePluginVersionTablesWithBody(ctx, teamName, pluginKind, pluginName, versionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePluginVersionTablesResponse(rsp)
}

func (c *ClientWithResponses) DeletePluginVersionTablesWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body DeletePluginVersionTablesJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePluginVersionTablesResponse, error) {
	rsp, err := c.DeletePluginVersionTables(ctx, teamName, pluginKind, pluginName, versionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePluginVersionTablesResponse(rsp)
}

// ListPluginVersionTablesWithResponse request returning *ListPluginVersionTablesResponse
func (c *ClientWithResponses) ListPluginVersionTablesWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, params *ListPluginVersionTablesParams, reqEditors ...RequestEditorFn) (*ListPluginVersionTablesResponse, error) {
	rsp, err := c.ListPluginVersionTables(ctx, teamName, pluginKind, pluginName, versionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPluginVersionTablesResponse(rsp)
}

// CreatePluginVersionTablesWithBodyWithResponse request with arbitrary body returning *CreatePluginVersionTablesResponse
func (c *ClientWithResponses) CreatePluginVersionTablesWithBodyWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePluginVersionTablesResponse, error) {
	rsp, err := c.CreatePluginVersionTablesWithBody(ctx, teamName, pluginKind, pluginName, versionName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginVersionTablesResponse(rsp)
}

func (c *ClientWithResponses) CreatePluginVersionTablesWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, body CreatePluginVersionTablesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePluginVersionTablesResponse, error) {
	rsp, err := c.CreatePluginVersionTables(ctx, teamName, pluginKind, pluginName, versionName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePluginVersionTablesResponse(rsp)
}

// GetPluginVersionTableWithResponse request returning *GetPluginVersionTableResponse
func (c *ClientWithResponses) GetPluginVersionTableWithResponse(ctx context.Context, teamName TeamName, pluginKind PluginKind, pluginName PluginName, versionName VersionName, tableName string, reqEditors ...RequestEditorFn) (*GetPluginVersionTableResponse, error) {
	rsp, err := c.GetPluginVersionTable(ctx, teamName, pluginKind, pluginName, versionName, tableName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPluginVersionTableResponse(rsp)
}

// AuthRegistryRequestWithResponse request returning *AuthRegistryRequestResponse
func (c *ClientWithResponses) AuthRegistryRequestWithResponse(ctx context.Context, params *AuthRegistryRequestParams, reqEditors ...RequestEditorFn) (*AuthRegistryRequestResponse, error) {
	rsp, err := c.AuthRegistryRequest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthRegistryRequestResponse(rsp)
}

// ListTeamsWithResponse request returning *ListTeamsResponse
func (c *ClientWithResponses) ListTeamsWithResponse(ctx context.Context, params *ListTeamsParams, reqEditors ...RequestEditorFn) (*ListTeamsResponse, error) {
	rsp, err := c.ListTeams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTeamsResponse(rsp)
}

// CreateTeamWithBodyWithResponse request with arbitrary body returning *CreateTeamResponse
func (c *ClientWithResponses) CreateTeamWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTeamResponse, error) {
	rsp, err := c.CreateTeamWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTeamResponse(rsp)
}

func (c *ClientWithResponses) CreateTeamWithResponse(ctx context.Context, body CreateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTeamResponse, error) {
	rsp, err := c.CreateTeam(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTeamResponse(rsp)
}

// DeleteTeamWithResponse request returning *DeleteTeamResponse
func (c *ClientWithResponses) DeleteTeamWithResponse(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*DeleteTeamResponse, error) {
	rsp, err := c.DeleteTeam(ctx, teamName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTeamResponse(rsp)
}

// GetTeamByNameWithResponse request returning *GetTeamByNameResponse
func (c *ClientWithResponses) GetTeamByNameWithResponse(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*GetTeamByNameResponse, error) {
	rsp, err := c.GetTeamByName(ctx, teamName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamByNameResponse(rsp)
}

// UpdateTeamWithBodyWithResponse request with arbitrary body returning *UpdateTeamResponse
func (c *ClientWithResponses) UpdateTeamWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamResponse, error) {
	rsp, err := c.UpdateTeamWithBody(ctx, teamName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamResponse(rsp)
}

func (c *ClientWithResponses) UpdateTeamWithResponse(ctx context.Context, teamName TeamName, body UpdateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamResponse, error) {
	rsp, err := c.UpdateTeam(ctx, teamName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamResponse(rsp)
}

// ListAddonOrdersByTeamWithResponse request returning *ListAddonOrdersByTeamResponse
func (c *ClientWithResponses) ListAddonOrdersByTeamWithResponse(ctx context.Context, teamName TeamName, params *ListAddonOrdersByTeamParams, reqEditors ...RequestEditorFn) (*ListAddonOrdersByTeamResponse, error) {
	rsp, err := c.ListAddonOrdersByTeam(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAddonOrdersByTeamResponse(rsp)
}

// CreateAddonOrderForTeamWithBodyWithResponse request with arbitrary body returning *CreateAddonOrderForTeamResponse
func (c *ClientWithResponses) CreateAddonOrderForTeamWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAddonOrderForTeamResponse, error) {
	rsp, err := c.CreateAddonOrderForTeamWithBody(ctx, teamName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAddonOrderForTeamResponse(rsp)
}

func (c *ClientWithResponses) CreateAddonOrderForTeamWithResponse(ctx context.Context, teamName TeamName, body CreateAddonOrderForTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAddonOrderForTeamResponse, error) {
	rsp, err := c.CreateAddonOrderForTeam(ctx, teamName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAddonOrderForTeamResponse(rsp)
}

// GetAddonOrderByTeamWithResponse request returning *GetAddonOrderByTeamResponse
func (c *ClientWithResponses) GetAddonOrderByTeamWithResponse(ctx context.Context, teamName TeamName, addonOrderID AddonOrderID, reqEditors ...RequestEditorFn) (*GetAddonOrderByTeamResponse, error) {
	rsp, err := c.GetAddonOrderByTeam(ctx, teamName, addonOrderID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAddonOrderByTeamResponse(rsp)
}

// DeleteAddonsByTeamWithResponse request returning *DeleteAddonsByTeamResponse
func (c *ClientWithResponses) DeleteAddonsByTeamWithResponse(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*DeleteAddonsByTeamResponse, error) {
	rsp, err := c.DeleteAddonsByTeam(ctx, teamName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAddonsByTeamResponse(rsp)
}

// ListAddonsByTeamWithResponse request returning *ListAddonsByTeamResponse
func (c *ClientWithResponses) ListAddonsByTeamWithResponse(ctx context.Context, teamName TeamName, params *ListAddonsByTeamParams, reqEditors ...RequestEditorFn) (*ListAddonsByTeamResponse, error) {
	rsp, err := c.ListAddonsByTeam(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAddonsByTeamResponse(rsp)
}

// DownloadAddonAssetByTeamWithResponse request returning *DownloadAddonAssetByTeamResponse
func (c *ClientWithResponses) DownloadAddonAssetByTeamWithResponse(ctx context.Context, teamName TeamName, addonTeam AddonTeam, addonType AddonType, addonName AddonName, versionName VersionName, params *DownloadAddonAssetByTeamParams, reqEditors ...RequestEditorFn) (*DownloadAddonAssetByTeamResponse, error) {
	rsp, err := c.DownloadAddonAssetByTeam(ctx, teamName, addonTeam, addonType, addonName, versionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadAddonAssetByTeamResponse(rsp)
}

// ListTeamAPIKeysWithResponse request returning *ListTeamAPIKeysResponse
func (c *ClientWithResponses) ListTeamAPIKeysWithResponse(ctx context.Context, teamName TeamName, params *ListTeamAPIKeysParams, reqEditors ...RequestEditorFn) (*ListTeamAPIKeysResponse, error) {
	rsp, err := c.ListTeamAPIKeys(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTeamAPIKeysResponse(rsp)
}

// CreateTeamAPIKeyWithBodyWithResponse request with arbitrary body returning *CreateTeamAPIKeyResponse
func (c *ClientWithResponses) CreateTeamAPIKeyWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTeamAPIKeyResponse, error) {
	rsp, err := c.CreateTeamAPIKeyWithBody(ctx, teamName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTeamAPIKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateTeamAPIKeyWithResponse(ctx context.Context, teamName TeamName, body CreateTeamAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTeamAPIKeyResponse, error) {
	rsp, err := c.CreateTeamAPIKey(ctx, teamName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTeamAPIKeyResponse(rsp)
}

// DeleteTeamAPIKeyWithResponse request returning *DeleteTeamAPIKeyResponse
func (c *ClientWithResponses) DeleteTeamAPIKeyWithResponse(ctx context.Context, teamName TeamName, aPIKeyID APIKeyID, reqEditors ...RequestEditorFn) (*DeleteTeamAPIKeyResponse, error) {
	rsp, err := c.DeleteTeamAPIKey(ctx, teamName, aPIKeyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTeamAPIKeyResponse(rsp)
}

// CreateTeamImagesWithBodyWithResponse request with arbitrary body returning *CreateTeamImagesResponse
func (c *ClientWithResponses) CreateTeamImagesWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTeamImagesResponse, error) {
	rsp, err := c.CreateTeamImagesWithBody(ctx, teamName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTeamImagesResponse(rsp)
}

func (c *ClientWithResponses) CreateTeamImagesWithResponse(ctx context.Context, teamName TeamName, body CreateTeamImagesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTeamImagesResponse, error) {
	rsp, err := c.CreateTeamImages(ctx, teamName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTeamImagesResponse(rsp)
}

// DeleteTeamInvitationWithBodyWithResponse request with arbitrary body returning *DeleteTeamInvitationResponse
func (c *ClientWithResponses) DeleteTeamInvitationWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTeamInvitationResponse, error) {
	rsp, err := c.DeleteTeamInvitationWithBody(ctx, teamName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTeamInvitationResponse(rsp)
}

func (c *ClientWithResponses) DeleteTeamInvitationWithResponse(ctx context.Context, teamName TeamName, body DeleteTeamInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTeamInvitationResponse, error) {
	rsp, err := c.DeleteTeamInvitation(ctx, teamName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTeamInvitationResponse(rsp)
}

// ListTeamInvitationsWithResponse request returning *ListTeamInvitationsResponse
func (c *ClientWithResponses) ListTeamInvitationsWithResponse(ctx context.Context, teamName TeamName, params *ListTeamInvitationsParams, reqEditors ...RequestEditorFn) (*ListTeamInvitationsResponse, error) {
	rsp, err := c.ListTeamInvitations(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTeamInvitationsResponse(rsp)
}

// EmailTeamInvitationWithBodyWithResponse request with arbitrary body returning *EmailTeamInvitationResponse
func (c *ClientWithResponses) EmailTeamInvitationWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmailTeamInvitationResponse, error) {
	rsp, err := c.EmailTeamInvitationWithBody(ctx, teamName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailTeamInvitationResponse(rsp)
}

func (c *ClientWithResponses) EmailTeamInvitationWithResponse(ctx context.Context, teamName TeamName, body EmailTeamInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*EmailTeamInvitationResponse, error) {
	rsp, err := c.EmailTeamInvitation(ctx, teamName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmailTeamInvitationResponse(rsp)
}

// AcceptTeamInvitationWithBodyWithResponse request with arbitrary body returning *AcceptTeamInvitationResponse
func (c *ClientWithResponses) AcceptTeamInvitationWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AcceptTeamInvitationResponse, error) {
	rsp, err := c.AcceptTeamInvitationWithBody(ctx, teamName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptTeamInvitationResponse(rsp)
}

func (c *ClientWithResponses) AcceptTeamInvitationWithResponse(ctx context.Context, teamName TeamName, body AcceptTeamInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*AcceptTeamInvitationResponse, error) {
	rsp, err := c.AcceptTeamInvitation(ctx, teamName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptTeamInvitationResponse(rsp)
}

// CancelTeamInvitationWithResponse request returning *CancelTeamInvitationResponse
func (c *ClientWithResponses) CancelTeamInvitationWithResponse(ctx context.Context, teamName TeamName, email Email, reqEditors ...RequestEditorFn) (*CancelTeamInvitationResponse, error) {
	rsp, err := c.CancelTeamInvitation(ctx, teamName, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelTeamInvitationResponse(rsp)
}

// ListInvoicesByTeamWithResponse request returning *ListInvoicesByTeamResponse
func (c *ClientWithResponses) ListInvoicesByTeamWithResponse(ctx context.Context, teamName TeamName, params *ListInvoicesByTeamParams, reqEditors ...RequestEditorFn) (*ListInvoicesByTeamResponse, error) {
	rsp, err := c.ListInvoicesByTeam(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInvoicesByTeamResponse(rsp)
}

// GetManagedDatabasesWithResponse request returning *GetManagedDatabasesResponse
func (c *ClientWithResponses) GetManagedDatabasesWithResponse(ctx context.Context, teamName TeamName, params *GetManagedDatabasesParams, reqEditors ...RequestEditorFn) (*GetManagedDatabasesResponse, error) {
	rsp, err := c.GetManagedDatabases(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetManagedDatabasesResponse(rsp)
}

// CreateManagedDatabaseWithBodyWithResponse request with arbitrary body returning *CreateManagedDatabaseResponse
func (c *ClientWithResponses) CreateManagedDatabaseWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManagedDatabaseResponse, error) {
	rsp, err := c.CreateManagedDatabaseWithBody(ctx, teamName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManagedDatabaseResponse(rsp)
}

func (c *ClientWithResponses) CreateManagedDatabaseWithResponse(ctx context.Context, teamName TeamName, body CreateManagedDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManagedDatabaseResponse, error) {
	rsp, err := c.CreateManagedDatabase(ctx, teamName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManagedDatabaseResponse(rsp)
}

// DeleteManagedDatabaseWithResponse request returning *DeleteManagedDatabaseResponse
func (c *ClientWithResponses) DeleteManagedDatabaseWithResponse(ctx context.Context, teamName TeamName, managedDatabaseID ManagedDatabaseID, reqEditors ...RequestEditorFn) (*DeleteManagedDatabaseResponse, error) {
	rsp, err := c.DeleteManagedDatabase(ctx, teamName, managedDatabaseID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManagedDatabaseResponse(rsp)
}

// GetManagedDatabaseWithResponse request returning *GetManagedDatabaseResponse
func (c *ClientWithResponses) GetManagedDatabaseWithResponse(ctx context.Context, teamName TeamName, managedDatabaseID ManagedDatabaseID, reqEditors ...RequestEditorFn) (*GetManagedDatabaseResponse, error) {
	rsp, err := c.GetManagedDatabase(ctx, teamName, managedDatabaseID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetManagedDatabaseResponse(rsp)
}

// GetTeamMembershipsWithResponse request returning *GetTeamMembershipsResponse
func (c *ClientWithResponses) GetTeamMembershipsWithResponse(ctx context.Context, teamName TeamName, params *GetTeamMembershipsParams, reqEditors ...RequestEditorFn) (*GetTeamMembershipsResponse, error) {
	rsp, err := c.GetTeamMemberships(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamMembershipsResponse(rsp)
}

// DeleteTeamMembershipWithResponse request returning *DeleteTeamMembershipResponse
func (c *ClientWithResponses) DeleteTeamMembershipWithResponse(ctx context.Context, teamName TeamName, email Email, reqEditors ...RequestEditorFn) (*DeleteTeamMembershipResponse, error) {
	rsp, err := c.DeleteTeamMembership(ctx, teamName, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTeamMembershipResponse(rsp)
}

// DeletePluginsByTeamWithResponse request returning *DeletePluginsByTeamResponse
func (c *ClientWithResponses) DeletePluginsByTeamWithResponse(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*DeletePluginsByTeamResponse, error) {
	rsp, err := c.DeletePluginsByTeam(ctx, teamName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePluginsByTeamResponse(rsp)
}

// ListPluginsByTeamWithResponse request returning *ListPluginsByTeamResponse
func (c *ClientWithResponses) ListPluginsByTeamWithResponse(ctx context.Context, teamName TeamName, params *ListPluginsByTeamParams, reqEditors ...RequestEditorFn) (*ListPluginsByTeamResponse, error) {
	rsp, err := c.ListPluginsByTeam(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPluginsByTeamResponse(rsp)
}

// DownloadPluginAssetByTeamWithResponse request returning *DownloadPluginAssetByTeamResponse
func (c *ClientWithResponses) DownloadPluginAssetByTeamWithResponse(ctx context.Context, teamName TeamName, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, versionName VersionName, targetName TargetName, params *DownloadPluginAssetByTeamParams, reqEditors ...RequestEditorFn) (*DownloadPluginAssetByTeamResponse, error) {
	rsp, err := c.DownloadPluginAssetByTeam(ctx, teamName, pluginTeam, pluginKind, pluginName, versionName, targetName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadPluginAssetByTeamResponse(rsp)
}

// GetTeamSpendWithResponse request returning *GetTeamSpendResponse
func (c *ClientWithResponses) GetTeamSpendWithResponse(ctx context.Context, teamName TeamName, params *GetTeamSpendParams, reqEditors ...RequestEditorFn) (*GetTeamSpendResponse, error) {
	rsp, err := c.GetTeamSpend(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamSpendResponse(rsp)
}

// DeleteSpendingLimitWithResponse request returning *DeleteSpendingLimitResponse
func (c *ClientWithResponses) DeleteSpendingLimitWithResponse(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*DeleteSpendingLimitResponse, error) {
	rsp, err := c.DeleteSpendingLimit(ctx, teamName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpendingLimitResponse(rsp)
}

// GetSpendingLimitWithResponse request returning *GetSpendingLimitResponse
func (c *ClientWithResponses) GetSpendingLimitWithResponse(ctx context.Context, teamName TeamName, reqEditors ...RequestEditorFn) (*GetSpendingLimitResponse, error) {
	rsp, err := c.GetSpendingLimit(ctx, teamName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpendingLimitResponse(rsp)
}

// CreateSpendingLimitWithBodyWithResponse request with arbitrary body returning *CreateSpendingLimitResponse
func (c *ClientWithResponses) CreateSpendingLimitWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpendingLimitResponse, error) {
	rsp, err := c.CreateSpendingLimitWithBody(ctx, teamName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpendingLimitResponse(rsp)
}

func (c *ClientWithResponses) CreateSpendingLimitWithResponse(ctx context.Context, teamName TeamName, body CreateSpendingLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpendingLimitResponse, error) {
	rsp, err := c.CreateSpendingLimit(ctx, teamName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpendingLimitResponse(rsp)
}

// UpdateSpendingLimitWithBodyWithResponse request with arbitrary body returning *UpdateSpendingLimitResponse
func (c *ClientWithResponses) UpdateSpendingLimitWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSpendingLimitResponse, error) {
	rsp, err := c.UpdateSpendingLimitWithBody(ctx, teamName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSpendingLimitResponse(rsp)
}

func (c *ClientWithResponses) UpdateSpendingLimitWithResponse(ctx context.Context, teamName TeamName, body UpdateSpendingLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSpendingLimitResponse, error) {
	rsp, err := c.UpdateSpendingLimit(ctx, teamName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSpendingLimitResponse(rsp)
}

// ListSubscriptionOrdersByTeamWithResponse request returning *ListSubscriptionOrdersByTeamResponse
func (c *ClientWithResponses) ListSubscriptionOrdersByTeamWithResponse(ctx context.Context, teamName TeamName, params *ListSubscriptionOrdersByTeamParams, reqEditors ...RequestEditorFn) (*ListSubscriptionOrdersByTeamResponse, error) {
	rsp, err := c.ListSubscriptionOrdersByTeam(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSubscriptionOrdersByTeamResponse(rsp)
}

// CreateSubscriptionOrderForTeamWithBodyWithResponse request with arbitrary body returning *CreateSubscriptionOrderForTeamResponse
func (c *ClientWithResponses) CreateSubscriptionOrderForTeamWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionOrderForTeamResponse, error) {
	rsp, err := c.CreateSubscriptionOrderForTeamWithBody(ctx, teamName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubscriptionOrderForTeamResponse(rsp)
}

func (c *ClientWithResponses) CreateSubscriptionOrderForTeamWithResponse(ctx context.Context, teamName TeamName, body CreateSubscriptionOrderForTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubscriptionOrderForTeamResponse, error) {
	rsp, err := c.CreateSubscriptionOrderForTeam(ctx, teamName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubscriptionOrderForTeamResponse(rsp)
}

// GetSubscriptionOrderByTeamWithResponse request returning *GetSubscriptionOrderByTeamResponse
func (c *ClientWithResponses) GetSubscriptionOrderByTeamWithResponse(ctx context.Context, teamName TeamName, teamSubscriptionOrderID TeamSubscriptionOrderID, reqEditors ...RequestEditorFn) (*GetSubscriptionOrderByTeamResponse, error) {
	rsp, err := c.GetSubscriptionOrderByTeam(ctx, teamName, teamSubscriptionOrderID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionOrderByTeamResponse(rsp)
}

// ListSyncDestinationsWithResponse request returning *ListSyncDestinationsResponse
func (c *ClientWithResponses) ListSyncDestinationsWithResponse(ctx context.Context, teamName TeamName, params *ListSyncDestinationsParams, reqEditors ...RequestEditorFn) (*ListSyncDestinationsResponse, error) {
	rsp, err := c.ListSyncDestinations(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSyncDestinationsResponse(rsp)
}

// CreateSyncDestinationWithBodyWithResponse request with arbitrary body returning *CreateSyncDestinationResponse
func (c *ClientWithResponses) CreateSyncDestinationWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSyncDestinationResponse, error) {
	rsp, err := c.CreateSyncDestinationWithBody(ctx, teamName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSyncDestinationResponse(rsp)
}

func (c *ClientWithResponses) CreateSyncDestinationWithResponse(ctx context.Context, teamName TeamName, body CreateSyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSyncDestinationResponse, error) {
	rsp, err := c.CreateSyncDestination(ctx, teamName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSyncDestinationResponse(rsp)
}

// TestSyncDestinationWithBodyWithResponse request with arbitrary body returning *TestSyncDestinationResponse
func (c *ClientWithResponses) TestSyncDestinationWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestSyncDestinationResponse, error) {
	rsp, err := c.TestSyncDestinationWithBody(ctx, teamName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestSyncDestinationResponse(rsp)
}

func (c *ClientWithResponses) TestSyncDestinationWithResponse(ctx context.Context, teamName TeamName, body TestSyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*TestSyncDestinationResponse, error) {
	rsp, err := c.TestSyncDestination(ctx, teamName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestSyncDestinationResponse(rsp)
}

// DeleteSyncDestinationWithResponse request returning *DeleteSyncDestinationResponse
func (c *ClientWithResponses) DeleteSyncDestinationWithResponse(ctx context.Context, teamName TeamName, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*DeleteSyncDestinationResponse, error) {
	rsp, err := c.DeleteSyncDestination(ctx, teamName, syncDestinationName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSyncDestinationResponse(rsp)
}

// GetSyncDestinationWithResponse request returning *GetSyncDestinationResponse
func (c *ClientWithResponses) GetSyncDestinationWithResponse(ctx context.Context, teamName TeamName, syncDestinationName SyncDestinationName, reqEditors ...RequestEditorFn) (*GetSyncDestinationResponse, error) {
	rsp, err := c.GetSyncDestination(ctx, teamName, syncDestinationName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncDestinationResponse(rsp)
}

// UpdateSyncDestinationWithBodyWithResponse request with arbitrary body returning *UpdateSyncDestinationResponse
func (c *ClientWithResponses) UpdateSyncDestinationWithBodyWithResponse(ctx context.Context, teamName TeamName, syncDestinationName SyncDestinationName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncDestinationResponse, error) {
	rsp, err := c.UpdateSyncDestinationWithBody(ctx, teamName, syncDestinationName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncDestinationResponse(rsp)
}

func (c *ClientWithResponses) UpdateSyncDestinationWithResponse(ctx context.Context, teamName TeamName, syncDestinationName SyncDestinationName, body UpdateSyncDestinationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncDestinationResponse, error) {
	rsp, err := c.UpdateSyncDestination(ctx, teamName, syncDestinationName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncDestinationResponse(rsp)
}

// ListSyncSourcesWithResponse request returning *ListSyncSourcesResponse
func (c *ClientWithResponses) ListSyncSourcesWithResponse(ctx context.Context, teamName TeamName, params *ListSyncSourcesParams, reqEditors ...RequestEditorFn) (*ListSyncSourcesResponse, error) {
	rsp, err := c.ListSyncSources(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSyncSourcesResponse(rsp)
}

// CreateSyncSourceWithBodyWithResponse request with arbitrary body returning *CreateSyncSourceResponse
func (c *ClientWithResponses) CreateSyncSourceWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSyncSourceResponse, error) {
	rsp, err := c.CreateSyncSourceWithBody(ctx, teamName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSyncSourceResponse(rsp)
}

func (c *ClientWithResponses) CreateSyncSourceWithResponse(ctx context.Context, teamName TeamName, body CreateSyncSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSyncSourceResponse, error) {
	rsp, err := c.CreateSyncSource(ctx, teamName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSyncSourceResponse(rsp)
}

// TestSyncSourceWithBodyWithResponse request with arbitrary body returning *TestSyncSourceResponse
func (c *ClientWithResponses) TestSyncSourceWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TestSyncSourceResponse, error) {
	rsp, err := c.TestSyncSourceWithBody(ctx, teamName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestSyncSourceResponse(rsp)
}

func (c *ClientWithResponses) TestSyncSourceWithResponse(ctx context.Context, teamName TeamName, body TestSyncSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*TestSyncSourceResponse, error) {
	rsp, err := c.TestSyncSource(ctx, teamName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTestSyncSourceResponse(rsp)
}

// DeleteSyncSourceWithResponse request returning *DeleteSyncSourceResponse
func (c *ClientWithResponses) DeleteSyncSourceWithResponse(ctx context.Context, teamName TeamName, syncSourceName SyncSourceName, reqEditors ...RequestEditorFn) (*DeleteSyncSourceResponse, error) {
	rsp, err := c.DeleteSyncSource(ctx, teamName, syncSourceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSyncSourceResponse(rsp)
}

// GetSyncSourceWithResponse request returning *GetSyncSourceResponse
func (c *ClientWithResponses) GetSyncSourceWithResponse(ctx context.Context, teamName TeamName, syncSourceName SyncSourceName, reqEditors ...RequestEditorFn) (*GetSyncSourceResponse, error) {
	rsp, err := c.GetSyncSource(ctx, teamName, syncSourceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncSourceResponse(rsp)
}

// UpdateSyncSourceWithBodyWithResponse request with arbitrary body returning *UpdateSyncSourceResponse
func (c *ClientWithResponses) UpdateSyncSourceWithBodyWithResponse(ctx context.Context, teamName TeamName, syncSourceName SyncSourceName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncSourceResponse, error) {
	rsp, err := c.UpdateSyncSourceWithBody(ctx, teamName, syncSourceName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncSourceResponse(rsp)
}

func (c *ClientWithResponses) UpdateSyncSourceWithResponse(ctx context.Context, teamName TeamName, syncSourceName SyncSourceName, body UpdateSyncSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncSourceResponse, error) {
	rsp, err := c.UpdateSyncSource(ctx, teamName, syncSourceName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncSourceResponse(rsp)
}

// ListSyncsWithResponse request returning *ListSyncsResponse
func (c *ClientWithResponses) ListSyncsWithResponse(ctx context.Context, teamName TeamName, params *ListSyncsParams, reqEditors ...RequestEditorFn) (*ListSyncsResponse, error) {
	rsp, err := c.ListSyncs(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSyncsResponse(rsp)
}

// CreateSyncWithBodyWithResponse request with arbitrary body returning *CreateSyncResponse
func (c *ClientWithResponses) CreateSyncWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSyncResponse, error) {
	rsp, err := c.CreateSyncWithBody(ctx, teamName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSyncResponse(rsp)
}

func (c *ClientWithResponses) CreateSyncWithResponse(ctx context.Context, teamName TeamName, body CreateSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSyncResponse, error) {
	rsp, err := c.CreateSync(ctx, teamName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSyncResponse(rsp)
}

// GetSyncTestConnectionWithResponse request returning *GetSyncTestConnectionResponse
func (c *ClientWithResponses) GetSyncTestConnectionWithResponse(ctx context.Context, teamName TeamName, syncTestConnectionId SyncTestConnectionId, reqEditors ...RequestEditorFn) (*GetSyncTestConnectionResponse, error) {
	rsp, err := c.GetSyncTestConnection(ctx, teamName, syncTestConnectionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncTestConnectionResponse(rsp)
}

// UpdateSyncTestConnectionWithBodyWithResponse request with arbitrary body returning *UpdateSyncTestConnectionResponse
func (c *ClientWithResponses) UpdateSyncTestConnectionWithBodyWithResponse(ctx context.Context, teamName TeamName, syncTestConnectionId SyncTestConnectionId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncTestConnectionResponse, error) {
	rsp, err := c.UpdateSyncTestConnectionWithBody(ctx, teamName, syncTestConnectionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncTestConnectionResponse(rsp)
}

func (c *ClientWithResponses) UpdateSyncTestConnectionWithResponse(ctx context.Context, teamName TeamName, syncTestConnectionId SyncTestConnectionId, body UpdateSyncTestConnectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncTestConnectionResponse, error) {
	rsp, err := c.UpdateSyncTestConnection(ctx, teamName, syncTestConnectionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncTestConnectionResponse(rsp)
}

// DeleteSyncWithResponse request returning *DeleteSyncResponse
func (c *ClientWithResponses) DeleteSyncWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, reqEditors ...RequestEditorFn) (*DeleteSyncResponse, error) {
	rsp, err := c.DeleteSync(ctx, teamName, syncName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSyncResponse(rsp)
}

// GetSyncWithResponse request returning *GetSyncResponse
func (c *ClientWithResponses) GetSyncWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, reqEditors ...RequestEditorFn) (*GetSyncResponse, error) {
	rsp, err := c.GetSync(ctx, teamName, syncName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncResponse(rsp)
}

// UpdateSyncWithBodyWithResponse request with arbitrary body returning *UpdateSyncResponse
func (c *ClientWithResponses) UpdateSyncWithBodyWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncResponse, error) {
	rsp, err := c.UpdateSyncWithBody(ctx, teamName, syncName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncResponse(rsp)
}

func (c *ClientWithResponses) UpdateSyncWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, body UpdateSyncJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncResponse, error) {
	rsp, err := c.UpdateSync(ctx, teamName, syncName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncResponse(rsp)
}

// ListSyncRunsWithResponse request returning *ListSyncRunsResponse
func (c *ClientWithResponses) ListSyncRunsWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, params *ListSyncRunsParams, reqEditors ...RequestEditorFn) (*ListSyncRunsResponse, error) {
	rsp, err := c.ListSyncRuns(ctx, teamName, syncName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSyncRunsResponse(rsp)
}

// CreateSyncRunWithResponse request returning *CreateSyncRunResponse
func (c *ClientWithResponses) CreateSyncRunWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, reqEditors ...RequestEditorFn) (*CreateSyncRunResponse, error) {
	rsp, err := c.CreateSyncRun(ctx, teamName, syncName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSyncRunResponse(rsp)
}

// GetSyncRunWithResponse request returning *GetSyncRunResponse
func (c *ClientWithResponses) GetSyncRunWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, reqEditors ...RequestEditorFn) (*GetSyncRunResponse, error) {
	rsp, err := c.GetSyncRun(ctx, teamName, syncName, syncRunId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncRunResponse(rsp)
}

// UpdateSyncRunWithBodyWithResponse request with arbitrary body returning *UpdateSyncRunResponse
func (c *ClientWithResponses) UpdateSyncRunWithBodyWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSyncRunResponse, error) {
	rsp, err := c.UpdateSyncRunWithBody(ctx, teamName, syncName, syncRunId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncRunResponse(rsp)
}

func (c *ClientWithResponses) UpdateSyncRunWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, body UpdateSyncRunJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSyncRunResponse, error) {
	rsp, err := c.UpdateSyncRun(ctx, teamName, syncName, syncRunId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSyncRunResponse(rsp)
}

// GetSyncRunLogsWithResponse request returning *GetSyncRunLogsResponse
func (c *ClientWithResponses) GetSyncRunLogsWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, params *GetSyncRunLogsParams, reqEditors ...RequestEditorFn) (*GetSyncRunLogsResponse, error) {
	rsp, err := c.GetSyncRunLogs(ctx, teamName, syncName, syncRunId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncRunLogsResponse(rsp)
}

// CreateSyncRunProgressWithBodyWithResponse request with arbitrary body returning *CreateSyncRunProgressResponse
func (c *ClientWithResponses) CreateSyncRunProgressWithBodyWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSyncRunProgressResponse, error) {
	rsp, err := c.CreateSyncRunProgressWithBody(ctx, teamName, syncName, syncRunId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSyncRunProgressResponse(rsp)
}

func (c *ClientWithResponses) CreateSyncRunProgressWithResponse(ctx context.Context, teamName TeamName, syncName SyncName, syncRunId SyncRunId, body CreateSyncRunProgressJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSyncRunProgressResponse, error) {
	rsp, err := c.CreateSyncRunProgress(ctx, teamName, syncName, syncRunId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSyncRunProgressResponse(rsp)
}

// ListTeamPluginUsageWithResponse request returning *ListTeamPluginUsageResponse
func (c *ClientWithResponses) ListTeamPluginUsageWithResponse(ctx context.Context, teamName TeamName, params *ListTeamPluginUsageParams, reqEditors ...RequestEditorFn) (*ListTeamPluginUsageResponse, error) {
	rsp, err := c.ListTeamPluginUsage(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTeamPluginUsageResponse(rsp)
}

// IncreaseTeamPluginUsageWithBodyWithResponse request with arbitrary body returning *IncreaseTeamPluginUsageResponse
func (c *ClientWithResponses) IncreaseTeamPluginUsageWithBodyWithResponse(ctx context.Context, teamName TeamName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IncreaseTeamPluginUsageResponse, error) {
	rsp, err := c.IncreaseTeamPluginUsageWithBody(ctx, teamName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIncreaseTeamPluginUsageResponse(rsp)
}

func (c *ClientWithResponses) IncreaseTeamPluginUsageWithResponse(ctx context.Context, teamName TeamName, body IncreaseTeamPluginUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*IncreaseTeamPluginUsageResponse, error) {
	rsp, err := c.IncreaseTeamPluginUsage(ctx, teamName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIncreaseTeamPluginUsageResponse(rsp)
}

// GetTeamUsageSummaryWithResponse request returning *GetTeamUsageSummaryResponse
func (c *ClientWithResponses) GetTeamUsageSummaryWithResponse(ctx context.Context, teamName TeamName, params *GetTeamUsageSummaryParams, reqEditors ...RequestEditorFn) (*GetTeamUsageSummaryResponse, error) {
	rsp, err := c.GetTeamUsageSummary(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamUsageSummaryResponse(rsp)
}

// GetGroupedTeamUsageSummaryWithResponse request returning *GetGroupedTeamUsageSummaryResponse
func (c *ClientWithResponses) GetGroupedTeamUsageSummaryWithResponse(ctx context.Context, teamName TeamName, groupBy GetGroupedTeamUsageSummaryParamsGroupBy, params *GetGroupedTeamUsageSummaryParams, reqEditors ...RequestEditorFn) (*GetGroupedTeamUsageSummaryResponse, error) {
	rsp, err := c.GetGroupedTeamUsageSummary(ctx, teamName, groupBy, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupedTeamUsageSummaryResponse(rsp)
}

// GetTeamPluginUsageWithResponse request returning *GetTeamPluginUsageResponse
func (c *ClientWithResponses) GetTeamPluginUsageWithResponse(ctx context.Context, teamName TeamName, pluginTeam PluginTeam, pluginKind PluginKind, pluginName PluginName, reqEditors ...RequestEditorFn) (*GetTeamPluginUsageResponse, error) {
	rsp, err := c.GetTeamPluginUsage(ctx, teamName, pluginTeam, pluginKind, pluginName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamPluginUsageResponse(rsp)
}

// ListUsersByTeamWithResponse request returning *ListUsersByTeamResponse
func (c *ClientWithResponses) ListUsersByTeamWithResponse(ctx context.Context, teamName TeamName, params *ListUsersByTeamParams, reqEditors ...RequestEditorFn) (*ListUsersByTeamResponse, error) {
	rsp, err := c.ListUsersByTeam(ctx, teamName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersByTeamResponse(rsp)
}

// UploadImageWithResponse request returning *UploadImageResponse
func (c *ClientWithResponses) UploadImageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UploadImageResponse, error) {
	rsp, err := c.UploadImage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadImageResponse(rsp)
}

// GetCurrentUserWithResponse request returning *GetCurrentUserResponse
func (c *ClientWithResponses) GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error) {
	rsp, err := c.GetCurrentUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentUserResponse(rsp)
}

// UpdateCurrentUserWithBodyWithResponse request with arbitrary body returning *UpdateCurrentUserResponse
func (c *ClientWithResponses) UpdateCurrentUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCurrentUserResponse, error) {
	rsp, err := c.UpdateCurrentUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCurrentUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateCurrentUserWithResponse(ctx context.Context, body UpdateCurrentUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCurrentUserResponse, error) {
	rsp, err := c.UpdateCurrentUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCurrentUserResponse(rsp)
}

// ListCurrentUserInvitationsWithResponse request returning *ListCurrentUserInvitationsResponse
func (c *ClientWithResponses) ListCurrentUserInvitationsWithResponse(ctx context.Context, params *ListCurrentUserInvitationsParams, reqEditors ...RequestEditorFn) (*ListCurrentUserInvitationsResponse, error) {
	rsp, err := c.ListCurrentUserInvitations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCurrentUserInvitationsResponse(rsp)
}

// GetCurrentUserMembershipsWithResponse request returning *GetCurrentUserMembershipsResponse
func (c *ClientWithResponses) GetCurrentUserMembershipsWithResponse(ctx context.Context, params *GetCurrentUserMembershipsParams, reqEditors ...RequestEditorFn) (*GetCurrentUserMembershipsResponse, error) {
	rsp, err := c.GetCurrentUserMemberships(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentUserMembershipsResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, userID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// ParseHealthCheckResponse parses an HTTP response from a HealthCheckWithResponse call
func ParseHealthCheckResponse(rsp *http.Response) (*HealthCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListAddonsResponse parses an HTTP response from a ListAddonsWithResponse call
func ParseListAddonsResponse(rsp *http.Response) (*ListAddonsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAddonsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAddons200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAddonResponse parses an HTTP response from a CreateAddonWithResponse call
func ParseCreateAddonResponse(rsp *http.Response) (*CreateAddonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAddonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Addon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAddonByTeamAndNameResponse parses an HTTP response from a DeleteAddonByTeamAndNameWithResponse call
func ParseDeleteAddonByTeamAndNameResponse(rsp *http.Response) (*DeleteAddonByTeamAndNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAddonByTeamAndNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAddonResponse parses an HTTP response from a GetAddonWithResponse call
func ParseGetAddonResponse(rsp *http.Response) (*GetAddonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAddonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAddon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAddonResponse parses an HTTP response from a UpdateAddonWithResponse call
func ParseUpdateAddonResponse(rsp *http.Response) (*UpdateAddonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAddonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Addon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAddonVersionsResponse parses an HTTP response from a ListAddonVersionsWithResponse call
func ParseListAddonVersionsResponse(rsp *http.Response) (*ListAddonVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAddonVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAddonVersions200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAddonVersionResponse parses an HTTP response from a GetAddonVersionWithResponse call
func ParseGetAddonVersionResponse(rsp *http.Response) (*GetAddonVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAddonVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddonVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAddonVersionResponse parses an HTTP response from a UpdateAddonVersionWithResponse call
func ParseUpdateAddonVersionResponse(rsp *http.Response) (*UpdateAddonVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAddonVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddonVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAddonVersionResponse parses an HTTP response from a CreateAddonVersionWithResponse call
func ParseCreateAddonVersionResponse(rsp *http.Response) (*CreateAddonVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAddonVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddonVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AddonVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDownloadAddonAssetResponse parses an HTTP response from a DownloadAddonAssetWithResponse call
func ParseDownloadAddonAssetResponse(rsp *http.Response) (*DownloadAddonAssetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadAddonAssetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddonAsset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadAddonAssetResponse parses an HTTP response from a UploadAddonAssetWithResponse call
func ParseUploadAddonAssetResponse(rsp *http.Response) (*UploadAddonAssetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadAddonAssetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ReleaseURL
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCQHealthCheckResponse parses an HTTP response from a CQHealthCheckWithResponse call
func ParseCQHealthCheckResponse(rsp *http.Response) (*CQHealthCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CQHealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListPluginNotificationRequestsResponse parses an HTTP response from a ListPluginNotificationRequestsWithResponse call
func ParseListPluginNotificationRequestsResponse(rsp *http.Response) (*ListPluginNotificationRequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPluginNotificationRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPluginNotificationRequests200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreatePluginNotificationRequestResponse parses an HTTP response from a CreatePluginNotificationRequestWithResponse call
func ParseCreatePluginNotificationRequestResponse(rsp *http.Response) (*CreatePluginNotificationRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePluginNotificationRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PluginNotificationRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePluginNotificationRequestResponse parses an HTTP response from a DeletePluginNotificationRequestWithResponse call
func ParseDeletePluginNotificationRequestResponse(rsp *http.Response) (*DeletePluginNotificationRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePluginNotificationRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPluginNotificationRequestResponse parses an HTTP response from a GetPluginNotificationRequestWithResponse call
func ParseGetPluginNotificationRequestResponse(rsp *http.Response) (*GetPluginNotificationRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPluginNotificationRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPluginNotificationRequests200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPluginsResponse parses an HTTP response from a ListPluginsWithResponse call
func ParseListPluginsResponse(rsp *http.Response) (*ListPluginsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPluginsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPlugins200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreatePluginResponse parses an HTTP response from a CreatePluginWithResponse call
func ParseCreatePluginResponse(rsp *http.Response) (*CreatePluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Plugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePluginByTeamAndPluginNameResponse parses an HTTP response from a DeletePluginByTeamAndPluginNameWithResponse call
func ParseDeletePluginByTeamAndPluginNameResponse(rsp *http.Response) (*DeletePluginByTeamAndPluginNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePluginByTeamAndPluginNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPluginResponse parses an HTTP response from a GetPluginWithResponse call
func ParseGetPluginResponse(rsp *http.Response) (*GetPluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPlugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdatePluginResponse parses an HTTP response from a UpdatePluginWithResponse call
func ParseUpdatePluginResponse(rsp *http.Response) (*UpdatePluginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePluginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePluginUpcomingPriceChangesResponse parses an HTTP response from a DeletePluginUpcomingPriceChangesWithResponse call
func ParseDeletePluginUpcomingPriceChangesResponse(rsp *http.Response) (*DeletePluginUpcomingPriceChangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePluginUpcomingPriceChangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPluginUpcomingPriceChangesResponse parses an HTTP response from a ListPluginUpcomingPriceChangesWithResponse call
func ParseListPluginUpcomingPriceChangesResponse(rsp *http.Response) (*ListPluginUpcomingPriceChangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPluginUpcomingPriceChangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPluginUpcomingPriceChanges200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreatePluginUpcomingPriceChangeResponse parses an HTTP response from a CreatePluginUpcomingPriceChangeWithResponse call
func ParseCreatePluginUpcomingPriceChangeResponse(rsp *http.Response) (*CreatePluginUpcomingPriceChangeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePluginUpcomingPriceChangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PluginPrice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPluginVersionsResponse parses an HTTP response from a ListPluginVersionsWithResponse call
func ParseListPluginVersionsResponse(rsp *http.Response) (*ListPluginVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPluginVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPluginVersions200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPluginVersionResponse parses an HTTP response from a GetPluginVersionWithResponse call
func ParseGetPluginVersionResponse(rsp *http.Response) (*GetPluginVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPluginVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PluginVersionDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdatePluginVersionResponse parses an HTTP response from a UpdatePluginVersionWithResponse call
func ParseUpdatePluginVersionResponse(rsp *http.Response) (*UpdatePluginVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePluginVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PluginVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreatePluginVersionResponse parses an HTTP response from a CreatePluginVersionWithResponse call
func ParseCreatePluginVersionResponse(rsp *http.Response) (*CreatePluginVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePluginVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PluginVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PluginVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDownloadPluginAssetResponse parses an HTTP response from a DownloadPluginAssetWithResponse call
func ParseDownloadPluginAssetResponse(rsp *http.Response) (*DownloadPluginAssetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadPluginAssetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PluginAsset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadPluginAssetResponse parses an HTTP response from a UploadPluginAssetWithResponse call
func ParseUploadPluginAssetResponse(rsp *http.Response) (*UploadPluginAssetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadPluginAssetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ReleaseURL
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePluginVersionDocsResponse parses an HTTP response from a DeletePluginVersionDocsWithResponse call
func ParseDeletePluginVersionDocsResponse(rsp *http.Response) (*DeletePluginVersionDocsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePluginVersionDocsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPluginVersionDocsResponse parses an HTTP response from a ListPluginVersionDocsWithResponse call
func ParseListPluginVersionDocsResponse(rsp *http.Response) (*ListPluginVersionDocsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPluginVersionDocsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPluginVersionDocs200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReplacePluginVersionDocsResponse parses an HTTP response from a ReplacePluginVersionDocsWithResponse call
func ParseReplacePluginVersionDocsResponse(rsp *http.Response) (*ReplacePluginVersionDocsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplacePluginVersionDocsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreatePluginVersionDocs201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreatePluginVersionDocsResponse parses an HTTP response from a CreatePluginVersionDocsWithResponse call
func ParseCreatePluginVersionDocsResponse(rsp *http.Response) (*CreatePluginVersionDocsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePluginVersionDocsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreatePluginVersionDocs201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePluginVersionTablesResponse parses an HTTP response from a DeletePluginVersionTablesWithResponse call
func ParseDeletePluginVersionTablesResponse(rsp *http.Response) (*DeletePluginVersionTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePluginVersionTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPluginVersionTablesResponse parses an HTTP response from a ListPluginVersionTablesWithResponse call
func ParseListPluginVersionTablesResponse(rsp *http.Response) (*ListPluginVersionTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPluginVersionTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPluginVersionTables200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreatePluginVersionTablesResponse parses an HTTP response from a CreatePluginVersionTablesWithResponse call
func ParseCreatePluginVersionTablesResponse(rsp *http.Response) (*CreatePluginVersionTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePluginVersionTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreatePluginVersionTables201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPluginVersionTableResponse parses an HTTP response from a GetPluginVersionTableWithResponse call
func ParseGetPluginVersionTableResponse(rsp *http.Response) (*GetPluginVersionTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPluginVersionTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PluginTableDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuthRegistryRequestResponse parses an HTTP response from a AuthRegistryRequestWithResponse call
func ParseAuthRegistryRequestResponse(rsp *http.Response) (*AuthRegistryRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthRegistryRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegistryAuthToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest DockerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest DockerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest DockerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest DockerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest DockerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTeamsResponse parses an HTTP response from a ListTeamsWithResponse call
func ParseListTeamsResponse(rsp *http.Response) (*ListTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTeams200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateTeamResponse parses an HTTP response from a CreateTeamWithResponse call
func ParseCreateTeamResponse(rsp *http.Response) (*CreateTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTeamResponse parses an HTTP response from a DeleteTeamWithResponse call
func ParseDeleteTeamResponse(rsp *http.Response) (*DeleteTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTeamByNameResponse parses an HTTP response from a GetTeamByNameWithResponse call
func ParseGetTeamByNameResponse(rsp *http.Response) (*GetTeamByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateTeamResponse parses an HTTP response from a UpdateTeamWithResponse call
func ParseUpdateTeamResponse(rsp *http.Response) (*UpdateTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAddonOrdersByTeamResponse parses an HTTP response from a ListAddonOrdersByTeamWithResponse call
func ParseListAddonOrdersByTeamResponse(rsp *http.Response) (*ListAddonOrdersByTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAddonOrdersByTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAddonOrdersByTeam200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAddonOrderForTeamResponse parses an HTTP response from a CreateAddonOrderForTeamWithResponse call
func ParseCreateAddonOrderForTeamResponse(rsp *http.Response) (*CreateAddonOrderForTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAddonOrderForTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AddonOrder
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAddonOrderByTeamResponse parses an HTTP response from a GetAddonOrderByTeamWithResponse call
func ParseGetAddonOrderByTeamResponse(rsp *http.Response) (*GetAddonOrderByTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAddonOrderByTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddonOrder
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAddonsByTeamResponse parses an HTTP response from a DeleteAddonsByTeamWithResponse call
func ParseDeleteAddonsByTeamResponse(rsp *http.Response) (*DeleteAddonsByTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAddonsByTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAddonsByTeamResponse parses an HTTP response from a ListAddonsByTeamWithResponse call
func ParseListAddonsByTeamResponse(rsp *http.Response) (*ListAddonsByTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAddonsByTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAddonsByTeam200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDownloadAddonAssetByTeamResponse parses an HTTP response from a DownloadAddonAssetByTeamWithResponse call
func ParseDownloadAddonAssetByTeamResponse(rsp *http.Response) (*DownloadAddonAssetByTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadAddonAssetByTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddonAsset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTeamAPIKeysResponse parses an HTTP response from a ListTeamAPIKeysWithResponse call
func ParseListTeamAPIKeysResponse(rsp *http.Response) (*ListTeamAPIKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTeamAPIKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTeamAPIKeys200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateTeamAPIKeyResponse parses an HTTP response from a CreateTeamAPIKeyWithResponse call
func ParseCreateTeamAPIKeyResponse(rsp *http.Response) (*CreateTeamAPIKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTeamAPIKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest APIKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTeamAPIKeyResponse parses an HTTP response from a DeleteTeamAPIKeyWithResponse call
func ParseDeleteTeamAPIKeyResponse(rsp *http.Response) (*DeleteTeamAPIKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTeamAPIKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateTeamImagesResponse parses an HTTP response from a CreateTeamImagesWithResponse call
func ParseCreateTeamImagesResponse(rsp *http.Response) (*CreateTeamImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTeamImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateTeamImages201Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTeamInvitationResponse parses an HTTP response from a DeleteTeamInvitationWithResponse call
func ParseDeleteTeamInvitationResponse(rsp *http.Response) (*DeleteTeamInvitationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTeamInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTeamInvitationsResponse parses an HTTP response from a ListTeamInvitationsWithResponse call
func ParseListTeamInvitationsResponse(rsp *http.Response) (*ListTeamInvitationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTeamInvitationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTeamInvitations200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEmailTeamInvitationResponse parses an HTTP response from a EmailTeamInvitationWithResponse call
func ParseEmailTeamInvitationResponse(rsp *http.Response) (*EmailTeamInvitationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmailTeamInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Invitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Invitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAcceptTeamInvitationResponse parses an HTTP response from a AcceptTeamInvitationWithResponse call
func ParseAcceptTeamInvitationResponse(rsp *http.Response) (*AcceptTeamInvitationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptTeamInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MembershipWithTeam
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 303:
		var dest MembershipWithTeam
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON303 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCancelTeamInvitationResponse parses an HTTP response from a CancelTeamInvitationWithResponse call
func ParseCancelTeamInvitationResponse(rsp *http.Response) (*CancelTeamInvitationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelTeamInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListInvoicesByTeamResponse parses an HTTP response from a ListInvoicesByTeamWithResponse call
func ParseListInvoicesByTeamResponse(rsp *http.Response) (*ListInvoicesByTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInvoicesByTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListInvoicesByTeam200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetManagedDatabasesResponse parses an HTTP response from a GetManagedDatabasesWithResponse call
func ParseGetManagedDatabasesResponse(rsp *http.Response) (*GetManagedDatabasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetManagedDatabasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetManagedDatabases200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateManagedDatabaseResponse parses an HTTP response from a CreateManagedDatabaseWithResponse call
func ParseCreateManagedDatabaseResponse(rsp *http.Response) (*CreateManagedDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManagedDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ManagedDatabase
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteManagedDatabaseResponse parses an HTTP response from a DeleteManagedDatabaseWithResponse call
func ParseDeleteManagedDatabaseResponse(rsp *http.Response) (*DeleteManagedDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManagedDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetManagedDatabaseResponse parses an HTTP response from a GetManagedDatabaseWithResponse call
func ParseGetManagedDatabaseResponse(rsp *http.Response) (*GetManagedDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetManagedDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManagedDatabase
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTeamMembershipsResponse parses an HTTP response from a GetTeamMembershipsWithResponse call
func ParseGetTeamMembershipsResponse(rsp *http.Response) (*GetTeamMembershipsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamMembershipsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetTeamMemberships200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTeamMembershipResponse parses an HTTP response from a DeleteTeamMembershipWithResponse call
func ParseDeleteTeamMembershipResponse(rsp *http.Response) (*DeleteTeamMembershipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTeamMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePluginsByTeamResponse parses an HTTP response from a DeletePluginsByTeamWithResponse call
func ParseDeletePluginsByTeamResponse(rsp *http.Response) (*DeletePluginsByTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePluginsByTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPluginsByTeamResponse parses an HTTP response from a ListPluginsByTeamWithResponse call
func ParseListPluginsByTeamResponse(rsp *http.Response) (*ListPluginsByTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPluginsByTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPluginsByTeam200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDownloadPluginAssetByTeamResponse parses an HTTP response from a DownloadPluginAssetByTeamWithResponse call
func ParseDownloadPluginAssetByTeamResponse(rsp *http.Response) (*DownloadPluginAssetByTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadPluginAssetByTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PluginAsset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTeamSpendResponse parses an HTTP response from a GetTeamSpendWithResponse call
func ParseGetTeamSpendResponse(rsp *http.Response) (*GetTeamSpendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamSpendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpendSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSpendingLimitResponse parses an HTTP response from a DeleteSpendingLimitWithResponse call
func ParseDeleteSpendingLimitResponse(rsp *http.Response) (*DeleteSpendingLimitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpendingLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSpendingLimitResponse parses an HTTP response from a GetSpendingLimitWithResponse call
func ParseGetSpendingLimitResponse(rsp *http.Response) (*GetSpendingLimitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpendingLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpendingLimit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSpendingLimitResponse parses an HTTP response from a CreateSpendingLimitWithResponse call
func ParseCreateSpendingLimitResponse(rsp *http.Response) (*CreateSpendingLimitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpendingLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SpendingLimit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSpendingLimitResponse parses an HTTP response from a UpdateSpendingLimitWithResponse call
func ParseUpdateSpendingLimitResponse(rsp *http.Response) (*UpdateSpendingLimitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSpendingLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpendingLimit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSubscriptionOrdersByTeamResponse parses an HTTP response from a ListSubscriptionOrdersByTeamWithResponse call
func ParseListSubscriptionOrdersByTeamResponse(rsp *http.Response) (*ListSubscriptionOrdersByTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSubscriptionOrdersByTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSubscriptionOrdersByTeam200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSubscriptionOrderForTeamResponse parses an HTTP response from a CreateSubscriptionOrderForTeamWithResponse call
func ParseCreateSubscriptionOrderForTeamResponse(rsp *http.Response) (*CreateSubscriptionOrderForTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSubscriptionOrderForTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TeamSubscriptionOrder
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSubscriptionOrderByTeamResponse parses an HTTP response from a GetSubscriptionOrderByTeamWithResponse call
func ParseGetSubscriptionOrderByTeamResponse(rsp *http.Response) (*GetSubscriptionOrderByTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionOrderByTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamSubscriptionOrder
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSyncDestinationsResponse parses an HTTP response from a ListSyncDestinationsWithResponse call
func ParseListSyncDestinationsResponse(rsp *http.Response) (*ListSyncDestinationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSyncDestinationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSyncDestinations200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSyncDestinationResponse parses an HTTP response from a CreateSyncDestinationWithResponse call
func ParseCreateSyncDestinationResponse(rsp *http.Response) (*CreateSyncDestinationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSyncDestinationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTestSyncDestinationResponse parses an HTTP response from a TestSyncDestinationWithResponse call
func ParseTestSyncDestinationResponse(rsp *http.Response) (*TestSyncDestinationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestSyncDestinationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncTestConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSyncDestinationResponse parses an HTTP response from a DeleteSyncDestinationWithResponse call
func ParseDeleteSyncDestinationResponse(rsp *http.Response) (*DeleteSyncDestinationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSyncDestinationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncDestinationResponse parses an HTTP response from a GetSyncDestinationWithResponse call
func ParseGetSyncDestinationResponse(rsp *http.Response) (*GetSyncDestinationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncDestinationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSyncDestinationResponse parses an HTTP response from a UpdateSyncDestinationWithResponse call
func ParseUpdateSyncDestinationResponse(rsp *http.Response) (*UpdateSyncDestinationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSyncDestinationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncDestination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSyncSourcesResponse parses an HTTP response from a ListSyncSourcesWithResponse call
func ParseListSyncSourcesResponse(rsp *http.Response) (*ListSyncSourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSyncSourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSyncSources200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSyncSourceResponse parses an HTTP response from a CreateSyncSourceWithResponse call
func ParseCreateSyncSourceResponse(rsp *http.Response) (*CreateSyncSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSyncSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncSource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTestSyncSourceResponse parses an HTTP response from a TestSyncSourceWithResponse call
func ParseTestSyncSourceResponse(rsp *http.Response) (*TestSyncSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TestSyncSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncTestConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSyncSourceResponse parses an HTTP response from a DeleteSyncSourceWithResponse call
func ParseDeleteSyncSourceResponse(rsp *http.Response) (*DeleteSyncSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSyncSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncSourceResponse parses an HTTP response from a GetSyncSourceWithResponse call
func ParseGetSyncSourceResponse(rsp *http.Response) (*GetSyncSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncSource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSyncSourceResponse parses an HTTP response from a UpdateSyncSourceWithResponse call
func ParseUpdateSyncSourceResponse(rsp *http.Response) (*UpdateSyncSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSyncSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncSource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSyncsResponse parses an HTTP response from a ListSyncsWithResponse call
func ParseListSyncsResponse(rsp *http.Response) (*ListSyncsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSyncsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSyncs200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSyncResponse parses an HTTP response from a CreateSyncWithResponse call
func ParseCreateSyncResponse(rsp *http.Response) (*CreateSyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Sync
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncTestConnectionResponse parses an HTTP response from a GetSyncTestConnectionWithResponse call
func ParseGetSyncTestConnectionResponse(rsp *http.Response) (*GetSyncTestConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncTestConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncTestConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSyncTestConnectionResponse parses an HTTP response from a UpdateSyncTestConnectionWithResponse call
func ParseUpdateSyncTestConnectionResponse(rsp *http.Response) (*UpdateSyncTestConnectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSyncTestConnectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncTestConnection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSyncResponse parses an HTTP response from a DeleteSyncWithResponse call
func ParseDeleteSyncResponse(rsp *http.Response) (*DeleteSyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncResponse parses an HTTP response from a GetSyncWithResponse call
func ParseGetSyncResponse(rsp *http.Response) (*GetSyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sync
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSyncResponse parses an HTTP response from a UpdateSyncWithResponse call
func ParseUpdateSyncResponse(rsp *http.Response) (*UpdateSyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sync
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSyncRunsResponse parses an HTTP response from a ListSyncRunsWithResponse call
func ParseListSyncRunsResponse(rsp *http.Response) (*ListSyncRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSyncRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSyncRuns200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSyncRunResponse parses an HTTP response from a CreateSyncRunWithResponse call
func ParseCreateSyncRunResponse(rsp *http.Response) (*CreateSyncRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSyncRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncRunResponse parses an HTTP response from a GetSyncRunWithResponse call
func ParseGetSyncRunResponse(rsp *http.Response) (*GetSyncRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncRunDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSyncRunResponse parses an HTTP response from a UpdateSyncRunWithResponse call
func ParseUpdateSyncRunResponse(rsp *http.Response) (*UpdateSyncRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSyncRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyncRunLogsResponse parses an HTTP response from a GetSyncRunLogsWithResponse call
func ParseGetSyncRunLogsResponse(rsp *http.Response) (*GetSyncRunLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncRunLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncRunLogs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseCreateSyncRunProgressResponse parses an HTTP response from a CreateSyncRunProgressWithResponse call
func ParseCreateSyncRunProgressResponse(rsp *http.Response) (*CreateSyncRunProgressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSyncRunProgressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTeamPluginUsageResponse parses an HTTP response from a ListTeamPluginUsageWithResponse call
func ParseListTeamPluginUsageResponse(rsp *http.Response) (*ListTeamPluginUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTeamPluginUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTeamPluginUsage200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIncreaseTeamPluginUsageResponse parses an HTTP response from a IncreaseTeamPluginUsageWithResponse call
func ParseIncreaseTeamPluginUsageResponse(rsp *http.Response) (*IncreaseTeamPluginUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IncreaseTeamPluginUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ServiceUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetTeamUsageSummaryResponse parses an HTTP response from a GetTeamUsageSummaryWithResponse call
func ParseGetTeamUsageSummaryResponse(rsp *http.Response) (*GetTeamUsageSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamUsageSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsageSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupedTeamUsageSummaryResponse parses an HTTP response from a GetGroupedTeamUsageSummaryWithResponse call
func ParseGetGroupedTeamUsageSummaryResponse(rsp *http.Response) (*GetGroupedTeamUsageSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupedTeamUsageSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsageSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTeamPluginUsageResponse parses an HTTP response from a GetTeamPluginUsageWithResponse call
func ParseGetTeamPluginUsageResponse(rsp *http.Response) (*GetTeamPluginUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamPluginUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsageCurrent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListUsersByTeamResponse parses an HTTP response from a ListUsersByTeamWithResponse call
func ParseListUsersByTeamResponse(rsp *http.Response) (*ListUsersByTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersByTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListUsersByTeam200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadImageResponse parses an HTTP response from a UploadImageWithResponse call
func ParseUploadImageResponse(rsp *http.Response) (*UploadImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImageURL
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCurrentUserResponse parses an HTTP response from a GetCurrentUserWithResponse call
func ParseGetCurrentUserResponse(rsp *http.Response) (*GetCurrentUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateCurrentUserResponse parses an HTTP response from a UpdateCurrentUserWithResponse call
func ParseUpdateCurrentUserResponse(rsp *http.Response) (*UpdateCurrentUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest MethodNotAllowed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListCurrentUserInvitationsResponse parses an HTTP response from a ListCurrentUserInvitationsWithResponse call
func ParseListCurrentUserInvitationsResponse(rsp *http.Response) (*ListCurrentUserInvitationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCurrentUserInvitationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListCurrentUserInvitations200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCurrentUserMembershipsResponse parses an HTTP response from a GetCurrentUserMembershipsWithResponse call
func ParseGetCurrentUserMembershipsResponse(rsp *http.Response) (*GetCurrentUserMembershipsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentUserMembershipsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCurrentUserMemberships200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequiresAuthentication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
